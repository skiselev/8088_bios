     1                                  ;=========================================================================
     2                                  ; main.asm - BIOS main file
     3                                  ;	Skeleton for the BIOS
     4                                  ;	Power On Self Test (POST)
     5                                  ;	Interrupt table setup
     6                                  ;       INT 11h - Get equipment list
     7                                  ;       INT 12h - Get memory size
     8                                  ;-------------------------------------------------------------------------
     9                                  ;
    10                                  ; Compiles with NASM 2.13.02, might work with other versions
    11                                  ;
    12                                  ; Copyright (C) 2010 - 2025 Sergey Kiselev.
    13                                  ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    14                                  ;
    15                                  ; This program is free software: you can redistribute it and/or modify
    16                                  ; it under the terms of the GNU General Public License as published by
    17                                  ; the Free Software Foundation, either version 3 of the License, or
    18                                  ; (at your option) any later version.
    19                                  ;
    20                                  ; This program is distributed in the hope that it will be useful,
    21                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                                  ; GNU General Public License for more details.
    24                                  ;
    25                                  ; You should have received a copy of the GNU General Public License
    26                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                                  ;
    28                                  ;=========================================================================
    29                                  
    30                                  ;-------------------------------------------------------------------------
    31                                  ; Fixed BIOS Entry Points
    32                                  ; Source:
    33                                  ;	Intel(R) Platform Innovation Framework for EFI
    34                                  ;	Compatibility Support Module Specification
    35                                  ;	Section 5.2
    36                                  ;
    37                                  ;	Location	Description
    38                                  ;	--------	-----------
    39                                  ;	F000:E05B	POST Entry Point
    40                                  ;	F000:E2C3	NMI Entry Point
    41                                  ;	F000:E401	HDD Parameter Table
    42                                  ;	F000:E6F2	INT 19 Entry Point
    43                                  ;	F000:E6F5	Configuration Data Table
    44                                  ;	F000:E729	Baut Rate Generator Table
    45                                  ;	F000:E739	INT 14 Entry Point
    46                                  ;	F000:E82E	INT 16 Entry Point
    47                                  ;	F000:E987	INT 09 Entry Point
    48                                  ;	F000:EC59	INT 13 (Floppy) Entry Point
    49                                  ;	F000:EF57	INT 0E Entry Point
    50                                  ;	F000:EFC7	Floppy Disk Controller Parameter Table
    51                                  ;	F000:EFD2	INT 17
    52                                  ;	F000:F065	INT 10 (Video) Entry Point
    53                                  ;	F000:F0A4	INT 1D MDA and CGA Video Parameter Table
    54                                  ;	F000:F841	INT 12 Entry Point
    55                                  ;	F000:F84D	INT 11 Entry Point
    56                                  ;	F000:F859	INT 15 Entry Point
    57                                  ;	F000:FA6E	Low 128 Characters of Graphic Video Font
    58                                  ;	F000:FE6E	INT 1A Entry Point
    59                                  ;	F000:FEA5	INT 08 Entry Point
    60                                  ;	F000:FF53	Dummy Interrupt Handler (IRET)
    61                                  ;	F000:FF54	INT 05 (Print Screen) Entry Point
    62                                  ;	F000:FFF0	Power-On Entry Point
    63                                  ;	F000:FFF5	ROM Date in ASCII "MM/DD/YY" Format (8 Characters)
    64                                  ;	F000:FFFE	System Model (0xFC - AT, 0xFE - XT)
    65                                  
    66                                  	cpu	8086
    67                                  
    68                                  %include "macro.inc"
    69                              <1> ;=========================================================================
    70                              <1> ; macro.inc - Defines macros
    71                              <1> ;       setloc
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> ;
    74                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    75                              <1> ;
    76                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
    77                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    78                              <1> ;
    79                              <1> ; This program is free software: you can redistribute it and/or modify
    80                              <1> ; it under the terms of the GNU General Public License as published by
    81                              <1> ; the Free Software Foundation, either version 3 of the License, or
    82                              <1> ; (at your option) any later version.
    83                              <1> ;
    84                              <1> ; This program is distributed in the hope that it will be useful,
    85                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    86                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    87                              <1> ; GNU General Public License for more details.
    88                              <1> ;
    89                              <1> ; You should have received a copy of the GNU General Public License
    90                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    91                              <1> ;
    92                              <1> ;=========================================================================
    93                              <1> 
    94                              <1> ;=========================================================================
    95                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    96                              <1> ;-------------------------------------------------------------------------
    97                              <1> %imacro setloc  1.nolist
    98                              <1> %assign pad_bytes (%1-($-$$)-START)
    99                              <1> %if pad_bytes < 0
   100                              <1> %assign over_bytes -pad_bytes
   101                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
   102                              <1> %endif
   103                              <1> %if pad_bytes > 0
   104                              <1> %warning Inserting pad_bytes bytes
   105                              <1>  times  pad_bytes db 0FFh
   106                              <1> %endif
   107                              <1> %endm
    69                                  %include "config.inc"
    70                              <1> ;=========================================================================
    71                              <1> ; config.inc - Compilation time settings and settings
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> ;
    74                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    75                              <1> ;
    76                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
    77                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    78                              <1> ;
    79                              <1> ; This program is free software: you can redistribute it and/or modify
    80                              <1> ; it under the terms of the GNU General Public License as published by
    81                              <1> ; the Free Software Foundation, either version 3 of the License, or
    82                              <1> ; (at your option) any later version.
    83                              <1> ;
    84                              <1> ; This program is distributed in the hope that it will be useful,
    85                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    86                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    87                              <1> ; GNU General Public License for more details.
    88                              <1> ;
    89                              <1> ; You should have received a copy of the GNU General Public License
    90                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    91                              <1> ;
    92                              <1> ;=========================================================================
    93                              <1> 
    94                              <1> %define DATE		'09/27/25'	; BIOS release date MM/DD/YY
    95                              <1> %define VERSION		'1.0.1'		; BIOS version
    96                              <1> 
    97                              <1> ; Machine type is defined in the Makefile
    98                              <1> ;%define MACHINE_XI8088			; Xi 8088
    99                              <1> ;%define MACHINE_FE2010A 		; Faraday FE2010A
   100                              <1> ;%define MACHINE_BOOK8088		; Book8088
   101                              <1> ;%define MACHINE_HOMEBREW8088		; EMM Computers "Homebrew8088" board
   102                              <1> ;%define MACHINE_XT			; IBM PC/XT or highly compatible board
   103                              <1> 					; FIXME: not implemented yet
   104                              <1> 
   105                              <1> ; Settings for Xi 8088
   106                              <1> %ifdef MACHINE_XI8088
   107                              <1> %define	START		8000h		; BIOS starts at offset 8000h
   108                              <1> %define MODEL_BYTE	0FCh		; Pretend it is an IBM PC/AT
   109                              <1> %define AT_RTC				; Has AT-compatible RTC
   110                              <1> %define AT_RTC_NVRAM			; Use AT RTC for BIOS configuration
   111                              <1> %define AT_NMI				; Use port 70h for NMI enable/disable
   112                              <1> %define AT_DELAY			; Use refresh bit of port 61h for delays
   113                              <1> %define SECOND_PIC			; Has two PICs (AT-style)
   114                              <1> %define AT_KEYBOARD			; Has AT-compatible keyboard controller
   115                              <1> %define PS2_MOUSE			; Enable PS/2 auxiliary device support
   116                              <1> %define DISABLE_KBD_DURING_INTERRUPTS	; Don't disable keyboard in INT1
   117                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   118                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   119                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   120                              <1> %define EBDA_SIZE	1		; 1KB reserved for EBDA
   121                              <1> 					; EBDA is required for PS/2 aux support
   122                              <1> %endif ; MACHINE_XI8088
   123                              <1> 
   124                              <1> ; Settings for FE2010A
   125                              <1> %ifdef MACHINE_FE2010A
   126                              <1> %define	START		0A000h		; BIOS starts at offset 0A000h
   127                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
   128                              <1> %define AT_RTC				; Has AT-compatible RTC
   129                              <1> %define AT_RTC_AUTODETECT		; Autodetect RTC presence
   130                              <1> %define FLASH_NVRAM			; Use Flash ROM for BIOS configuration
   131                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   132                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   133                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   134                              <1> %define PIT_DELAY			; Use PIT polling for delays
   135                              <1> %endif ; MACHINE_FE2010A
   136                              <1> 
   137                              <1> ; Settings for Book8088
   138                              <1> %ifdef MACHINE_BOOK8088
   139                              <1> %define	START		0C000h		; BIOS starts at 0C000h - 16 KiB total
   140                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
   141                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   142                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   143                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   144                              <1> %define PIT_DELAY			; Use PIT polling for delays
   145                              <1> %endif ; MACHINE_BOOK8088
   146                              <1> 
   147                              <1> ; Settings for IBM PC/XT
   148                              <1> %ifdef MACHINE_XT
   149                              <1> ;%define	START		0E000h		; BIOS starts at offset 0E000h
   150                              <1> %define	START		0C000h		; FIXME: more ROM for development
   151                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
   152                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   153                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   154                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   155                              <1> %define PIT_DELAY			; Use PIT polling for delays
   156                              <1> %endif ; MACHINE_XT
   157                              <1> 
   158                              <1> %ifdef MACHINE_HOMEBREW8088
   159                              <1> %define	START		0C000h		; FIXME: more ROM for development
   160                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
   161                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   162                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   163                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   164                              <1> %define PIT_DELAY			; Use PIT polling for delays
   165                              <1> %define AT_KEYBOARD			; Has AT-compatible keyboard controller
   166                              <1> %define DISABLE_KBD_DURING_INTERRUPTS
   167                              <1> ; Optional: Enable DS12885/DS12887 based RTC
   168                              <1> ;%define AT_RTC				; Has AT-compatible RTC
   169                              <1> ;%define AT_RTC_AUTODETECT		; Autodetect RTC presence
   170                              <1> ; Specify RTC I/O address if different from the default 0x70
   171                              <1> ;%define AT_RTC_PORT	2A0h
   172                              <1> %endif ; MACHINE_HOMEBREW8088
   173                              <1> 
   174                              <1> ; Automatic settings based on the machine settings above
   175                              <1> %ifdef AT_RTC or AT_RTC_NVRAM or FLASH_NVRAM
   176                              <1> %define BIOS_SETUP			; Include BIOS setup utility
   177                              <1> %endif ; AT_RTC or AT_RTC_NVRAM or FLASH_NVRAM
   178                              <1> 
   179                              <1> ; Note: while Book8088 does have a turbo mode, it is not software controlled
   180                              <1> %ifdef MACHINE_XI8088 or MACHINE_FE2010A
   181                              <1> %define TURBO_MODE			; Has turbo mode
   182                              <1> %endif ; MACHINE_XI8088 or MACHINE_FE2010A
   183                              <1> 
   184                              <1> ; Default floppy drives configuration for systems without NVRAM/Flash ROM setup
   185                              <1> ; First digit = drive A, second = drive B
   186                              <1> ; 0 - none,	1 - 360 KB,	2 - 1.2 MB
   187                              <1> ; 3 - 720 KB,	4 - 1.44 MB,	6 - 2.88 MB
   188                              <1> ; Use two 1.44 MB drives by default
   189                              <1> %define DEFAULT_FLOPPIES 44h
   190                              <1> 
   191                              <1> ; Check for the boot sector signature
   192                              <1> ; Note: Most BIOSes do not check for it
   193                              <1> ; %define BOOT_SIGNATURE
    70                                  %include "errno.inc"
    71                              <1> ;=========================================================================
    72                              <1> ; errno.inc - POST checkpoint codes (sent to port 80h during POST)
    73                              <1> ;-------------------------------------------------------------------------
    74                              <1> ;
    75                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    76                              <1> ;
    77                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
    78                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    79                              <1> ;
    80                              <1> ; This program is free software: you can redistribute it and/or modify
    81                              <1> ; it under the terms of the GNU General Public License as published by
    82                              <1> ; the Free Software Foundation, either version 3 of the License, or
    83                              <1> ; (at your option) any later version.
    84                              <1> ;
    85                              <1> ; This program is distributed in the hope that it will be useful,
    86                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    87                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    88                              <1> ; GNU General Public License for more details.
    89                              <1> ;
    90                              <1> ; You should have received a copy of the GNU General Public License
    91                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    92                              <1> ;
    93                              <1> ;=========================================================================
    94                              <1> 
    95                              <1> e_boot		equ	00h		; Boot the OS
    96                              <1> e_cpu_test	equ	01h		; Start of BIOS POST, CPU test
    97                              <1> e_init_cfg	equ	02h		; Initial chipset configuration:
    98                              <1> 					; initialize PPI, disable NMI
    99                              <1> 					; disable turbo mode, disable display
   100                              <1> e_init_dmac	equ	03h		; Initialize DMAC initialized
   101                              <1> e_low_ram_test	equ	04h		; Test low 32 KiB of RAM
   102                              <1> e_int_table	equ	05h		; Initialize interrupt table
   103                              <1> e_pit_init	equ	06h		; Initialize PIT (timer)
   104                              <1> 					; play power on melody
   105                              <1> e_pic_init	equ	07h		; Initialize PIC
   106                              <1> e_kbd_init	equ	08h		; Initialize KBC and keyboard
   107                              <1> e_int_ena	equ	09h		; Enable interrupts
   108                              <1> e_vid_bios_scan	equ	10h		; Locate video BIOS
   109                              <1> e_vid_bios_init	equ	11h		; Initialize video BIOS
   110                              <1> e_vid_no_bios	equ	12h		; No video BIOS, using MDA/CGA
   111                              <1> e_rtc_init	equ	20h		; Initialize RTC
   112                              <1> e_cpu_detect	equ	21h		; Detect CPU type
   113                              <1> e_fpu_detect	equ	22h		; Detect FPU
   114                              <1> e_serial_scan	equ	24h		; Detect serial ports
   115                              <1> e_parallel_scan	equ	25h		; Detect parallel ports
   116                              <1> e_ram_start	equ	30h		; Start RAM test
   117                              <1> e_ram_complete	equ	31h		; RAM test completed
   118                              <1> e_ram_esc	equ	32h		; RAM test canceled
   119                              <1> e_ext_start	equ	40h		; Start BIOS extension ROM scan
   120                              <1> e_ext_detect	equ	41h		; BIOS extension ROM found, initizalize
   121                              <1> e_ext_init_ok	equ	42h		; BIOS extension ROM initialized
   122                              <1> e_ext_complete	equ	43h		; BIOS extension scan complete
   123                              <1> e_cpu_fail	equ	52h		; CPU test failed
   124                              <1> e_low_ram_fail	equ	54h		; Low 32 KiB RAM test failed
   125                              <1> e_ram_fail	equ	55h		; RAM test failed
   126                              <1> e_kbc_flsh_fail	equ	60h		; Unable to flush KBC output buffer
   127                              <1> e_kbc_cmd_fail	equ	61h		; Unable to send command to KBC
   128                              <1> e_kbc_test_fail	equ	62h		; Keyboard controller self test failed
   129                              <1> e_kbc_int_fail	equ	63h		; Keyboard interface test failed
   130                              <1> e_kbd_bat_fail	equ	70h		; Keyboard BAT test failed
   131                              <1> e_kbd_dis_fail	equ	71h		; Keyboard disable command failed
   132                              <1> e_kbd_ena_fail	equ	72h		; Keyboard enable command failed
   133                              <1> ;-------------------------------------------------------------------------
   134                              <1> ; Minor numbers for keyboard errors
   135                              <1> e_kbd_tout_fail	equ	01h		; Keyboard timeout sending command
   136                              <1> e_kbd_resp_fail	equ	02h		; Keyboard no response
   137                              <1> e_kbd_nack_fail	equ	03h		; Acknowledge response was expected
   138                              <1> 					; but keyboard have sent something else
   139                              <1> e_kbd_rsp2_fail	equ	04h		; Keyboard no response byte 2 for BAT
   140                              <1> e_kbd_nbat_fail	equ	05h		; BAT OK response was expected
   141                              <1> 					; but keyboard have sent something else
   142                              <1> e_kbd_test_fail	equ	06h		; Keyboard controller test failed
   143                              <1> e_kbd_int_fail	equ	07h		; Keyboard interface test failed
    71                                  
    72                                  bioscseg	equ	0F000h
    73                                  biosdseg	equ	0040h
    74                                  
    75                                  pic1_reg0	equ	20h
    76                                  pic1_reg1	equ	21h
    77                                  pit_ch0_reg	equ	40h
    78                                  pit_ch1_reg	equ	41h
    79                                  pit_ch2_reg	equ	42h
    80                                  pit_ctl_reg	equ	43h
    81                                  
    82                                  ; 8255 PPI port A I/O register - Read - keyboard data
    83                                  ppi_pa_reg	equ	60h	; 8255 PPI port A I/O register
    84                                  
    85                                  ; Port 61h - 8255 PPI Port B - Write only
    86                                  ppi_pb_reg	equ	61h	; 8255 PPI port B I/O register
    87                                  iochk_disable	equ	08h	; clear and disable ~IOCHK NMI
    88                                  refresh_flag	equ	10h	; refresh flag, toggles every 15us
    89                                  iochk_enable	equ	0F7h	; enable ~IOCHK NMI
    90                                  iochk_status	equ	40h	; ~IOCHK status - 1 = ~IOCHK NMI signalled
    91                                  
    92                                  %ifdef MACHINE_XT or MACHINE_FE2010A
    93                                  ; Port 62h - 8255 PPI Port C - Read only
    94                                  ppi_pc_reg	equ	62h	; 8255 PPI port C I/O register
    95                                  ; XT DIP switches 1-4 (read when bit 3 of PPI Port B is 1)
    96                                  sw_post_loop	equ	01h	; XT DIP switch 1 - 1 = Loop on POST
    97                                  sw_fpu_present	equ	02h	; XT DIP switch 2 - 1 = FPU present
    98                                  sw_ram_256k	equ	00h	; XT DIP switches 3-4 - 256 KiB
    99                                  sw_ram_512k	equ	04h	; XT DIP switches 3-4 - 512 KiB
   100                                  sw_ram_576k	equ	08h	; XT DIP switches 3-4 - 576 KiB
   101                                  sw_ram_640k	equ	0Ch	; XT DIP switches 3-4 - 640 KiB
   102                                  ; XT DIP switches 5-8 (read when bit 3 of PPI Port B is 0)
   103                                  sw_vid_none	equ	00h	; XT DIP switches 5-6 - No video, EGA, or VGA
   104                                  sw_vid_color_40	equ	01h	; XT DIP switches 5-6 - CGA, 80x25
   105                                  sw_vid_color_80	equ	02h	; XT DIP switches 5-6 - CGA, 40x25
   106                                  sw_vid_mono	equ	03h	; XT DIP switches 5-6 - Monochome, 80x25
   107                                  sw_one_floppy	equ	00h	; XT DIP switches 7-8 - One floppy
   108                                  sw_two_floppies	equ	01h	; XT DIP switches 7-8 - Two floppies
   109                                  sw_three_floppies equ	02h	; XT DIP switches 7-8 - Three floppies
   110                                  sw_four_floppies  equ	03h	; XT DIP switches 7-8 - Four floppies
   111                                  %endif ; MACHINE_XT or MACHINE_FE2010A
   112                                  
   113                                  ; FE2010/FE2010 - Ports 62h-63h
   114                                  %ifdef MACHINE_FE2010A
   115                                  ; Port 62h - Chipset Control Register - Write
   116                                  fe_control_reg	equ	62h
   117                                  fe_fpu_present	equ	02h	; FPU present
   118                                  fe_ram_256k	equ	00h	; XT DIP switches 3-4 - 256 KiB
   119                                  fe_ram_512k	equ	04h	; XT DIP switches 3-4 - 512 KiB
   120                                  fe_ram_576k	equ	08h	; XT DIP switches 3-4 - 576 KiB
   121                                  fe_ram_640k	equ	0Ch	; XT DIP switches 3-4 - 640 KiB
   122                                  fe_one_floppy	equ	00h	; XT DIP switches 7-8 - One floppy
   123                                  fe_two_floppies	equ	40h	; XT DIP switches 7-8 - Two floppies
   124                                  
   125                                  ; Port 63h - Chipset Configuration Register - Write only
   126                                  fe_config_reg	equ	63h	; Chipset configuration register
   127                                  fe_par_disable	equ	01h	; Disable memory parity checking
   128                                  fe_fpu_nma_ena 	equ	02h	; Enable FPU NMI
   129                                  fe_config_lock	equ	08h	; Write lock of control register and
   130                                  				; bits 0-4 of configuration register
   131                                  fe_clk_7_norm	equ	40h	; FE2010A 7.15 MHz CPU clock frequency, normal WS
   132                                  fe_clk_7_fast	equ	60h	; FE2010A 7.15 MHz CPU clock frequency, fast WS
   133                                  fe_clk_9_norm	equ	80h	; FE2010A 9.54 MHz CPU clock frequency, normal WS
   134                                  fe_clk_9_fast	equ	0C0h	; FE2010A 9.54 MHz CPU clock frequency, fast WS
   135                                  %endif ; MACHINE_FE2010A
   136                                  
   137                                  ; IBM PC/XT - Port 63h - 8255 PPI Control Word
   138                                  %ifdef MACHINE_XT
   139                                  ppi_cwd_reg	equ	63h	; 8255 PPI control word register
   140                                  ppi_cwd_value	equ	99h	; 8255 PPI control word value for IBM XT:
   141                                  				; Port A - mode 0 (simple I/O), input
   142                                  				; Port B - mode 0 (simple I/O), output
   143                                  				; Port C - input
   144                                  %endif ; MACHINE_XT
   145                                  
   146                                  post_reg	equ	80h	; POST status output port
   147                                  %ifdef AT_NMI
   148                                  nmi_mask_reg	equ	70h
   149                                  %else ; AT_NMI
   150                                  nmi_mask_reg	equ	0A0h
   151                                  %endif ; AT_NMI
   152                                  %ifdef SECOND_PIC
   153                                  pic2_reg0	equ	0A0h
   154                                  pic2_reg1	equ	0A1h
   155                                  %endif ; SECOND_PIC
   156                                  unused_reg	equ	0C0h	; used for hardware detection and I/O delays
   157                                  cga_mode_reg	equ	3D8h
   158                                  mda_mode_reg	equ	3B8h
   159                                  
   160                                  ; NMI mask (written to 0A0h)
   161                                  nmi_disable	equ	00h	; disable NMI
   162                                  nmi_disa_mask	equ	7Fh	; disable NMI AND mask (bit 7 = 0)
   163                                  nmi_enable	equ	80h	; enable NMI OR mask (bit 7 = 1)
   164                                  
   165                                  pic_freq	equ	1193182	; PIC input frequency - 14318180 MHz / 12
   166                                  
   167                                  ;========================================================================
   168                                  ; BIOS data area variables
   169                                  ;------------------------------------------------------------------------
   170                                  equip_serial	equ	00h	; word[4] - addresses of serial ports
   171                                  				; or 0 if port doesn't exist
   172                                  equip_parallel	equ	08h	; word[3] - addresses of parallel ports
   173                                  				; or 0 if port doesn't exist
   174                                  ebda_segment	equ	0Eh	; word - address of EBDA segment
   175                                  equipment_list	equ	10h	; word - equpment list
   176                                  equip_floppies	equ	0000000000000001b	; floppy drivers installed
   177                                  equip_fpu	equ	0000000000000010b	; FPU installed
   178                                  equip_mouse	equ	0000000000000100b
   179                                  equip_video	equ	0000000000110000b	; video type bit mask
   180                                  equip_color_40	equ	0000000000010000b	; color 40x24 (mode 1)
   181                                  equip_color_80	equ	0000000000100000b	; color 80x25 (mode 3)
   182                                  equip_mono	equ	0000000000110000b	; mono 80x25 (mode 7)
   183                                  equip_floppy2	equ	0000000001000000b	; 2nd floppy drive installed
   184                                  ;			|||||||||||||||`-- floppy drives installed
   185                                  ;			||||||||||||||`-- FPU installed
   186                                  ;			|||||||||||||`-- PS/2 mouse installed
   187                                  ;			||||||||||||`-- reserved
   188                                  ;			||||||||||`--- initial video mode
   189                                  ;			||||||||`---- number of floppy drives - 1
   190                                  ;			|||||||`---- O = DMA installed
   191                                  ;			||||`------ number of serial ports
   192                                  ;			|||`------ game adapter installed
   193                                  ;			||`------ internal modem?!
   194                                  ;			`------- number of parallel ports
   195                                  
   196                                  post_flags	equ	12h	; byte - post flags
   197                                  post_setup	equ	01h	; run NVRAM setup
   198                                  memory_size	equ	13h	; word - memory size in KiB
   199                                  kbd_flags_1	equ	17h	; byte - keyboard shift flags 1
   200                                  kbd_flags_2	equ	18h	; byte - keyboard shift flags 2
   201                                  kbd_alt_keypad	equ	19h	; byte - work area for Alt+Numpad
   202                                  kbd_buffer_head	equ	1Ah	; word - keyboard buffer head offset
   203                                  kbd_buffer_tail	equ	1Ch	; word - keyboard buffer tail offset
   204                                  kbd_buffer	equ	1Eh	; byte[32] - keyboard buffer
   205                                  fdc_calib_state	equ	3Eh	; byte - floppy drive recalibration status
   206                                  fdc_motor_state	equ	3Fh	; byte - floppy drive motor status
   207                                  fdc_motor_tout	equ	40h	; byte - floppy drive motor off timeout (ticks)
   208                                  fdc_last_error	equ	41h	; byte - status of last diskette operation
   209                                  fdc_ctrl_status	equ	42h	; byte[7] - FDC status bytes
   210                                  video_mode	equ	49h	; byte - active video mode number
   211                                  video_columns	equ	4Ah	; word - number of text columns for active mode
   212                                  video_page_size	equ	4Ch	; word - size of video page in bytes
   213                                  video_page_offt	equ	4Eh	; word - offset of the active video page
   214                                  video_cur_pos	equ	50h	; byte[16] - cursor position for each page
   215                                  video_cur_shape	equ	60h	; word - cursor shape
   216                                  video_page	equ	62h	; byte - active video page
   217                                  video_port	equ	63h	; word - I/O port for the display adapter
   218                                  video_mode_reg	equ	65h	; byte - video adapter mode register
   219                                  video_palet_reg	equ	66h	; byte - color palette
   220                                  last_irq	equ	6Bh	; byte - Last spurious IRQ number
   221                                  ticks_lo	equ	6Ch	; word - timer ticks - low word
   222                                  ticks_hi	equ	6Eh	; word - timer ticks - high word
   223                                  new_day		equ	70h	; byte - 1 = new day flag
   224                                  break_flag	equ	71h	; byte - bit 7 = 1 if Ctrl-Break was pressed
   225                                  warm_boot	equ	72h	; word - Warm boot if equals 1234h
   226                                  printer_timeout	equ	78h	; byte[3] - parallel port timeout values
   227                                  serial_timeout	equ	7Ch	; byte[4] - serial port timeout values
   228                                  kbd_buffer_start equ	80h	; word - keyboard buffer start offset
   229                                  kbd_buffer_end	equ	82h	; word - keyboard buffer end offset
   230                                  video_rows	equ	84h	; byte - number of text rows (EGA+)
   231                                  fdc_last_rate	equ	8Bh	; byte - last data rate / step rate
   232                                  fdc_info	equ	8Fh	; byte - floppy dist drive information
   233                                  fdc_media_state	equ	90h	; byte[4] - drive media state (drives 0 - 3)
   234                                  fdc_cylinder	equ	94h	; byte[2] - current cylinder (drives 0 - 1)
   235                                  kbd_flags_3	equ	96h	; byte - keyboard status flags 3
   236                                  kbd_flags_4	equ	97h	; byte - keyboard status flags 4
   237                                  vga_table_ptr	equ	0A8h	; dword - BIOS Video Save/Override Pointer
   238                                  				;       Table address
   239                                  prt_scrn_flags	equ	100h	; byte - print screen flags
   240                                  prt_scrn_ready	equ	00h	;	print screen is not in progress
   241                                  prt_scrn_run	equ	01h	; 	print screen is in progress
   242                                  prt_scrn_fail	equ	0FFh	;	last print screen attempt has failed
   243                                  
   244                                  ;=========================================================================
   245                                  ; Extended BIOS data area variables
   246                                  ;-------------------------------------------------------------------------
   247                                  ebda_size	equ	0h
   248                                  mouse_driver	equ	22h	; 4 bytes - pointer to mouse driver
   249                                  mouse_flags_1	equ	26h
   250                                  mouse_flags_2	equ	27h
   251                                  mouse_data	equ	28h	; 8 bytes - mouse data buffer
   252                                  
   253                                  	org	START		; Use only upper 32 KiB of ROM
   254                                  
   255                                  ;=========================================================================
   256                                  ; Includes
   257                                  ;-------------------------------------------------------------------------
   258                                  %include	"messages.inc"		; POST messages
   259                              <1> ;=========================================================================
   260                              <1> ; messages.inc - Messages printed by BIOS POST (Power On Self Test)
   261                              <1> ;-------------------------------------------------------------------------
   262                              <1> ;
   263                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   264                              <1> ;
   265                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
   266                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   267                              <1> ;
   268                              <1> ; This program is free software: you can redistribute it and/or modify
   269                              <1> ; it under the terms of the GNU General Public License as published by
   270                              <1> ; the Free Software Foundation, either version 3 of the License, or
   271                              <1> ; (at your option) any later version.
   272                              <1> ;
   273                              <1> ; This program is distributed in the hope that it will be useful,
   274                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   275                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   276                              <1> ; GNU General Public License for more details.
   277                              <1> ;
   278                              <1> ; You should have received a copy of the GNU General Public License
   279                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   280                              <1> ;
   281                              <1> ;=========================================================================
   282                              <1> 
   283 00000000 0D0A                <1> msg_copyright	db	0Dh, 0Ah
   284                              <1> %ifdef MACHINE_XI8088
   285                              <1> 		db	"Xi 8088"
   286                              <1> %endif ; MACHINE_XI8088
   287                              <1> %ifdef MACHINE_FE2010A
   288 00000002 4D6963726F20383038- <1> 		db	"Micro 8088"
   288 0000000B 38                  <1>
   289                              <1> %endif ; MACHINE_FE2010A
   290                              <1> %ifdef MACHINE_BOOK8088
   291                              <1> 		db	"Book8088"
   292                              <1> %endif ; MACHINE_BOOK8088
   293                              <1> %ifdef MACHINE_XT
   294                              <1> 		db	"XT 8088"
   295                              <1> %endif ; MACHINE_XT
   296                              <1> %ifdef MACHINE_HOMEBREW8088
   297                              <1> 		db	"Homebrew8088"
   298                              <1> %endif ; MACHINE_HOMEBREW8088
   299 0000000C 2042494F532C205665- <1> 		db	" BIOS, Version "
   299 00000015 7273696F6E20        <1>
   300 0000001B 312E302E31          <1> 		db	VERSION
   301 00000020 2E20                <1> 		db	". "
   302 00000022 436F70797269676874- <1> 		db	"Copyright (C) 2010 - 2025 Sergey Kiselev", 0Dh, 0Ah
   302 0000002B 202843292032303130- <1>
   302 00000034 202D20323032352053- <1>
   302 0000003D 6572676579204B6973- <1>
   302 00000046 656C65760D0A        <1>
   303 0000004C 446973747269627574- <1> 		db	"Distributed under the terms of "
   303 00000055 656420756E64657220- <1>
   303 0000005E 746865207465726D73- <1>
   303 00000067 206F6620            <1>
   304 0000006B 74686520474E552047- <1> 		db	"the GNU General Public License", 0Dh, 0Ah
   304 00000074 656E6572616C205075- <1>
   304 0000007D 626C6963204C696365- <1>
   304 00000086 6E73650D0A          <1>
   305 0000008B 0D0A00              <1> msg_crlf	db      0Dh, 0Ah, 00h
   306 0000008E 6E6F6E6500          <1> msg_none	db	'none', 00h
   307 00000093 3A2000              <1> msg_colon	db	': ', 00h
   308 00000096 3B2000              <1> msg_semicolon	db	'; ', 00h
   309                              <1> %ifdef TURBO_MODE
   310 00000099 43505520636C6F636B- <1> msg_cpu_clk	db	'CPU clock frequency:        ', 00h
   310 000000A2 206672657175656E63- <1>
   310 000000AB 793A20202020202020- <1>
   310 000000B4 2000                <1>
   311 000000B6 20402000            <1> msg_at		db	' @ ', 00h
   312 000000BA 342E3737204D487A20- <1> msg_clk_4_77mhz	db	'4.77 MHz ', 00h
   312 000000C3 00                  <1>
   313                              <1> %ifdef MACHINE_FE2010A
   314 000000C4 372E3136204D487A20- <1> msg_clk_7_16mhz	db	'7.16 MHz ', 00h
   314 000000CD 00                  <1>
   315 000000CE 392E3535204D487A20- <1> msg_clk_9_55mhz	db	'9.55 MHz ', 00h
   315 000000D7 00                  <1>
   316                              <1> %else ; MACHINE_FE2010A
   317                              <1> msg_clk_turbo	db	'Turbo ', 00h
   318                              <1> %endif ; MACHINE_FE2010A
   319                              <1> %endif ; TURBO_MODE
   320                              <1> %ifdef MACHINE_HOMEBREW8088
   321                              <1> msg_est		db      'Estimated Clock:            ',00h
   322                              <1> msg_mhz		db	"MHz", 00h
   323                              <1> msg_ticks	db	"Ticks ", 0F7h, 00h
   324                              <1> %endif ; MACHINE_HOMEBREW8088
   325 000000D8 4D61696E2050726F63- <1> msg_cpu		db      'Main Processor:             ', 00h
   325 000000E1 6573736F723A202020- <1>
   325 000000EA 202020202020202020- <1>
   325 000000F3 2000                <1>
   326 000000F5 4D617468656D617469- <1> msg_fpu		db      'Mathematics Co-processor:   ', 00h
   326 000000FE 637320436F2D70726F- <1>
   326 00000107 636573736F723A2020- <1>
   326 00000110 2000                <1>
   327 00000112 496E74656C20383038- <1> msg_cpu_8088_78	db      "Intel 8088 '78", 00h
   327 0000011B 382027373800        <1>
   328 00000121 5741524E494E473A20- <1> msg_cpu_bug	db      'WARNING: This CPU does not disable interrupts '
   328 0000012A 546869732043505520- <1>
   328 00000133 646F6573206E6F7420- <1>
   328 0000013C 64697361626C652069- <1>
   328 00000145 6E7465727275707473- <1>
   328 0000014E 20                  <1>
   329 0000014F 6166746572206C6F61- <1> 		db      'after loading segment registers!', 0Dh, 0Ah, 00h
   329 00000158 64696E67207365676D- <1>
   329 00000161 656E74207265676973- <1>
   329 0000016A 74657273210D0A00    <1>
   330 00000172 496E74656C20383038- <1> msg_cpu_8088_81	db      "Intel 8088 '81 or later, "
   330 0000017B 3820273831206F7220- <1>
   330 00000184 6C617465722C20      <1>
   331 0000018B 6F72204F4B492D6465- <1> 		db      'or OKI-designed 80C88', 00h
   331 00000194 7369676E6564203830- <1>
   331 0000019D 43383800            <1>
   332 000001A1 4861727269732D6465- <1> msg_cpu_harris  db      'Harris-designed 80C88', 00h
   332 000001AA 7369676E6564203830- <1>
   332 000001B3 43383800            <1>
   333 000001B7 4E45432056323000    <1> msg_cpu_nec_v20 db      'NEC V20', 00h
   334                              <1> %ifdef MACHINE_HOMEBREW8088
   335                              <1> msg_cpu_nec_v40	db	'NEC V40', 00h
   336                              <1> %endif ; MACHINE_HOMEBREW8088
   337 000001BF 496E74656C20383038- <1> msg_fpu_present db      'Intel 8087', 0Dh, 0Ah, 00h
   337 000001C8 370D0A00            <1>
   338                              <1> %ifdef MACHINE_FE2010A
   339 000001CC 436869707365743A20- <1> msg_chipset	db	'Chipset:                    ', 00h
   339 000001D5 202020202020202020- <1>
   339 000001DE 202020202020202020- <1>
   339 000001E7 2000                <1>
   340 000001E9 466172616461792046- <1> msg_fe2010	db	'Faraday FE2010', 0Dh, 0Ah, 00h
   340 000001F2 45323031300D0A00    <1>
   341 000001FA 466172616461792046- <1> msg_fe2010a	db	'Faraday FE2010A', 0Dh, 0Ah, 00h
   341 00000203 4532303130410D0A00  <1>
   342 0000020C 50726F746F6E205054- <1> msg_pt8010af	db	'Proton PT8010AF', 0Dh, 0Ah, 00h
   342 00000215 3830313041460D0A00  <1>
   343                              <1> %endif ; MACHINE_FE2010A
   344 0000021E 446973706C61792041- <1> msg_disp	db      'Display Adapter Type:       ', 00h
   344 00000227 646170746572205479- <1>
   344 00000230 70653A202020202020- <1>
   344 00000239 2000                <1>
   345 0000023B 4547412F5647412028- <1> msg_disp_ega	db      'EGA/VGA (Video BIOS Present)', 0Dh, 0Ah, 00h
   345 00000244 566964656F2042494F- <1>
   345 0000024D 532050726573656E74- <1>
   345 00000256 290D0A00            <1>
   346 0000025A 434741202838307832- <1> msg_disp_cga_80	db      'CGA (80x25)', 0Dh, 0Ah, 00h
   346 00000263 35290D0A00          <1>
   347 00000268 434741202834307832- <1> msg_disp_cga_40	db      'CGA (40x25)', 0Dh, 0Ah, 00h
   347 00000271 35290D0A00          <1>
   348 00000276 4D4441206F72204865- <1> msg_disp_mda	db      'MDA or Hercules', 0Dh, 0Ah, 00h
   348 0000027F 7263756C65730D0A00  <1>
   349 00000288 52544320285265616C- <1> msg_rtc		db	'RTC (Real Time Clock):      ', 00h
   349 00000291 2054696D6520436C6F- <1>
   349 0000029A 636B293A2020202020- <1>
   349 000002A3 2000                <1>
   350 000002A5 466C6F707079206469- <1> msg_floppy	db	'Floppy disk drives:         Drive 0: ', 00h
   350 000002AE 736B20647269766573- <1>
   350 000002B7 3A2020202020202020- <1>
   350 000002C0 20447269766520303A- <1>
   350 000002C9 2000                <1>
   351 000002CB 3B2044726976652031- <1> msg_floppy_2	db	'; Drive 1: ', 00h
   351 000002D4 3A2000              <1>
   352 000002D7 333630204B422C2035- <1> msg_floppy_360	db	'360 KB, 5.25"', 00h
   352 000002E0 2E32352200          <1>
   353 000002E5 312E32204D422C2035- <1> msg_floppy_1200	db	'1.2 MB, 5.25"', 00h
   353 000002EE 2E32352200          <1>
   354 000002F3 373230204B422C2033- <1> msg_floppy_720	db	'720 KB, 3.5"', 00h
   354 000002FC 2E352200            <1>
   355 00000300 312E3434204D422C20- <1> msg_floppy_1440	db	'1.44 MB, 3.5"', 00h
   355 00000309 332E352200          <1>
   356 0000030E 322E3838204D422C20- <1> msg_floppy_2880	db	'2.88 MB, 3.5"', 00h
   356 00000317 332E352200          <1>
   357                              <1> %ifdef PS2_MOUSE
   358                              <1> msg_mouse	db      'PS/2 Aux Device (Mouse):    ', 00h
   359                              <1> %endif ; PS2_MOUSE
   360 0000031C 50726573656E740D0A- <1> msg_present	db      'Present', 0Dh, 0Ah, 00h
   360 00000325 00                  <1>
   361 00000326 416273656E740D0A00  <1> msg_absent	db      'Absent', 0Dh, 0Ah, 00h
   362 0000032F 53657269616C20506F- <1> msg_serial	db	'Serial Ports:               ', 00h
   362 00000338 7274733A2020202020- <1>
   362 00000341 202020202020202020- <1>
   362 0000034A 2000                <1>
   363 0000034C 434F4D00            <1> msg_serial_com	db	'COM', 00h
   364 00000350 506172616C6C656C20- <1> msg_parallel	db	'Parallel Ports:             ', 00h
   364 00000359 506F7274733A202020- <1>
   364 00000362 202020202020202020- <1>
   364 0000036B 2000                <1>
   365 0000036D 4C505400            <1> msg_parallel_lpt db	'LPT', 00h
   366 00000371 54657374696E672052- <1> msg_ram_testing	db	'Testing RAM (ESC to skip):  ', 00h
   366 0000037A 414D20284553432074- <1>
   366 00000383 6F20736B6970293A20- <1>
   366 0000038C 2000                <1>
   367 0000038E 0D0A4552524F523A20- <1> msg_ram_error	db	0Dh, 0Ah, 'ERROR: Faulty memory detected at ', 00h
   367 00000397 4661756C7479206D65- <1>
   367 000003A0 6D6F72792064657465- <1>
   367 000003A9 637465642061742000  <1>
   368 000003B2 0D546F74616C20436F- <1> msg_ram_total	db      0Dh, 'Total Conventional RAM:     ', 00h
   368 000003BB 6E76656E74696F6E61- <1>
   368 000003C4 6C2052414D3A202020- <1>
   368 000003CD 202000              <1>
   369                              <1> %ifdef EBDA_SIZE
   370                              <1> msg_ebda	db      'Reserved for EBDA:          ', 00h
   371                              <1> msg_ram_avail	db      'Available Conventional RAM: ', 00h
   372                              <1> %endif ; EBDA_SIZE
   373 000003D0 204B69420D0A00      <1> msg_kib		db      ' KiB', 0Dh, 0Ah, 00h
   374 000003D7 426F6F74206661696C- <1> msg_boot_failed	db      'Boot failed, press any key to try again...', 0Dh, 0Ah, 0
   374 000003E0 65642C207072657373- <1>
   374 000003E9 20616E79206B657920- <1>
   374 000003F2 746F20747279206167- <1>
   374 000003FB 61696E2E2E2E0D0A00  <1>
   375 00000404 4E6F20524F4D204241- <1> msg_no_basic    db      'No ROM BASIC', 0Dh, 0Ah, 0
   375 0000040D 5349430D0A00        <1>
   376 00000413 466F756E642042494F- <1> msg_rom_found   db      'Found BIOS extension ROM at ', 0
   376 0000041C 5320657874656E7369- <1>
   376 00000425 6F6E20524F4D206174- <1>
   376 0000042E 2000                <1>
   377 00000430 302C20696E69746961- <1> msg_rom_init	db	'0, initializing...', 0Dh, 0Ah, 0
   377 00000439 6C697A696E672E2E2E- <1>
   377 00000442 0D0A00              <1>
   378 00000445 426F6F74696E67204F- <1> msg_boot	db      'Booting OS...', 0Dh, 0Ah, 0
   378 0000044E 532E2E2E0D0A00      <1>
   379                              <1> %ifdef AT_RTC
   380 00000455 4552524F523A205254- <1> msg_rtc_bad	db	'ERROR: RTC battery is bad', 0Dh, 0Ah, 00h
   380 0000045E 432062617474657279- <1>
   380 00000467 206973206261640D0A- <1>
   380 00000470 00                  <1>
   381                              <1> %endif ; AT_RTC
   382                              <1> %ifdef AT_RTC_NVRAM
   383                              <1> msg_rtc_sum	db	'ERROR: NVRAM checksum is invalid, '
   384                              <1> 		db	'loading default values to NVRAM', 0Dh, 0Ah, 00h
   385                              <1> %endif ; AT_RTC_NVRAM
   386                              <1> %ifdef BIOS_SETUP
   387 00000471 507265737320463120- <1> msg_setup	db	'Press F1 to run BIOS setup...',0Dh, 0Ah, 0Dh, 0Ah, 00h
   387 0000047A 746F2072756E204249- <1>
   387 00000483 4F532073657475702E- <1>
   387 0000048C 2E2E0D0A0D0A00      <1>
   388 00000493 0D0A57656C636F6D65- <1> msg_set_welcome	db	0Dh, 0Ah, 'Welcome to the BIOS setup utility', 00h
   388 0000049C 20746F207468652042- <1>
   388 000004A5 494F53207365747570- <1>
   388 000004AE 207574696C69747900  <1>
   389 000004B7 0D0A                <1> msg_set_help	db	0Dh, 0Ah
   390 000004B9 42494F532073657475- <1> 		db	'BIOS setup commands:', 0Dh, 0Ah
   390 000004C2 7020636F6D6D616E64- <1>
   390 000004CB 733A0D0A            <1>
   391 000004CF 66202D204368616E67- <1> 		db	'f - Change first floppy drive type', 0Dh, 0Ah
   391 000004D8 652066697273742066- <1>
   391 000004E1 6C6F70707920647269- <1>
   391 000004EA 766520747970650D0A  <1>
   392 000004F3 67202D204368616E67- <1> 		db	'g - Change second floppy drive type', 0Dh, 0Ah
   392 000004FC 65207365636F6E6420- <1>
   392 00000505 666C6F707079206472- <1>
   392 0000050E 69766520747970650D- <1>
   392 00000517 0A                  <1>
   393 00000518 65202D204368616E67- <1> 		db	'e - Change BIOS extension ROM scan settings', 0Dh, 0Ah
   393 00000521 652042494F53206578- <1>
   393 0000052A 74656E73696F6E2052- <1>
   393 00000533 4F4D207363616E2073- <1>
   393 0000053C 657474696E67730D0A  <1>
   394 00000545 6D202D204368616E67- <1> 		db	'm - Change memory test settings', 0Dh, 0Ah
   394 0000054E 65206D656D6F727920- <1>
   394 00000557 746573742073657474- <1>
   394 00000560 696E67730D0A        <1>
   395                              <1> %ifdef TURBO_MODE
   396 00000566 63202D205365742064- <1> 		db	'c - Set default CPU clock frequency', 0Dh, 0Ah
   396 0000056F 656661756C74204350- <1>
   396 00000578 5520636C6F636B2066- <1>
   396 00000581 72657175656E63790D- <1>
   396 0000058A 0A                  <1>
   397                              <1> %endif ; TURBO_MODE
   398                              <1> %ifdef MACHINE_FE2010A
   399 0000058B 73202D204368616E67- <1> 		db	's - Change wait state settings', 0Dh, 0Ah
   399 00000594 652077616974207374- <1>
   399 0000059D 617465207365747469- <1>
   399 000005A6 6E67730D0A          <1>
   400                              <1> %endif ; MACHINE_FE2010A
   401 000005AB 00                  <1> 		db	00h
   402                              <1> %ifdef AT_RTC
   403 000005AC 74202D205365742074- <1> msg_set_rtc_help db	't - Set time', 0Dh, 0Ah
   403 000005B5 696D650D0A          <1>
   404 000005BA 64202D205365742064- <1> 		db	'd - Set date', 0Dh, 0Ah, 00h
   404 000005C3 6174650D0A00        <1>
   405                              <1> %endif ; AT_RTC
   406 000005C9 70202D205072696E74- <1> msg_set_def_help db	'p - Print current settings', 0Dh, 0Ah
   406 000005D2 2063757272656E7420- <1>
   406 000005DB 73657474696E67730D- <1>
   406 000005E4 0A                  <1>
   407 000005E5 77202D205361766520- <1> 		db	'w - Save changes and exit', 0Dh, 0Ah
   407 000005EE 6368616E6765732061- <1>
   407 000005F7 6E6420657869740D0A  <1>
   408 00000600 71202D204578697420- <1> 		db	'q - Exit without saving changes', 0Dh, 0Ah
   408 00000609 776974686F75742073- <1>
   408 00000612 6176696E6720636861- <1>
   408 0000061B 6E6765730D0A        <1>
   409 00000621 68202D2053686F7720- <1> 		db	'h - Show this help', 0Dh, 0Ah, 00h
   409 0000062A 746869732068656C70- <1>
   409 00000633 0D0A00              <1>
   410 00000636 0D0A456E7465722063- <1> msg_set_prompt	db	0Dh, 0Ah, 'Enter command (h for help): ', 00h
   410 0000063F 6F6D6D616E64202868- <1>
   410 00000648 20666F722068656C70- <1>
   410 00000651 293A2000            <1>
   411                              <1> %ifdef TURBO_MODE
   412 00000655 0D0A                <1> msg_set_clk_help db 	0Dh, 0Ah
   413 00000657 43505520636C6F636B- <1> 		db	'CPU clock frequency options:', 0Dh, 0Ah
   413 00000660 206672657175656E63- <1>
   413 00000669 79206F7074696F6E73- <1>
   413 00000672 3A0D0A              <1>
   414 00000675 34202D20342E373720- <1> 		db	'4 - 4.77 MHz', 0Dh, 0Ah
   414 0000067E 4D487A0D0A          <1>
   415                              <1> %ifdef MACHINE_FE2010A
   416 00000683 37202D20372E313620- <1> 		db	'7 - 7.16 MHz', 0Dh, 0Ah
   416 0000068C 4D487A0D0A          <1>
   417 00000691 39202D20392E353520- <1> 		db	'9 - 9.55 MHz', 0Dh, 0Ah, 00h
   417 0000069A 4D487A0D0A00        <1>
   418                              <1> %else ; MACHINE_FE2010A
   419                              <1> 		db	't - Turbo', 0Dh, 0Ah, 00h
   420                              <1> %endif ; MACHINE_FE2010A
   421 000006A0 0D0A456E7465722043- <1> msg_set_clk_prmt db	0Dh, 0Ah, 'Enter CPU clock frequency (h for help): '
   421 000006A9 505520636C6F636B20- <1>
   421 000006B2 6672657175656E6379- <1>
   421 000006BB 20286820666F722068- <1>
   421 000006C4 656C70293A20        <1>
   422 000006CA 00                  <1> 		db	00h
   423                              <1> %endif ; TURBO_MODE
   424                              <1> %ifdef AT_RTC
   425 000006CB 456E7465722074696D- <1> msg_set_time	db	'Enter time (hh:mm:ss): ', 00h
   425 000006D4 65202868683A6D6D3A- <1>
   425 000006DD 7373293A2000        <1>
   426 000006E3 456E74657220646174- <1> msg_set_date	db	'Enter date (YYYY-MM-DD): ', 00h
   426 000006EC 652028595959592D4D- <1>
   426 000006F5 4D2D4444293A2000    <1>
   427 000006FD 4552524F523A20496E- <1> msg_time_inval	db	'ERROR: Invalid time.', 0Dh, 0Ah, 00h
   427 00000706 76616C69642074696D- <1>
   427 0000070F 652E0D0A00          <1>
   428 00000714 4552524F523A20496E- <1> msg_date_inval	db	'ERROR: Invalid date.', 0Dh, 0Ah, 00h
   428 0000071D 76616C696420646174- <1>
   428 00000726 652E0D0A00          <1>
   429                              <1> %endif ; AT_RTC
   430 0000072B 0D0A                <1> msg_set_fd_help	db	0Dh, 0Ah
   431 0000072D 466C6F707079206472- <1> 		db	'Floppy drive types:', 0Dh, 0Ah
   431 00000736 697665207479706573- <1>
   431 0000073F 3A0D0A              <1>
   432 00000742 30202D204E6F742069- <1> 		db	'0 - Not installed   3 - 720 KB, 3.5"', 0Dh, 0Ah
   432 0000074B 6E7374616C6C656420- <1>
   432 00000754 202033202D20373230- <1>
   432 0000075D 204B422C20332E3522- <1>
   432 00000766 0D0A                <1>
   433 00000768 31202D20333630204B- <1> 		db	'1 - 360 KB, 5.25"   4 - 1.44 MB, 3.5"', 0Dh, 0Ah
   433 00000771 422C20352E32352220- <1>
   433 0000077A 202034202D20312E34- <1>
   433 00000783 34204D422C20332E35- <1>
   433 0000078C 220D0A              <1>
   434 0000078F 32202D20312E32204D- <1> 		db	'2 - 1.2 MB, 5.25"   6 - 2.88 MB, 3.5"', 0Dh, 0Ah, 00h
   434 00000798 422C20352E32352220- <1>
   434 000007A1 202036202D20322E38- <1>
   434 000007AA 38204D422C20332E35- <1>
   434 000007B3 220D0A00            <1>
   435 000007B7 536574757020636F6D- <1> msg_set_sub_help db	'Setup commands:', 0Dh, 0Ah
   435 000007C0 6D616E64733A0D0A    <1>
   436 000007C8 72202D205265747572- <1> 		db	'r - Return to the main menu', 0Dh, 0Ah
   436 000007D1 6E20746F2074686520- <1>
   436 000007DA 6D61696E206D656E75- <1>
   436 000007E3 0D0A                <1>
   437 000007E5 68202D2053686F7720- <1> 		db	'h - Show this help', 0Dh, 0Ah, 00h
   437 000007EE 746869732068656C70- <1>
   437 000007F7 0D0A00              <1>
   438 000007FA 0D0A456E7465722066- <1> msg_set_fd_prmt	db	0Dh, 0Ah, 'Enter floppy drive type (h for help): '
   438 00000803 6C6F70707920647269- <1>
   438 0000080C 766520747970652028- <1>
   438 00000815 6820666F722068656C- <1>
   438 0000081E 70293A20            <1>
   439 00000822 00                  <1> 		db	00h
   440 00000823 5363616E2046303030- <1> msg_set_ext	db	'Scan F0000-F7FFF area for BIOS extension ROMs (y/n): '
   440 0000082C 302D46374646462061- <1>
   440 00000835 72656120666F722042- <1>
   440 0000083E 494F5320657874656E- <1>
   440 00000847 73696F6E20524F4D73- <1>
   440 00000850 2028792F6E293A20    <1>
   441 00000858 00                  <1> 		db	00h
   442 00000859 46303030302D463746- <1> msg_ext_scan	db	'F0000-F7FFF BIOS ext. scan: ', 00h
   442 00000862 46462042494F532065- <1>
   442 0000086B 78742E207363616E3A- <1>
   442 00000874 2000                <1>
   443 00000876 456E61626C65206D65- <1> msg_set_mem_tst	db	'Enable memory test (y/n): ', 00h
   443 0000087F 6D6F72792074657374- <1>
   443 00000888 2028792F6E293A2000  <1>
   444 00000891 4D656D6F7279207465- <1> msg_mem_test	db	'Memory test:                ', 00h
   444 0000089A 73743A202020202020- <1>
   444 000008A3 202020202020202020- <1>
   444 000008AC 2000                <1>
   445                              <1> %ifdef MACHINE_FE2010A
   446 000008AE 466173742077616974- <1> msg_set_ws	db	'Fast wait states (y/n, h for help): ', 00h
   446 000008B7 207374617465732028- <1>
   446 000008C0 792F6E2C206820666F- <1>
   446 000008C9 722068656C70293A20- <1>
   446 000008D2 00                  <1>
   447 000008D3 0D0A                <1> msg_ws_help	db	0Dh, 0Ah
   448 000008D5 576169742073746174- <1> 		db	'Wait states configuration for FE2010A and PT8010AF:',
   448 000008DE 657320636F6E666967- <1>
   448 000008E7 75726174696F6E2066- <1>
   448 000008F0 6F7220464532303130- <1>
   448 000008F9 4120616E6420505438- <1>
   448 00000902 30313041463A        <1>
   449 00000908 0D0A                <1> 		db	0Dh, 0Ah
   450 0000090A 372E3135204D487A2C- <1> 		db	'7.15 MHz, normal: I/O - 4 WS; Upper memory - 2 WS'
   450 00000913 206E6F726D616C3A20- <1>
   450 0000091C 492F4F202D20342057- <1>
   450 00000925 533B20557070657220- <1>
   450 0000092E 6D656D6F7279202D20- <1>
   450 00000937 32205753            <1>
   451 0000093B 0D0A                <1> 		db	0Dh, 0Ah
   452 0000093D 372E3135204D487A2C- <1> 		db	'7.15 MHz, fast:   I/O - 4 WS; Upper memory - 0 WS'
   452 00000946 20666173743A202020- <1>
   452 0000094F 492F4F202D20342057- <1>
   452 00000958 533B20557070657220- <1>
   452 00000961 6D656D6F7279202D20- <1>
   452 0000096A 30205753            <1>
   453 0000096E 0D0A                <1> 		db	0Dh, 0Ah
   454 00000970 392E3534204D487A2C- <1> 		db	'9.54 MHz, normal: I/O - 6 WS; Upper memory - 4 WS'
   454 00000979 206E6F726D616C3A20- <1>
   454 00000982 492F4F202D20362057- <1>
   454 0000098B 533B20557070657220- <1>
   454 00000994 6D656D6F7279202D20- <1>
   454 0000099D 34205753            <1>
   455 000009A1 0D0A                <1> 		db	0Dh, 0Ah
   456 000009A3 392E3534204D487A2C- <1> 		db	'9.54 MHz, fast:   I/O - 4 WS; Upper memory - 2 WS'
   456 000009AC 20666173743A202020- <1>
   456 000009B5 492F4F202D20342057- <1>
   456 000009BE 533B20557070657220- <1>
   456 000009C7 6D656D6F7279202D20- <1>
   456 000009D0 32205753            <1>
   457 000009D4 0D0A00              <1> 		db	0Dh, 0Ah, 00h
   458 000009D7 466173742077616974- <1> msg_ws		db	'Fast wait states:           ', 00h
   458 000009E0 207374617465733A20- <1>
   458 000009E9 202020202020202020- <1>
   458 000009F2 2000                <1>
   459                              <1> %endif ; MACHINE_FE2010A
   460 000009F4 456E61626C656400    <1> msg_enabled	db	'Enabled', 00h
   461 000009FC 44697361626C656400  <1> msg_disabled	db	'Disabled', 00h
   462                              <1> %ifdef FLASH_NVRAM
   463 00000A05 0D0A536176696E6720- <1> msg_saving	db	0Dh, 0Ah, 'Saving configuration to Flash ROM... ', 00h
   463 00000A0E 636F6E666967757261- <1>
   463 00000A17 74696F6E20746F2046- <1>
   463 00000A20 6C61736820524F4D2E- <1>
   463 00000A29 2E2E2000            <1>
   464 00000A2D 4F4B0D0A00          <1> msg_save_ok	db	'OK', 0Dh, 0Ah, 00h
   465 00000A32 4552524F520D0A00    <1> msg_save_error	db	'ERROR', 0Dh, 0Ah, 00h
   466                              <1> %endif ; FLASH_NVRAM
   467                              <1> %endif ; BIOS_SETUP
   468 00000A3A [8E00]              <1> tbl_floppy	dw	msg_none
   469 00000A3C [D702]              <1> 		dw	msg_floppy_360
   470 00000A3E [E502]              <1> 		dw	msg_floppy_1200
   471 00000A40 [F302]              <1> 		dw	msg_floppy_720
   472 00000A42 [0003]              <1> 		dw	msg_floppy_1440
   473 00000A44 [8E00]              <1> 		dw	msg_none
   474 00000A46 [0E03]              <1> 		dw	msg_floppy_2880
   475 00000A48 [8E00]              <1> 		dw	msg_none
   259                                  %ifndef MACHINE_XT			; No space in XT ROM for font
   260                                  %include	"fnt80-FF.inc"		; font for graphics modes
   261                              <1> ;=========================================================================
   262                              <1> ; fnt80-FF.inc - Font for graphics modes (Cyrillic font)
   263                              <1> ;       Characters from 80h to 0FFh
   264                              <1> ;-------------------------------------------------------------------------
   265                              <1> ;
   266                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   267                              <1> ;
   268                              <1> ; This font is borrowed from kbd package (alt-8x8)
   269                              <1> ;
   270                              <1> ; This program is free software: you can redistribute it and/or modify
   271                              <1> ; it under the terms of the GNU General Public License as published by
   272                              <1> ; the Free Software Foundation, either version 3 of the License, or
   273                              <1> ; (at your option) any later version.
   274                              <1> ;
   275                              <1> ; This program is distributed in the hope that it will be useful,
   276                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   277                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   278                              <1> ; GNU General Public License for more details.
   279                              <1> ;
   280                              <1> ; You should have received a copy of the GNU General Public License
   281                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   282                              <1> ;
   283                              <1> ;=========================================================================
   284                              <1> int_1F:
   285 00000A4A 1E3666667E666600    <1> 	db	 1Eh,  36h,  66h,  66h,  7Eh,  66h,  66h,  00h
   286 00000A52 7C60607C66667C00    <1> 	db	 7Ch,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   287 00000A5A 7C66667C66667C00    <1> 	db	 7Ch,  66h,  66h,  7Ch,  66h,  66h,  7Ch,  00h
   288 00000A62 7E60606060606000    <1> 	db	 7Eh,  60h,  60h,  60h,  60h,  60h,  60h,  00h
   289 00000A6A 386C6C6C6C6CFEC6    <1> 	db	 38h,  6Ch,  6Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   290 00000A72 7E60607C60607E00    <1> 	db	 7Eh,  60h,  60h,  7Ch,  60h,  60h,  7Eh,  00h
   291 00000A7A DBDB7E3C7EDBDB00    <1> 	db	0DBh, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh, 0DBh,  00h
   292 00000A82 3C66061C06663C00    <1> 	db	 3Ch,  66h,  06h,  1Ch,  06h,  66h,  3Ch,  00h
   293 00000A8A 66666E7E76666600    <1> 	db	 66h,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   294 00000A92 3C666E7E76666600    <1> 	db	 3Ch,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   295 00000A9A 666C7870786C6600    <1> 	db	 66h,  6Ch,  78h,  70h,  78h,  6Ch,  66h,  00h
   296 00000AA2 1E36666666666600    <1> 	db	 1Eh,  36h,  66h,  66h,  66h,  66h,  66h,  00h
   297 00000AAA C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
   298 00000AB2 6666667E66666600    <1> 	db	 66h,  66h,  66h,  7Eh,  66h,  66h,  66h,  00h
   299 00000ABA 3C66666666663C00    <1> 	db	 3Ch,  66h,  66h,  66h,  66h,  66h,  3Ch,  00h
   300 00000AC2 7E66666666666600    <1> 	db	 7Eh,  66h,  66h,  66h,  66h,  66h,  66h,  00h
   301 00000ACA 7C6666667C606000    <1> 	db	 7Ch,  66h,  66h,  66h,  7Ch,  60h,  60h,  00h
   302 00000AD2 3C66606060663C00    <1> 	db	 3Ch,  66h,  60h,  60h,  60h,  66h,  3Ch,  00h
   303 00000ADA 7E18181818181800    <1> 	db	 7Eh,  18h,  18h,  18h,  18h,  18h,  18h,  00h
   304 00000AE2 6666663E06663C00    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  66h,  3Ch,  00h
   305 00000AEA 7EDBDBDB7E181800    <1> 	db	 7Eh, 0DBh, 0DBh, 0DBh,  7Eh,  18h,  18h,  00h
   306 00000AF2 66663C183C666600    <1> 	db	 66h,  66h,  3Ch,  18h,  3Ch,  66h,  66h,  00h
   307 00000AFA 6666666666667F03    <1> 	db	 66h,  66h,  66h,  66h,  66h,  66h,  7Fh,  03h
   308 00000B02 6666663E06060600    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  06h,  06h,  00h
   309 00000B0A DBDBDBDBDBDBFF00    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   310 00000B12 DBDBDBDBDBDBFF03    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   311 00000B1A E060607C66667C00    <1> 	db	0E0h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   312 00000B22 C6C6C6F6DEDEF600    <1> 	db	0C6h, 0C6h, 0C6h, 0F6h, 0DEh, 0DEh, 0F6h,  00h
   313 00000B2A 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   314 00000B32 788C063E068C7800    <1> 	db	 78h,  8Ch,  06h,  3Eh,  06h,  8Ch,  78h,  00h
   315 00000B3A CEDBDBFBDBDBCE00    <1> 	db	0CEh, 0DBh, 0DBh, 0FBh, 0DBh, 0DBh, 0CEh,  00h
   316 00000B42 3E6666663E366600    <1> 	db	 3Eh,  66h,  66h,  66h,  3Eh,  36h,  66h,  00h
   317 00000B4A 0000780C7CCC7600    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  76h,  00h
   318 00000B52 003C603C66663C00    <1> 	db	 00h,  3Ch,  60h,  3Ch,  66h,  66h,  3Ch,  00h
   319 00000B5A 00007C667C667C00    <1> 	db	 00h,  00h,  7Ch,  66h,  7Ch,  66h,  7Ch,  00h
   320 00000B62 00007E6060606000    <1> 	db	 00h,  00h,  7Eh,  60h,  60h,  60h,  60h,  00h
   321 00000B6A 00003C6C6C6CFEC6    <1> 	db	 00h,  00h,  3Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   322 00000B72 00003C667E603C00    <1> 	db	 00h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   323 00000B7A 0000DB7E3C7EDB00    <1> 	db	 00h,  00h, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh,  00h
   324 00000B82 00003C660C663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  0Ch,  66h,  3Ch,  00h
   325 00000B8A 0000666E7E766600    <1> 	db	 00h,  00h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   326 00000B92 0018666E7E766600    <1> 	db	 00h,  18h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   327 00000B9A 0000666C786C6600    <1> 	db	 00h,  00h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
   328 00000BA2 00001E3666666600    <1> 	db	 00h,  00h,  1Eh,  36h,  66h,  66h,  66h,  00h
   329 00000BAA 0000C6FEFED6C600    <1> 	db	 00h,  00h, 0C6h, 0FEh, 0FEh, 0D6h, 0C6h,  00h
   330 00000BB2 000066667E666600    <1> 	db	 00h,  00h,  66h,  66h,  7Eh,  66h,  66h,  00h
   331 00000BBA 00003C6666663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  66h,  66h,  3Ch,  00h
   332 00000BC2 00007E6666666600    <1> 	db	 00h,  00h,  7Eh,  66h,  66h,  66h,  66h,  00h
   333 00000BCA 1144114411441144    <1> 	db	 11h,  44h,  11h,  44h,  11h,  44h,  11h,  44h
   334 00000BD2 55AA55AA55AA55AA    <1> 	db	 55h, 0AAh,  55h, 0AAh,  55h, 0AAh,  55h, 0AAh
   335 00000BDA DD77DD77DD77DD77    <1> 	db	0DDh,  77h, 0DDh,  77h, 0DDh,  77h, 0DDh,  77h
   336 00000BE2 1818181818181818    <1> 	db	 18h,  18h,  18h,  18h,  18h,  18h,  18h,  18h
   337 00000BEA 181818F818181818    <1> 	db	 18h,  18h,  18h, 0F8h,  18h,  18h,  18h,  18h
   338 00000BF2 18F818F818181818    <1> 	db	 18h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   339 00000BFA 363636F636363636    <1> 	db	 36h,  36h,  36h, 0F6h,  36h,  36h,  36h,  36h
   340 00000C02 000000FE36363636    <1> 	db	 00h,  00h,  00h, 0FEh,  36h,  36h,  36h,  36h
   341 00000C0A 00F818F818181818    <1> 	db	 00h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   342 00000C12 36F606F636363636    <1> 	db	 36h, 0F6h,  06h, 0F6h,  36h,  36h,  36h,  36h
   343 00000C1A 3636363636363636    <1> 	db	 36h,  36h,  36h,  36h,  36h,  36h,  36h,  36h
   344 00000C22 00FE06F636363636    <1> 	db	 00h, 0FEh,  06h,  0F6h, 36h,  36h,  36h,  36h
   345 00000C2A 36F606FE00000000    <1> 	db	 36h, 0F6h,  06h, 0FEh,  00h,  00h,  00h,  00h
   346 00000C32 363636FE00000000    <1> 	db	 36h,  36h,  36h, 0FEh,  00h,  00h,  00h,  00h
   347 00000C3A 18F818F800000000    <1> 	db	 18h, 0F8h,  18h, 0F8h,  00h,  00h,  00h,  00h
   348 00000C42 000000F818181818    <1> 	db	 00h,  00h,  00h, 0F8h,  18h,  18h,  18h,  18h
   349 00000C4A 1818181F00000000    <1> 	db	 18h,  18h,  18h,  1Fh,  00h,  00h,  00h,  00h
   350 00000C52 181818FF00000000    <1> 	db	 18h,  18h,  18h, 0FFh,  00h,  00h,  00h,  00h
   351 00000C5A 000000FF18181818    <1> 	db	 00h,  00h,  00h, 0FFh,  18h,  18h,  18h,  18h
   352 00000C62 1818181F18181818    <1> 	db	 18h,  18h,  18h,  1Fh,  18h,  18h,  18h,  18h
   353 00000C6A 000000FF00000000    <1> 	db	 00h,  00h,  00h, 0FFh,  00h,  00h,  00h,  00h
   354 00000C72 181818FF18181818    <1> 	db	 18h,  18h,  18h,  0FFh, 18h,  18h,  18h,  18h
   355 00000C7A 181F181F18181818    <1> 	db	 18h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   356 00000C82 3636363736363636    <1> 	db	 36h,  36h,  36h,  37h,  36h,  36h,  36h,  36h
   357 00000C8A 3637303F00000000    <1> 	db	 36h,  37h,  30h,  3Fh,  00h,  00h,  00h,  00h
   358 00000C92 003F303736363636    <1> 	db	 00h,  3Fh,  30h,  37h,  36h,  36h,  36h,  36h
   359 00000C9A 36F700FF00000000    <1> 	db	 36h, 0F7h,  00h, 0FFh,  00h,  00h,  00h,  00h
   360 00000CA2 00FF00F736363636    <1> 	db	 00h, 0FFh,  00h, 0F7h,  36h,  36h,  36h,  36h
   361 00000CAA 3637303736363636    <1> 	db	 36h,  37h,  30h,  37h,  36h,  36h,  36h,  36h
   362 00000CB2 00FF00FF00000000    <1> 	db	 00h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   363 00000CBA 36F700F736363636    <1> 	db	 36h, 0F7h,  00h, 0F7h,  36h,  36h,  36h,  36h
   364 00000CC2 18FF00FF00000000    <1> 	db	 18h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   365 00000CCA 363636FF00000000    <1> 	db	 36h,  36h,  36h, 0FFh,  00h,  00h,  00h,  00h
   366 00000CD2 00FF00FF18181818    <1> 	db	 00h, 0FFh,  00h, 0FFh,  18h,  18h,  18h,  18h
   367 00000CDA 000000FF36363636    <1> 	db	 00h,  00h,  00h, 0FFh,  36h,  36h,  36h,  36h
   368 00000CE2 3636363F00000000    <1> 	db	 36h,  36h,  36h,  3Fh,  00h,  00h,  00h,  00h
   369 00000CEA 181F181F00000000    <1> 	db	 18h,  1Fh,  18h,  1Fh,  00h,  00h,  00h,  00h
   370 00000CF2 001F181F18181818    <1> 	db	 00h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   371 00000CFA 0000003F36363636    <1> 	db	 00h,  00h,  00h,  3Fh,  36h,  36h,  36h,  36h
   372 00000D02 363636FF36363636    <1> 	db	 36h,  36h,  36h, 0FFh,  36h,  36h,  36h,  36h
   373 00000D0A 18FF18FF18181818    <1> 	db	 18h, 0FFh,  18h, 0FFh,  18h,  18h,  18h,  18h
   374 00000D12 181818F800000000    <1> 	db	 18h,  18h,  18h, 0F8h,  00h,  00h,  00h,  00h
   375 00000D1A 0000001F18181818    <1> 	db	 00h,  00h,  00h,  1Fh,  18h,  18h,  18h,  18h
   376 00000D22 FFFFFFFFFFFFFFFF    <1> 	db	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   377 00000D2A 000000FFFFFFFFFF    <1> 	db	 00h,  00h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   378 00000D32 F0F0F0F0F0F0F0F0    <1> 	db	0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h
   379 00000D3A 0F0F0F0F0F0F0F0F    <1> 	db	 0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh
   380 00000D42 FFFFFF0000000000    <1> 	db	0FFh, 0FFh, 0FFh,  00h,  00h,  00h,  00h,  00h
   381 00000D4A 00007C66667C6000    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  00h
   382 00000D52 00003C6660663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  60h,  66h,  3Ch,  00h
   383 00000D5A 00007E1818181800    <1> 	db	 00h,  00h,  7Eh,  18h,  18h,  18h,  18h,  00h
   384 00000D62 000066663E063C00    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  3Ch,  00h
   385 00000D6A 00007EDBDB7E1800    <1> 	db	 00h,  00h,  7Eh, 0DBh, 0DBh,  7Eh,  18h,  00h
   386 00000D72 0000663C183C6600    <1> 	db	 00h,  00h,  66h,  3Ch,  18h,  3Ch,  66h,  00h
   387 00000D7A 0000666666667F03    <1> 	db	 00h,  00h,  66h,  66h,  66h,  66h,  7Fh,  03h
   388 00000D82 000066663E060600    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  06h,  00h
   389 00000D8A 0000DBDBDBDBFF00    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   390 00000D92 0000DBDBDBDBFF03    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   391 00000D9A 0000E0607C667C00    <1> 	db	 00h,  00h, 0E0h,  60h,  7Ch,  66h,  7Ch,  00h
   392 00000DA2 0000C6C6F6DEF600    <1> 	db	 00h,  00h, 0C6h, 0C6h, 0F6h, 0DEh, 0F6h,  00h
   393 00000DAA 000060607C667C00    <1> 	db	 00h,  00h,  60h,  60h,  7Ch,  66h,  7Ch,  00h
   394 00000DB2 00007C063E067C00    <1> 	db	 00h,  00h,  7Ch,  06h,  3Eh,  06h,  7Ch,  00h
   395 00000DBA 0000CEDBFBDBCE00    <1> 	db	 00h,  00h, 0CEh, 0DBh, 0FBh, 0DBh, 0CEh,  00h
   396 00000DC2 00003E663E366600    <1> 	db	 00h,  00h,  3Eh,  66h,  3Eh,  36h,  66h,  00h
   397 00000DCA 66007E607C607E00    <1> 	db	 66h,  00h,  7Eh,  60h,  7Ch,  60h,  7Eh,  00h
   398 00000DD2 24003C667E603C00    <1> 	db	 24h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   399 00000DDA 0030180C060C1830    <1> 	db	 00h,  30h,  18h,  0Ch,  06h,  0Ch,  18h,  30h
   400 00000DE2 000C18306030180C    <1> 	db	 00h,  0Ch,  18h,  30h,  60h,  30h,  18h,  0Ch
   401 00000DEA 0E1B1B1818181818    <1> 	db	 0Eh,  1Bh,  1Bh,  18h,  18h,  18h,  18h,  18h
   402 00000DF2 1818181818D8D870    <1> 	db	 18h,  18h,  18h,  18h,  18h, 0D8h, 0D8h,  70h
   403 00000DFA 001818007E001818    <1> 	db	 00h,  18h,  18h,  00h,  7Eh,  00h,  18h,  18h
   404 00000E02 0076DC0076DC0000    <1> 	db	 00h,  76h, 0DCh,  00h,  76h, 0DCh,  00h,  00h
   405 00000E0A 00386C6C38000000    <1> 	db	 00h,  38h,  6Ch,  6Ch,  38h,  00h,  00h,  00h
   406 00000E12 0000000018000000    <1> 	db	 00h,  00h,  00h,  00h,  18h,  00h,  00h,  00h
   407 00000E1A 0000003838000000    <1> 	db	 00h,  00h,  00h,  38h,  38h,  00h,  00h,  00h
   408 00000E22 03020604CC683810    <1> 	db	 03h,  02h,  06h,  04h, 0CCh,  68h,  38h,  10h
   409 00000E2A 3C4299A1A199423C    <1> 	db	 3Ch,  42h,  99h, 0A1h, 0A1h,  99h,  42h,  3Ch
   410 00000E32 3048102078000000    <1> 	db	 30h,  48h,  10h,  20h,  78h,  00h,  00h,  00h
   411 00000E3A 00007C7C7C7C0000    <1> 	db	 00h,  00h,  7Ch,  7Ch,  7Ch,  7Ch,  00h,  00h
   412 00000E42 0000000000427E00    <1> 	db	 00h,  00h,  00h,  00h,  00h,  42h,  7Eh,  00h
   261                                  %endif ; MACHINE_XT
   262                                  ;%include	"inttrace.inc"		; Uncomment for interrupt debugging
   263                                  %ifdef AT_RTC
   264                                  %include	"rtc.inc"		; RTC and CMOS read / write functions
   265                              <1> ;=========================================================================
   266                              <1> ; rtc.inc - RTC/CMOS read and write functions
   267                              <1> ;-------------------------------------------------------------------------
   268                              <1> ;
   269                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   270                              <1> ;
   271                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
   272                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   273                              <1> ;
   274                              <1> ; This program is free software: you can redistribute it and/or modify
   275                              <1> ; it under the terms of the GNU General Public License as published by
   276                              <1> ; the Free Software Foundation, either version 3 of the License, or
   277                              <1> ; (at your option) any later version.
   278                              <1> ;
   279                              <1> ; This program is distributed in the hope that it will be useful,
   280                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   281                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   282                              <1> ; GNU General Public License for more details.
   283                              <1> ;
   284                              <1> ; You should have received a copy of the GNU General Public License
   285                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   286                              <1> ;
   287                              <1> ;=========================================================================
   288                              <1> 
   289                              <1> ;-------------------------------------------------------------------------
   290                              <1> ; RTC ports
   291                              <1> rtc_addr_reg	equ	70h	; RTC address port
   292                              <1> rtc_data_reg	equ	71h	; RTC data port
   293                              <1> 
   294                              <1> ;-------------------------------------------------------------------------
   295                              <1> ; locations in RTC and NVRAM
   296                              <1> cmos_seconds	equ	00h	; seconds location in RTC
   297                              <1> cmos_alarm_secs	equ	01h	; alarm seconds location in RTC
   298                              <1> cmos_minutes	equ	02h	; minutes location in RTC
   299                              <1> cmos_alarm_mins	equ	03h	; alarm minutes location in RTC
   300                              <1> cmos_hours	equ	04h	; hours locaiton in RTC
   301                              <1> cmos_alarm_hrs	equ	05h	; alarm hours location in RTC
   302                              <1> cmos_day	equ	06h	; day location in RTC
   303                              <1> cmos_date	equ	07h	; date location in RTC
   304                              <1> cmos_month	equ	08h	; month location in RTC
   305                              <1> cmos_year	equ	09h	; year location in RTC
   306                              <1> cmos_floppy	equ	10h	; floppy type byte
   307                              <1> cmos_equip	equ	14h	; equipment byte
   308                              <1> cmos_config_a	equ	2Dh	; BIOS configuration byte A
   309                              <1> cmos_sum_hi	equ	2Eh	; checksum of bytes 10h - 20h - high byte
   310                              <1> cmos_sum_lo	equ	2Fh	; checksum of bytes 10h - 20h - low byte 
   311                              <1> cmos_century	equ	32h	; centry location in RTC (DS12C887 only)
   312                              <1> 
   313                              <1> ;-------------------------------------------------------------------------
   314                              <1> ; RTC control register and their bits
   315                              <1> cmos_control_a	equ	0Ah	; RTC control A register
   316                              <1> cmos_uip	equ	80h	; RTC update in progress bit
   317                              <1> cmos_control_b	equ	0Bh	; RTC control B register
   318                              <1> cmos_dse	equ	01h	; RTC daylight savings enable bit
   319                              <1> cmos_24hours	equ	02h	; RTC 24 hours format (1 = 24 hours, 0 = 12)
   320                              <1> cmos_uie	equ	10h	; RTC update ended interrupt enable bit
   321                              <1> cmos_aie	equ	20h	; RTC alarm interrupt enable bit
   322                              <1> cmos_pie	equ	40h	; RTC periodic interrupt enable bit
   323                              <1> cmos_set	equ	80h	; RTC set bit (0 = normal operation, 1 = set)
   324                              <1> cmos_control_c	equ	0Ch	; RTC control C register
   325                              <1> cmos_uf		equ	20h	; RTC update ended interrupt flag
   326                              <1> cmos_af		equ	40h	; RTC alarm interrupt flag
   327                              <1> cmos_pf		equ	80h	; RTC periodic interrupt flag
   328                              <1> cmos_control_d	equ	0Dh	; RTC control D register
   329                              <1> cmos_vrt	equ	80h	; RTC vrt bit (1 = battery is OK)
   330                              <1> 
   331                              <1> ;=========================================================================
   332                              <1> ; rtc_read - Read byte from RTC or CMOS memory
   333                              <1> ; Input:
   334                              <1> ;	AL - address and NMI enable bit
   335                              <1> ;		bits 6-0 - address of byte to read
   336                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   337                              <1> ; Output:
   338                              <1> ;	AL = byte from RTC
   339                              <1> ;-------------------------------------------------------------------------
   340                              <1> rtc_read:
   341 00000E4A FA                  <1> 	cli
   342                              <1> %ifndef AT_RTC_PORT
   343 00000E4B E670                <1> 	out	rtc_addr_reg,al
   344 00000E4D EB00                <1> 	jmp	$+2
   345 00000E4F EB00                <1> 	jmp	$+2
   346 00000E51 EB00                <1> 	jmp	$+2
   347 00000E53 EB00                <1> 	jmp	$+2
   348 00000E55 E471                <1> 	in	al,rtc_data_reg
   349                              <1> %else ; AT_RTC_PORT
   350                              <1> 	push	dx
   351                              <1> 	mov	dx,AT_RTC_PORT
   352                              <1> 	out	dx,al
   353                              <1> 	jmp	$+2
   354                              <1> 	jmp	$+2
   355                              <1> 	jmp	$+2
   356                              <1> 	jmp	$+2
   357                              <1> 	inc	dx			; DX = RTC data register
   358                              <1> 	in	al,dx
   359                              <1> 	pop	dx
   360                              <1> %endif ; AT_RTC_PORT
   361 00000E57 FB                  <1> 	sti
   362 00000E58 C3                  <1> 	ret
   363                              <1> 
   364                              <1> ;=========================================================================
   365                              <1> ; rtc_write - Read byte to RTC or CMOS memory
   366                              <1> ; Input:
   367                              <1> ;	AL - address and NMI enable bit
   368                              <1> ;		bits 6-0 - address of byte to read
   369                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   370                              <1> ;	AH = byte to write to RTC
   371                              <1> ;-------------------------------------------------------------------------
   372                              <1> rtc_write:
   373 00000E59 FA                  <1> 	cli
   374                              <1> %ifndef AT_RTC_PORT
   375 00000E5A E670                <1> 	out	rtc_addr_reg,al
   376 00000E5C EB00                <1> 	jmp	$+2
   377 00000E5E EB00                <1> 	jmp	$+2
   378 00000E60 EB00                <1> 	jmp	$+2
   379 00000E62 EB00                <1> 	jmp	$+2
   380 00000E64 86E0                <1> 	xchg	ah,al
   381 00000E66 E671                <1> 	out	rtc_data_reg,al
   382                              <1> %else ; AT_RTC_PORT
   383                              <1> 	push	dx
   384                              <1> 	mov	dx,AT_RTC_PORT
   385                              <1> 	out	dx,al
   386                              <1> 	jmp	$+2
   387                              <1> 	jmp	$+2
   388                              <1> 	jmp	$+2
   389                              <1> 	jmp	$+2
   390                              <1> 	xchg	ah,al
   391                              <1> 	inc	dx			; DX = RTC data register
   392                              <1> 	out	dx,al
   393                              <1> 	pop	dx
   394                              <1> %endif ; AT_RTC_PORT
   395 00000E68 86E0                <1> 	xchg	ah,al
   396 00000E6A FB                  <1> 	sti
   397 00000E6B C3                  <1> 	ret
   398                              <1> 
   399                              <1> ;=========================================================================
   400                              <1> ; set_system_timer - set timer variables to RTC time
   401                              <1> ;-------------------------------------------------------------------------
   402                              <1> set_system_timer:
   403 00000E6C 50                  <1> 	push	ax
   404 00000E6D 53                  <1> 	push	bx
   405 00000E6E 51                  <1> 	push	cx
   406 00000E6F 52                  <1> 	push	dx
   407 00000E70 56                  <1> 	push	si
   408 00000E71 57                  <1> 	push	di
   409                              <1> 
   410 00000E72 B402                <1> 	mov	ah,02h			; int 1Ah, function 02h - get RTC time
   411 00000E74 CD1A                <1> 	int	1Ah
   412                              <1> 
   413                              <1> ; convert time to ticks * 2^11
   414                              <1> 
   415                              <1> ; ticks = seconds * 37287
   416 00000E76 88F0                <1> 	mov	al,dh
   417 00000E78 E8BA00              <1> 	call	bcd_to_binary		; convert seconds to binary
   418                              <1> 
   419 00000E7B BAA791              <1> 	mov	dx,37287
   420 00000E7E F7E2                <1> 	mul	dx			; DX:AX = seconds * 37287
   421                              <1> 
   422 00000E80 89C6                <1> 	mov	si,ax
   423 00000E82 89D7                <1> 	mov	di,dx
   424                              <1> 
   425                              <1> ; ticks += minutes * 2237216 = minutes * 8992 + minutes * 34 * 2^16
   426 00000E84 88C8                <1> 	mov	al,cl
   427 00000E86 E8AC00              <1> 	call	bcd_to_binary		; convert minutes to binary
   428                              <1> 
   429 00000E89 89C3                <1> 	mov	bx,ax
   430 00000E8B BA2023              <1> 	mov	dx,8992
   431 00000E8E F7E2                <1> 	mul	dx			; DX:AX = minutes * 8992
   432                              <1> 
   433 00000E90 01C6                <1> 	add	si,ax
   434 00000E92 11D7                <1> 	adc	di,dx
   435                              <1> 
   436 00000E94 89D8                <1> 	mov	ax,bx
   437 00000E96 BA2200              <1> 	mov	dx,34
   438 00000E99 F7E2                <1> 	mul	dx
   439                              <1> 
   440 00000E9B 01C7                <1> 	add	di,ax
   441                              <1> 
   442                              <1> ; ticks += hours * 134232938 = hours * 15210 + hours * 2048 * 2^16
   443 00000E9D 88E8                <1> 	mov	al,ch
   444 00000E9F E89300              <1> 	call	bcd_to_binary		; convert hours to binary
   445                              <1> 
   446 00000EA2 89C3                <1> 	mov	bx,ax
   447 00000EA4 BA6A3B              <1> 	mov	dx,15210
   448 00000EA7 F7E2                <1> 	mul	dx			; DX:AX = hours * 15210
   449                              <1> 
   450 00000EA9 01C6                <1> 	add	si,ax
   451 00000EAB 11D7                <1> 	adc	di,dx
   452                              <1> 
   453 00000EAD 89D8                <1> 	mov	ax,bx
   454 00000EAF BA0008              <1> 	mov	dx,2048
   455 00000EB2 F7E2                <1> 	mul	dx			; AX = hours * 2048
   456                              <1> 
   457 00000EB4 01C7                <1> 	add	di,ax
   458                              <1> 
   459                              <1> ; CX:DX = DI:SI / 2048
   460 00000EB6 B10B                <1> 	mov	cl,11
   461 00000EB8 D3EE                <1> 	shr	si,cl
   462 00000EBA 89FA                <1> 	mov	dx,di
   463 00000EBC B105                <1> 	mov	cl,5
   464 00000EBE D3E2                <1> 	shl	dx,cl
   465 00000EC0 09F2                <1> 	or	dx,si
   466                              <1> 
   467 00000EC2 B10B                <1> 	mov	cl,11
   468 00000EC4 D3EF                <1> 	shr	di,cl
   469 00000EC6 89F9                <1> 	mov	cx,di
   470                              <1> 
   471                              <1> 					; CX = high word of tick count
   472                              <1> 					; DX = low word of tick count
   473                              <1> 	
   474 00000EC8 B401                <1> 	mov	ah,01h			; int 1Ah, function 01h - set time
   475 00000ECA CD1A                <1> 	int	1Ah
   476 00000ECC 5F                  <1> 	pop	di
   477 00000ECD 5E                  <1> 	pop	si
   478 00000ECE 5A                  <1> 	pop	dx
   479 00000ECF 59                  <1> 	pop	cx
   480 00000ED0 5B                  <1> 	pop	bx
   481 00000ED1 58                  <1> 	pop	ax
   482 00000ED2 C3                  <1> 	ret
   483                              <1> 
   484                              <1> ;=========================================================================
   485                              <1> ; rtc_init - Initialize RTC
   486                              <1> ; Notes:
   487                              <1> ;	- makes sure RTC battery is OK, resets time if not
   488                              <1> ;	- disables RTC interrupts
   489                              <1> ;	- validates NVRAM checksum, loads default values if invalid
   490                              <1> ;-------------------------------------------------------------------------
   491                              <1> rtc_init:
   492 00000ED3 50                  <1> 	push	ax
   493 00000ED4 53                  <1> 	push	bx
   494 00000ED5 51                  <1> 	push	cx
   495 00000ED6 52                  <1> 	push	dx
   496 00000ED7 56                  <1> 	push	si
   497 00000ED8 B020                <1> 	mov	al,e_rtc_init
   498 00000EDA E680                <1> 	out	post_reg,al
   499                              <1> %ifdef MACHINE_FE2010A
   500                              <1> %ifndef AT_RTC_PORT
   501                              <1> 	; FE2010 chipset does not fully decode I/O addresses and PPI ports
   502                              <1> 	; 60h-63h are aliased to 70h-73h, so RTC cannot use addresses 70h-71h.
   503                              <1>         ; Therefore port 62h (ppi_pc_reg) reads the same as port 72h.
   504 00000EDC E462                <1> 	in	al,ppi_pc_reg
   505 00000EDE 88C4                <1> 	mov	ah,al
   506 00000EE0 E472                <1> 	in	al,72h
   507 00000EE2 38E0                <1> 	cmp	al,ah
   508 00000EE4 7449                <1> 	je	.exit			; FE2010, will not try to init RTC
   509                              <1> %endif ; AT_RTC_PORT
   510                              <1> %endif ; MACHINE_FE2010A
   511 00000EE6 B00A                <1> 	mov	al,cmos_control_a	; select control A register
   512 00000EE8 B426                <1> 	mov	ah,26h			; turn on oscillator and time keeping
   513                              <1> 					; set SQW frequency to 1.024 KHz
   514 00000EEA E86CFF              <1> 	call	rtc_write		; write control register A
   515                              <1> 
   516                              <1> %ifdef AT_RTC_AUTODETECT
   517 00000EED E85AFF              <1> 	call	rtc_read		; read back control A register
   518 00000EF0 3C26                <1> 	cmp	al,26h
   519 00000EF2 753B                <1> 	jne	.exit			; RTC is not responding, exit
   520                              <1> %endif ; AT_RTC_AUTODETECT
   521                              <1> 
   522 00000EF4 B00B                <1> 	mov	al,cmos_control_b
   523 00000EF6 E851FF              <1> 	call	rtc_read
   524 00000EF9 88C4                <1> 	mov	ah,al
   525 00000EFB 80E401              <1> 	and	ah,cmos_dse		; clear all bits except of DSE
   526 00000EFE 80CC02              <1> 	or	ah,cmos_24hours		; set 24 hours bit, keep BCD format and
   527                              <1> 					; interrupts disabled
   528 00000F01 B00B                <1> 	mov	al,cmos_control_b
   529 00000F03 E853FF              <1> 	call	rtc_write		; write control register B
   530                              <1> 
   531 00000F06 B00C                <1> 	mov	al,cmos_control_c
   532 00000F08 E83FFF              <1> 	call	rtc_read		; read control register C - reset
   533                              <1> 					; interrupt flags
   534                              <1> 
   535 00000F0B B00D                <1> 	mov	al,cmos_control_d
   536 00000F0D E83AFF              <1> 	call	rtc_read		; read control register D
   537 00000F10 A880                <1> 	test	al,cmos_vrt
   538 00000F12 7518                <1> 	jnz	.1			; RTC battery is OK
   539 00000F14 BE[5504]            <1> 	mov	si,msg_rtc_bad
   540 00000F17 E85619              <1> 	call	print
   541                              <1> ; RTC is bad, set initial time
   542 00000F1A B403                <1> 	mov	ah,03h			; int 1Ah, function 03h - set RTC time
   543 00000F1C 31C9                <1> 	xor	cx,cx
   544 00000F1E 31D2                <1> 	xor	dx,dx
   545 00000F20 CD1A                <1> 	int	1Ah
   546 00000F22 B405                <1> 	mov	ah,05h			; int 1Ah, function 05h - set RTC date
   547 00000F24 B91020              <1> 	mov	cx,2010h		; year 2010
   548 00000F27 BA0101              <1> 	mov	dx,0101h		; January 1st
   549 00000F2A CD1A                <1> 	int	1Ah
   550                              <1> 
   551                              <1> .1:
   552                              <1> 
   553 00000F2C E83DFF              <1> 	call	set_system_timer		; set timer variables to RTC time
   554                              <1> 
   555                              <1> %ifdef AT_RTC_NVRAM
   556                              <1> ; compare NVRAM checksum with stored value
   557                              <1> 
   558                              <1> 	call	nvram_checksum
   559                              <1> 
   560                              <1> 	mov	al,cmos_sum_hi
   561                              <1> 	call	rtc_read
   562                              <1> 	mov	ah,al
   563                              <1> 	mov	al,cmos_sum_lo
   564                              <1> 	call	rtc_read
   565                              <1> 	cmp	bx,ax
   566                              <1> 	je	.update_equipment
   567                              <1> 
   568                              <1> 	mov	si,msg_rtc_sum
   569                              <1> 	call	print
   570                              <1> 
   571                              <1> ; clear NVRAM
   572                              <1> 
   573                              <1> 	mov	ax,0010h		; start from 10h, load 00h
   574                              <1> 
   575                              <1> .nvram_clear_loop:
   576                              <1> 	call	rtc_write
   577                              <1> 	inc	al
   578                              <1> 	cmp	al,20h			; last address is 20h
   579                              <1> 	jbe	.nvram_clear_loop
   580                              <1> 
   581                              <1> 	mov	al,cmos_floppy		; write default floppy type
   582                              <1>     cs	mov	ah,byte [default_floppy]
   583                              <1> 	call	rtc_write
   584                              <1> 
   585                              <1> 	mov	al,cmos_equip		; write default equipment byte
   586                              <1>     cs	mov	ah,byte [default_equip]
   587                              <1> 	call	rtc_write
   588                              <1> 
   589                              <1> ; update checksum
   590                              <1> 
   591                              <1> 	call	nvram_checksum
   592                              <1> 
   593                              <1> 	mov	al,cmos_sum_hi
   594                              <1> 	mov	ah,bh
   595                              <1> 	call	rtc_write
   596                              <1> 
   597                              <1> 	inc	al			; AL = cmos_sum_lo
   598                              <1> 	mov	ah,bl
   599                              <1> 	call	rtc_write
   600                              <1> 
   601                              <1> ; read equipment byte from NVRAM and set it in BIOS data area
   602                              <1> 
   603                              <1> .update_equipment:
   604                              <1> 	mov	al,cmos_equip
   605                              <1> 	call	rtc_read
   606                              <1> 	and	al,~(equip_video|equip_mouse)   ; these are autodetected
   607                              <1> 	and	byte [equipment_list],equip_video|equip_mouse
   608                              <1> 	or	byte [equipment_list],al
   609                              <1> 
   610                              <1> %endif ; AT_RTC_NVRAM
   611                              <1> 
   612                              <1> .exit:
   613 00000F2F 5E                  <1> 	pop	si
   614 00000F30 5A                  <1> 	pop	dx
   615 00000F31 59                  <1> 	pop	cx
   616 00000F32 5B                  <1> 	pop	bx
   617 00000F33 58                  <1> 	pop	ax
   618 00000F34 C3                  <1> 	ret
   619                              <1> 
   620                              <1> bcd_to_binary:
   621 00000F35 51                  <1> 	push	cx
   622 00000F36 88C5                <1> 	mov	ch,al
   623 00000F38 80E50F              <1> 	and	ch,0Fh
   624 00000F3B B104                <1> 	mov	cl,4
   625 00000F3D D2E8                <1> 	shr	al,cl
   626 00000F3F B10A                <1> 	mov	cl,10
   627 00000F41 F6E1                <1> 	mul	cl
   628 00000F43 00E8                <1> 	add	al,ch
   629 00000F45 59                  <1> 	pop	cx
   630 00000F46 C3                  <1> 	ret
   631                              <1> 
   632                              <1> %ifdef AT_RTC_NVRAM
   633                              <1> ;=========================================================================
   634                              <1> ; nvram_checksum - calculate NVRAM checksum
   635                              <1> ; Input:
   636                              <1> ;	none
   637                              <1> ; Output:
   638                              <1> ;	BX = NVRAM checksum
   639                              <1> ;-------------------------------------------------------------------------
   640                              <1> nvram_checksum:
   641                              <1> 	push	ax
   642                              <1> 	xor	bx,bx
   643                              <1> 	mov	ah,10h			; start from 10h
   644                              <1> 
   645                              <1> .checksum_loop:
   646                              <1> 	mov	al,ah
   647                              <1> 	call	rtc_read
   648                              <1> 	add	bl,al			; BX += AL
   649                              <1> 	adc	bh,0
   650                              <1> 	inc	ah
   651                              <1> 	cmp	ah,20h			; last address is 20h
   652                              <1> 	jbe	.checksum_loop
   653                              <1> 	pop	ax
   654                              <1> 	ret
   655                              <1> 
   656                              <1> ;=========================================================================
   657                              <1> ; nvram_save - Save configuration to CMOS memory
   658                              <1> ; Input:
   659                              <1> ;	CH - CPU Clock speed
   660                              <1> ;	     0 - 4.77 Mhz / Normal
   661                              <1> ;	     1 - 7.16 Mhz / Turbo
   662                              <1> ;	     2 - 9.55 Mhz (FE2010A only)
   663                              <1> ;
   664                              <1> ;	CL - CMOS floppy drive type
   665                              <1> ;	     7-4 - first floppy drive type
   666                              <1> ;	     3-0 - second floppy drive type
   667                              <1> ;-------------------------------------------------------------------------
   668                              <1> nvram_save:
   669                              <1> 	push	ax
   670                              <1> 	push	bx
   671                              <1> 
   672                              <1> 	mov	al,cmos_config_a
   673                              <1> 	mov	ah,ch
   674                              <1> 	call	rtc_write
   675                              <1> 
   676                              <1> 	mov	al,cmos_floppy
   677                              <1> 	mov	ah,cl
   678                              <1> 	call	rtc_write
   679                              <1> 
   680                              <1> 	mov	ah,byte [equipment_list]
   681                              <1> 	and	ah,03Eh			; mask floppy bits
   682                              <1> 
   683                              <1> 	test	cl,70h
   684                              <1> 	jz	.second_floppy		; jump if first floppy is not installed
   685                              <1> 	or	ah,01h			; first floppy is installed
   686                              <1> 
   687                              <1> .second_floppy:
   688                              <1> 	test	cl,07h
   689                              <1> 	jz	.save_equipment		; jump if second floppy is not installed
   690                              <1> 	or	ah,41h			; indicate two floppies
   691                              <1> 					; (even if the first one is missing)
   692                              <1> 
   693                              <1> .save_equipment:
   694                              <1> 	mov	byte [equipment_list],ah
   695                              <1> 	mov	al,cmos_equip
   696                              <1> 	call	rtc_write
   697                              <1> 
   698                              <1> 	call	nvram_checksum
   699                              <1> 
   700                              <1> 	mov	al,cmos_sum_hi
   701                              <1> 	mov	ah,bh
   702                              <1> 	call	rtc_write
   703                              <1> 
   704                              <1> 	inc	al			; AL = cmos_sum_lo
   705                              <1> 	mov	ah,bl
   706                              <1> 	call	rtc_write
   707                              <1> 
   708                              <1> 	pop	bx
   709                              <1> 	pop	ax
   710                              <1> 	ret
   711                              <1> 
   712                              <1> ;=========================================================================
   713                              <1> ; get_config_a - Return BIOS configuration byte A from NVRAM
   714                              <1> ; Input:
   715                              <1> ;	none
   716                              <1> ; Output:
   717                              <1> ;	AL - NVRAM CPU clock frequency configuration setting
   718                              <1> ;		0 - 4.77 MHz / Normal
   719                              <1> ;		1 - 7.16 MHz / Turbo
   720                              <1> ;		2 - 9.55 MHz (FE2010 only)
   721                              <1> ;-------------------------------------------------------------------------
   722                              <1> get_config_a:
   723                              <1> 	mov	al,cmos_config_a	; read BIOS configuration byte A
   724                              <1> 	call	rtc_read
   725                              <1> 	ret
   726                              <1>   
   727                              <1> ;=========================================================================
   728                              <1> ; get_floppy - Return floppy drive type from NVRAM
   729                              <1> ; Input:
   730                              <1> ;	none
   731                              <1> ; Output:
   732                              <1> ;	AL = floppy drive type
   733                              <1> ;-------------------------------------------------------------------------
   734                              <1> get_floppy:
   735                              <1> 	mov     al,cmos_floppy
   736                              <1> 	call    rtc_read		; read currently configured floppies
   737                              <1> 	ret
   738                              <1> 
   739                              <1> %endif ; AT_RTC_NVRAM
   740                              <1> 
   741                              <1> ;=========================================================================
   742                              <1> ; print_rtc - print current RTC date and time
   743                              <1> ; Input:
   744                              <1> ;	none
   745                              <1> ; Output:
   746                              <1> ;	date and time are printed in YYYY-MM-DD hh:mm:ss format
   747                              <1> ; Notes:
   748                              <1> ;	There is a slight probability of getting inconsistent printout.
   749                              <1> ;	In case the function is called just before midnight, it could
   750                              <1> ;	print the previos day's date and next day's time.
   751                              <1> ;-------------------------------------------------------------------------
   752                              <1> print_rtc:
   753 00000F47 50                  <1> 	push	ax
   754 00000F48 53                  <1> 	push	bx
   755 00000F49 51                  <1> 	push	cx
   756 00000F4A 52                  <1> 	push	dx
   757 00000F4B 56                  <1> 	push	si
   758 00000F4C BE[8802]            <1> 	mov	si,msg_rtc
   759 00000F4F E81E19              <1> 	call	print
   760                              <1> 
   761                              <1> %ifdef AT_RTC_AUTODETECT
   762 00000F52 E86400              <1> 	call	rtc_detect
   763 00000F55 7308                <1> 	jnc	.rtc_present
   764 00000F57 BE[2603]            <1> 	mov	si,msg_absent
   765 00000F5A E81319              <1> 	call	print
   766 00000F5D EB54                <1> 	jmp	.exit
   767                              <1> .rtc_present:
   768                              <1> %endif ; AT_RTC_AUTODETECT
   769                              <1> 
   770                              <1> ; print date
   771 00000F5F B404                <1> 	mov	ah,04h
   772 00000F61 CD1A                <1> 	int	1Ah			; read RTC date
   773                              <1> 					; CH = BCD century
   774                              <1> 					; CL = BCD year
   775                              <1> 					; DH = BCD month
   776                              <1> 					; DL = BCD date (day of month)
   777 00000F63 89C8                <1> 	mov	ax,cx
   778 00000F65 E82319              <1> 	call	print_hex		; print 4-digit year
   779 00000F68 B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
   780 00000F6B BB0700              <1> 	mov	bx,0007h
   781 00000F6E CD10                <1> 	int	10h			; print dash (-)
   782                              <1> 
   783 00000F70 88F0                <1> 	mov	al,dh
   784 00000F72 E82119              <1> 	call	print_byte		; print 2-digit month
   785 00000F75 B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
   786 00000F78 BB0700              <1> 	mov	bx,0007h
   787 00000F7B CD10                <1> 	int	10h			; print dash (-)
   788                              <1> 
   789 00000F7D 88D0                <1> 	mov	al,dl
   790 00000F7F E81419              <1> 	call	print_byte		; print 2-digit date (day of month)
   791                              <1> 
   792 00000F82 B8200E              <1> 	mov	ax,(0Eh << 8) + ' '
   793 00000F85 BB0700              <1> 	mov	bx,0007h
   794 00000F88 CD10                <1> 	int	10h			; print space ( )
   795                              <1> 
   796                              <1> ; print time
   797 00000F8A B402                <1> 	mov	ah,02h
   798 00000F8C CD1A                <1> 	int	1Ah			; read RTC time
   799                              <1> 					; CH = BCD hours
   800                              <1> 					; CL = BCD minutes
   801                              <1> 					; DH = BCD seconds
   802                              <1> 					; DL = daylight saving flag
   803 00000F8E 88E8                <1> 	mov	al,ch
   804 00000F90 E80319              <1> 	call	print_byte		; print 2-digit hours
   805                              <1> 	
   806 00000F93 B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
   807 00000F96 BB0700              <1> 	mov	bx,0007h
   808 00000F99 CD10                <1> 	int	10h			; print colon (:)
   809                              <1> 
   810 00000F9B 88C8                <1> 	mov	al,cl
   811 00000F9D E8F618              <1> 	call	print_byte		; print 2-digit minutes
   812                              <1> 	
   813 00000FA0 B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
   814 00000FA3 BB0700              <1> 	mov	bx,0007h
   815 00000FA6 CD10                <1> 	int	10h			; print colon (:)
   816                              <1> 
   817 00000FA8 88F0                <1> 	mov	al,dh
   818 00000FAA E8E918              <1> 	call	print_byte		; print 2-digit seconds
   819 00000FAD BE[8B00]            <1> 	mov	si,msg_crlf
   820 00000FB0 E8BD18              <1> 	call	print
   821                              <1> 
   822                              <1> .exit:
   823 00000FB3 5E                  <1> 	pop	si
   824 00000FB4 5A                  <1> 	pop	dx
   825 00000FB5 59                  <1> 	pop	cx
   826 00000FB6 5B                  <1> 	pop	bx
   827 00000FB7 58                  <1> 	pop	ax
   828 00000FB8 C3                  <1> 	ret
   829                              <1> 
   830                              <1> %ifdef AT_RTC_AUTODETECT
   831                              <1> ;=========================================================================
   832                              <1> ; rtc_detect - Check RTC is present at 0x70 port
   833                              <1> ; Input:
   834                              <1> ;	none
   835                              <1> ; Output:
   836                              <1> ;	CF == 0 - RTC is present
   837                              <1> ;	CF == 1 - RTC is not detected
   838                              <1> ;-------------------------------------------------------------------------
   839                              <1> rtc_detect:
   840 00000FB9 50                  <1> 	push ax
   841                              <1> %ifdef MACHINE_FE2010A
   842                              <1> %ifndef AT_RTC_PORT
   843                              <1> 	; FE2010 chipset does not fully decode I/O addresses and PPI ports
   844                              <1> 	; 60h-63h are aliased to 70h-73h, so RTC cannot use addresses 70h-71h.
   845                              <1>         ; Therefore port 62h (ppi_pc_reg) reads the same as port 72h.
   846 00000FBA E462                <1> 	in	al,ppi_pc_reg
   847 00000FBC 88C4                <1> 	mov	ah,al
   848 00000FBE E472                <1> 	in	al,72h
   849 00000FC0 38E0                <1> 	cmp	al,ah
   850 00000FC2 7503                <1> 	jne	.not_fe2010
   851 00000FC4 F9                  <1> 	stc				; FE2010, will not try to detect RTC
   852 00000FC5 EB0D                <1> 	jmp	.exit
   853                              <1> .not_fe2010:
   854                              <1> %endif ; AT_RTC_PORT
   855                              <1> %endif ; MACHINE_FE2010A
   856 00000FC7 B00A                <1> 	mov	al,cmos_control_a	; select control A register
   857 00000FC9 E87EFE              <1> 	call    rtc_read		; check if RTC is present
   858 00000FCC 3C26                <1> 	cmp     al,26h
   859 00000FCE 7403                <1> 	je	.rtc_present
   860 00000FD0 F9                  <1> 	stc				; no RTC - set CF
   861 00000FD1 EB01                <1> 	jmp	.exit
   862                              <1> 
   863                              <1> .rtc_present:
   864 00000FD3 F8                  <1> 	clc				; RTC detected - clear CF
   865                              <1> 
   866                              <1> .exit:
   867 00000FD4 58                  <1> 	pop ax
   868 00000FD5 C3                  <1> 	ret
   869                              <1> %endif ; AT_RTC_AUTODETECT
   265                                  %endif ; AT_RTC
   266                                  %ifdef FLASH_NVRAM
   267                                  %include	"flash.inc"		; Flash ROM configuration functions
   268                              <1> ;=========================================================================
   269                              <1> ; flash.inc - Flash ROM programming functions
   270                              <1> ;-------------------------------------------------------------------------
   271                              <1> ;
   272                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   273                              <1> ;
   274                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
   275                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   276                              <1> ;
   277                              <1> ; This program is free software: you can redistribute it and/or modify
   278                              <1> ; it under the terms of the GNU General Public License as published by
   279                              <1> ; the Free Software Foundation, either version 3 of the License, or
   280                              <1> ; (at your option) any later version.
   281                              <1> ;
   282                              <1> ; This program is distributed in the hope that it will be useful,
   283                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   284                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   285                              <1> ; GNU General Public License for more details.
   286                              <1> ;
   287                              <1> ; You should have received a copy of the GNU General Public License
   288                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   289                              <1> ;
   290                              <1> ;=========================================================================
   291                              <1> 
   292                              <1> config_segment	equ	0000h
   293                              <1> config_space	equ	8000h		; offset of the configuration
   294                              <1> flash_floppy	equ	config_space
   295                              <1> flash_config_a	equ	config_space+01h ; BIOS configuration byte A
   296                              <1> flash_checksum	equ	config_space+0Eh ; 16-bit checksum
   297                              <1> temp_segment	equ	07C0h		; segment for flash writing code
   298                              <1> flash_write	equ	0		; offset for flash writing code
   299                              <1> ;=========================================================================
   300                              <1> ; get_config_a - Return BIOS configuration byte A from Flash ROM
   301                              <1> ;		 configuration area
   302                              <1> ; Input:
   303                              <1> ;	none
   304                              <1> ; Output:
   305                              <1> ;	AL - NVRAM CPU clock frequency configuration setting
   306                              <1> ;		0 - 4.77 MHz / Normal
   307                              <1> ;		1 - 7.16 MHz / Turbo
   308                              <1> ;		2 - 9.55 MHz (FE2010A only)
   309                              <1> ;-------------------------------------------------------------------------
   310                              <1> get_config_a:
   311 00000FD6 E81D00              <1> 	call	flash_verify_checksum
   312 00000FD9 7506                <1> 	jnz	.checksum_error		; ZF == 1 - checksum is invalid
   313                              <1> 
   314 00000FDB 2EA00180            <1>     cs	mov	al,byte [flash_config_a] ; return CPU clock configuration
   315 00000FDF EB04                <1> 	jmp	.exit
   316                              <1> 
   317                              <1> .checksum_error:
   318 00000FE1 2EA0[A511]          <1>     cs	mov	al,byte [default_config_a] ; load the default configuration
   319                              <1> 
   320                              <1> .exit:
   321 00000FE5 C3                  <1> 	ret
   322                              <1>   
   323                              <1> ;=========================================================================
   324                              <1> ; get_floppy - Return floppy drive type from Flash ROM configuration area
   325                              <1> ; Input:
   326                              <1> ;	none
   327                              <1> ; Output:
   328                              <1> ;	AL = floppy drive type
   329                              <1> ;-------------------------------------------------------------------------
   330                              <1> get_floppy:
   331 00000FE6 E80D00              <1> 	call	flash_verify_checksum
   332 00000FE9 7506                <1> 	jnz	.checksum_error		; ZF == 0 - checksum is invalid
   333                              <1> 
   334 00000FEB 2EA00080            <1>     cs	mov	al,byte [flash_floppy]	; return floppy type
   335 00000FEF EB04                <1> 	jmp	.exit
   336                              <1> 
   337                              <1> .checksum_error:
   338 00000FF1 2EA0[A311]          <1>     cs  mov	al,byte [default_floppy] ; load the default configuration
   339                              <1> 
   340                              <1> .exit:
   341 00000FF5 C3                  <1> 	ret
   342                              <1> 
   343                              <1> ;=========================================================================
   344                              <1> ; flash_verify_checksum - Verify that checksum is correct
   345                              <1> ; Input:
   346                              <1> ;	none
   347                              <1> ; Output:
   348                              <1> ;	ZF == 1 - checksum is valid
   349                              <1> ;	ZF == 0 - checksum is invalid
   350                              <1> ;-------------------------------------------------------------------------
   351                              <1> flash_verify_checksum:
   352 00000FF6 51                  <1> 	push	cx
   353 00000FF7 52                  <1> 	push	dx
   354 00000FF8 57                  <1> 	push	di
   355 00000FF9 31D2                <1> 	xor	dx,dx
   356 00000FFB BF0080              <1> 	mov	di,config_space
   357 00000FFE B90E00              <1> 	mov	cx,000Eh
   358                              <1> 
   359                              <1> .checksum_loop:				; calculate the 16-bit checksum
   360 00001001 2E0215              <1>     cs	add	dl,byte [di]
   361 00001004 80D600              <1> 	adc	dh,0
   362 00001007 47                  <1> 	inc	di
   363 00001008 E2F7                <1> 	loop	.checksum_loop
   364                              <1> 
   365 0000100A 2E39160E80          <1>     cs	cmp	word [flash_checksum],dx ; compare checksum to the stored value
   366 0000100F 5F                  <1> 	pop	di
   367 00001010 5A                  <1> 	pop	dx
   368 00001011 59                  <1> 	pop	cx
   369 00001012 C3                  <1> 	ret
   370                              <1> 
   371                              <1> ;=========================================================================
   372                              <1> ; flash_save - Save configuration to Flash ROM
   373                              <1> ; Input:
   374                              <1> ;	CH - CPU Clock speed
   375                              <1> ;	     0 - 4.77 Mhz / Normal
   376                              <1> ;	     1 - 7.16 Mhz / Turbo
   377                              <1> ;	     2 - 9.55 Mhz (FE2010A only)
   378                              <1> ;
   379                              <1> ;	CL - CMOS floppy drive type
   380                              <1> ;	     7-4 - first floppy drive type
   381                              <1> ;	     3-0 - second floppy drive type
   382                              <1> ;-------------------------------------------------------------------------
   383                              <1> flash_save:
   384 00001013 50                  <1> 	push	ax
   385 00001014 52                  <1> 	push	dx
   386 00001015 56                  <1> 	push	si
   387 00001016 57                  <1> 	push	di
   388 00001017 1E                  <1> 	push	ds
   389 00001018 06                  <1> 	push	es
   390 00001019 51                  <1> 	push	cx
   391                              <1> 
   392 0000101A BE[050A]            <1> 	mov	si,msg_saving
   393 0000101D E85018              <1> 	call	print
   394                              <1> 
   395 00001020 8CC8                <1> 	mov	ax,cs			; ROM segment
   396 00001022 8ED8                <1> 	mov	ds,ax
   397 00001024 B8C007              <1> 	mov	ax,temp_segment		; copy flash_write_code here
   398 00001027 8EC0                <1> 	mov	es,ax
   399                              <1> 
   400 00001029 BE[8F10]            <1> 	mov	si,flash_write_code
   401 0000102C BF0000              <1> 	mov	di,flash_write
   402 0000102F B91401              <1> 	mov	cx,flash_write_size
   403                              <1> 
   404 00001032 FC                  <1> 	cld
   405 00001033 F3A4                <1>     rep movsb				; copy the flash_write_code
   406                              <1> 
   407 00001035 B80000              <1> 	mov	ax,config_segment	; copy current flash content here
   408 00001038 8EC0                <1> 	mov	es,ax
   409                              <1> 
   410 0000103A BE0080              <1> 	mov	si,config_space
   411 0000103D 89F7                <1> 	mov	di,si			; use the same offset
   412 0000103F B90040              <1> 	mov	cx,16384		; maximal flash segment size (Am29F010)
   413                              <1> 
   414 00001042 FC                  <1> 	cld
   415 00001043 F3A4                <1>     rep movsb
   416                              <1> 
   417 00001045 59                  <1> 	pop	cx			; load the original CX value
   418 00001046 51                  <1> 	push	cx
   419 00001047 26882E0180          <1>     es  mov	byte [flash_config_a],ch ; set new BIOS configuration byte A
   420 0000104C 26880E0080          <1>     es  mov	byte [flash_floppy],cl	; set new floppy drive type    
   421                              <1>     
   422 00001051 B000                <1> 	mov	al,00h			; zero the rest of
   423 00001053 BF0280              <1> 	mov	di,config_space+2	; the configuration space
   424 00001056 B90C00              <1> 	mov	cx,000Ch
   425                              <1> 
   426 00001059 FC                  <1> 	cld
   427 0000105A F3AA                <1>     rep	stosb
   428                              <1> 
   429 0000105C 31D2                <1> 	xor	dx,dx
   430 0000105E BF0080              <1> 	mov	di,config_space
   431 00001061 B90E00              <1> 	mov	cx,000Eh
   432                              <1> 
   433                              <1> .checksum_loop:				; calculate the 16-bit checksum
   434 00001064 260215              <1>     es	add	dl,byte [di]
   435 00001067 80D600              <1> 	adc	dh,0
   436 0000106A 47                  <1> 	inc	di
   437 0000106B E2F7                <1> 	loop	.checksum_loop
   438 0000106D 2689160E80          <1>     es	mov	word [flash_checksum],dx ; store it to the configuration space
   439                              <1> 
   440 00001072 9A0000C007          <1> 	call	temp_segment:flash_write
   441                              <1> 
   442 00001077 7208                <1> 	jc	.error
   443                              <1> 
   444 00001079 BE[2D0A]            <1> 	mov	si,msg_save_ok
   445 0000107C E8F117              <1> 	call	print
   446 0000107F EB06                <1> 	jmp	.exit
   447                              <1> 
   448                              <1> .error:
   449 00001081 BE[320A]            <1> 	mov	si,msg_save_error
   450 00001084 E8E917              <1> 	call	print
   451                              <1> 
   452                              <1> .exit:
   453 00001087 59                  <1> 	pop	cx
   454 00001088 07                  <1> 	pop	es
   455 00001089 1F                  <1> 	pop	ds
   456 0000108A 5F                  <1> 	pop	di
   457 0000108B 5E                  <1> 	pop	si
   458 0000108C 5A                  <1> 	pop	dx
   459 0000108D 58                  <1> 	pop	ax
   460 0000108E C3                  <1> 	ret
   461                              <1> 
   462                              <1> 
   463                              <1> ;=========================================================================
   464                              <1> ; flash_write - Write configuration to Flash ROM
   465                              <1> ;		Must be copied to RAM and run from it
   466                              <1> ; Input:
   467                              <1> ;	Data to write stored at ES:config_space
   468                              <1> ; Output:
   469                              <1> ;	CF clear on success
   470                              <1> ;	CF set on error
   471                              <1> ;	AX,CX,DX,DS,SI,DI trashed
   472                              <1> ;-------------------------------------------------------------------------
   473                              <1> flash_write_code:
   474 0000108F B800F0              <1> 	mov	ax,bioscseg
   475 00001092 8ED8                <1> 	mov	ds,ax
   476                              <1> 
   477 00001094 FA                  <1> 	cli				; no interrupts while writing flash
   478 00001095 B000                <1> 	mov	al,nmi_disable
   479 00001097 E6A0                <1> 	out	nmi_mask_reg,al		; disable NMIs too
   480                              <1> 
   481 00001099 A10000              <1> 	mov	ax,word [0]		; get data from first two bytes of flash
   482                              <1> 
   483                              <1> ; try to identify Flash ROM using 5555h and 0AAAAh addresses for commands
   484 0000109C BE5555              <1> 	mov	si,5555h
   485 0000109F BFAAAA              <1> 	mov	di,0AAAAh
   486 000010A2 C604AA              <1> 	mov	byte [si],0AAh
   487 000010A5 C60555              <1> 	mov	byte [di],55h
   488 000010A8 C60490              <1> 	mov	byte [si],90h		; enter ID mode command
   489 000010AB B90010              <1> 	mov	cx,1000h
   490                              <1> .delay1:
   491 000010AE E2FE                <1> 	loop	.delay1			; some ICs need 10ms delay
   492 000010B0 8B0E0000            <1> 	mov	cx,word [0]		; get device ID
   493 000010B4 39C1                <1> 	cmp	cx,ax			; is it really an ID?
   494 000010B6 7523                <1> 	jne	.select_flash		; yes, try to select the flash type
   495                              <1> 
   496                              <1> ; try to identify Flash ROM using 0555h and 0AAAh addresses for commands
   497 000010B8 BE5505              <1> 	mov	si,0555h
   498 000010BB BFAA0A              <1> 	mov	di,0AAAh
   499 000010BE C604AA              <1> 	mov	byte [si],0AAh
   500 000010C1 C60555              <1> 	mov	byte [di],55h
   501 000010C4 C60490              <1> 	mov	byte [si],90h		; enter ID mode command
   502 000010C7 B90010              <1> 	mov	cx,1000h
   503                              <1> .delay2:
   504 000010CA E2FE                <1> 	loop	.delay2			; some ICs need 10ms delay
   505 000010CC 8B0E0000            <1> 	mov	cx,word [0]		; get device ID
   506 000010D0 39C1                <1> 	cmp	cx,ax			; is it really an ID?
   507 000010D2 7507                <1> 	jne	.select_flash		; yes, try to select the flash type
   508                              <1> 
   509                              <1> ; unable to get Flash ROM ID, return with error
   510                              <1> 
   511                              <1> .error:
   512 000010D4 F9                  <1> 	stc
   513 000010D5 B080                <1> 	mov	al,nmi_enable
   514 000010D7 E6A0                <1> 	out	nmi_mask_reg,al		; enable NMIs
   515 000010D9 FB                  <1> 	sti
   516 000010DA CB                  <1> 	retf
   517                              <1> 
   518                              <1> .select_flash:
   519 000010DB C604AA              <1> 	mov	byte[si],0AAh
   520 000010DE C60555              <1> 	mov	byte[di],55h
   521 000010E1 C604F0              <1> 	mov	byte[si],0F0h		; exit ID mode command
   522                              <1> 
   523                              <1> .try_at29c010:
   524 000010E4 81F91FD5            <1> 	cmp	cx,0D51Fh		; 1F = Atmel, D5 = AT29C010A
   525 000010E8 7505                <1> 	jne	.try_sst29ee010
   526 000010EA B98000              <1> 	mov	cx,128			; sector size is 128 bytes
   527 000010ED EB42                <1> 	jmp	short .write_auto_sector
   528                              <1> 
   529                              <1> .try_sst29ee010:
   530 000010EF 81F9BF07            <1> 	cmp	cx,07BFh		; BF = SST, 07 = SST29EE010/GLS29EE010
   531 000010F3 7505                <1> 	jne	.try_w29ee011
   532 000010F5 B98000              <1> 	mov	cx,128			; sector size is 128 bytes
   533 000010F8 EB37                <1> 	jmp	short .write_auto_sector
   534                              <1> 
   535                              <1> .try_w29ee011:
   536 000010FA 81F9DAC1            <1> 	cmp	cx,0C1DAh		; DA = Winbond, C1 = W29EE011
   537 000010FE 7505                <1> 	jne	.try_sst39sf010
   538 00001100 B98000              <1> 	mov	cx,128			; sector size is 128 bytes
   539 00001103 EB2C                <1> 	jmp	short .write_auto_sector
   540                              <1> 
   541                              <1> .try_sst39sf010:
   542 00001105 81F9BFB5            <1> 	cmp	cx,0B5BFh		; BF = SST, B5 = SST39SF010
   543 00001109 7505                <1> 	jne	.try_sst39sf020
   544 0000110B B90010              <1> 	mov	cx,4096			; sector size is 4 KiB
   545 0000110E EB42                <1> 	jmp	short .write_erase_byte
   546                              <1> 
   547                              <1> .try_sst39sf020:
   548 00001110 81F9BFB6            <1> 	cmp	cx,0B6BFh		; BF = SST, B6 = SST39SF020
   549 00001114 7505                <1> 	jne	.try_sst39sf040
   550 00001116 B90010              <1> 	mov	cx,4096			; sector size is 4 KiB
   551 00001119 EB37                <1> 	jmp	short .write_erase_byte
   552                              <1> 
   553                              <1> .try_sst39sf040:
   554 0000111B 81F9BFB7            <1> 	cmp	cx,0B7BFh		; BF = SST, B7 = SST39SF040
   555 0000111F 7505                <1> 	jne	.try_am29f010
   556 00001121 B90010              <1> 	mov	cx,4096			; sector size is 4 KiB
   557 00001124 EB2C                <1> 	jmp	short .write_erase_byte
   558                              <1> 
   559                              <1> .try_am29f010:
   560 00001126 81F90120            <1> 	cmp	cx,2001h		; 01 = AMD, 20 = Am29F010
   561 0000112A 75A8                <1> 	jne	.error
   562 0000112C B90040              <1> 	mov	cx,16384		; sector size is 16 KiB
   563 0000112F EB21                <1> 	jmp	short .write_erase_byte
   564                              <1> 
   565                              <1> ; write Flash that auto erases itself and programmed sector by sector
   566                              <1> 
   567                              <1> .write_auto_sector:
   568 00001131 BB0080              <1> 	mov	bx,config_space
   569 00001134 C604AA              <1> 	mov	byte [si],0AAh
   570 00001137 C60555              <1> 	mov	byte [di],55h
   571 0000113A C604A0              <1> 	mov	byte [si],0A0h		; enter write mode
   572                              <1> 
   573                              <1> .write_auto_sector1:
   574 0000113D 268A07              <1>     es	mov	al,byte [bx]		; read byte to write
   575 00001140 8807                <1> 	mov	byte [bx],al		; write it to flash
   576 00001142 43                  <1> 	inc	bx
   577 00001143 E2F8                <1> 	loop	.write_auto_sector1	; write next byte
   578                              <1> 
   579 00001145 31C9                <1> 	xor	cx,cx
   580 00001147 4B                  <1> 	dec	bx
   581                              <1> 
   582                              <1> .write_auto_sector2:
   583 00001148 3A07                <1> 	cmp	al,byte [bx]		; wait for write operation to complete
   584 0000114A E0FC                <1> 	loopne	.write_auto_sector2
   585 0000114C 09C9                <1> 	or	cx,cx			; CX ?= 0
   586 0000114E 7484                <1> 	jz	.error			; write timed out
   587 00001150 EB4A                <1> 	jmp	short .exit
   588                              <1> 
   589                              <1> ; write Flash that requires block erase prior to write, and writen byte by byte
   590                              <1> 	
   591                              <1> .write_erase_byte:
   592 00001152 BB0080              <1> 	mov	bx,config_space
   593 00001155 C604AA              <1> 	mov	byte [si],0AAh
   594 00001158 C60555              <1> 	mov	byte [di],55h
   595 0000115B C60480              <1> 	mov	byte [si],80h		; erase command
   596 0000115E C604AA              <1> 	mov	byte [si],0AAh
   597 00001161 C60555              <1> 	mov	byte [di],055h
   598 00001164 C60730              <1> 	mov	byte [bx],30h		; erase sector command
   599 00001167 89CA                <1> 	mov	dx,cx			; save sector size to DX
   600 00001169 31C9                <1> 	xor	cx,cx
   601                              <1> 
   602                              <1> .write_erase_byte1:
   603 0000116B B020                <1> 	mov	al,20h			; additional delay
   604                              <1> 					; Am29F010 is slow to erase...
   605                              <1> .write_erase_byte2:
   606 0000116D FEC8                <1> 	dec	al
   607 0000116F 75FC                <1> 	jnz	.write_erase_byte2
   608 00001171 803FFF              <1> 	cmp	byte [bx],0FFh		; is it erased yet?
   609 00001174 E0F5                <1> 	loopne	.write_erase_byte1
   610 00001176 09C9                <1> 	or	cx,cx			; CX ?= 0
   611 00001178 7503E957FF          <1> 	jz	.error			; erase timed out
   612                              <1> 
   613                              <1> .write_erase_byte3:
   614 0000117D C604AA              <1> 	mov	byte [si],0AAh
   615 00001180 C60555              <1> 	mov	byte [di],55h
   616 00001183 C604A0              <1> 	mov	byte [si],0A0h		; enter write mode
   617                              <1> 
   618 00001186 268A07              <1>     es	mov	al,byte [bx]		; read byte to write
   619 00001189 8807                <1> 	mov	byte [bx],al		; write it to flash
   620 0000118B 31C9                <1> 	xor	cx,cx
   621                              <1> 
   622                              <1> .write_erase_byte4:
   623 0000118D 3A07                <1> 	cmp	al,byte [bx]		; wait for write operation to complete
   624 0000118F E0FC                <1> 	loopne	.write_erase_byte4
   625 00001191 09C9                <1> 	or	cx,cx			; CX ?= 0
   626 00001193 7503E93CFF          <1> 	jz	.error			; write timed out
   627                              <1> 
   628 00001198 43                  <1> 	inc	bx
   629 00001199 4A                  <1> 	dec	dx
   630 0000119A 75E1                <1> 	jnz	.write_erase_byte3
   631                              <1> 
   632                              <1> .exit:
   633 0000119C F8                  <1> 	clc
   634 0000119D B080                <1> 	mov	al,nmi_enable
   635 0000119F E6A0                <1> 	out	nmi_mask_reg,al		; enable NMIs
   636 000011A1 FB                  <1> 	sti
   637 000011A2 CB                  <1> 	retf
   638                              <1> 
   639                              <1> flash_write_size	equ	($-flash_write_code)
   640                              <1> %if flash_write_size > ((config_segment << 4) + config_space - (temp_segment << 4))
   641                              <1> %error "flash_write code is too big - try increasing changing config_segment"
   642                              <1> %endif
   268                                  %endif ; FLASH_NVRAM
   269                                  %ifdef BIOS_SETUP
   270                                  %include	"setup.inc"		; NVRAM setup functions
   271                              <1> ;=========================================================================
   272                              <1> ; setup.inc - NVRAM setup functions
   273                              <1> ; Works either with AT-style RTC/NVRAM or with Flash ROM
   274                              <1> ;-------------------------------------------------------------------------
   275                              <1> ;
   276                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   277                              <1> ;
   278                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
   279                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   280                              <1> ;
   281                              <1> ; This program is free software: you can redistribute it and/or modify
   282                              <1> ; it under the terms of the GNU General Public License as published by
   283                              <1> ; the Free Software Foundation, either version 3 of the License, or
   284                              <1> ; (at your option) any later version.
   285                              <1> ;
   286                              <1> ; This program is distributed in the hope that it will be useful,
   287                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   288                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   289                              <1> ; GNU General Public License for more details.
   290                              <1> ;
   291                              <1> ; You should have received a copy of the GNU General Public License
   292                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   293                              <1> ;
   294                              <1> ;=========================================================================
   295                              <1> 
   296 000011A3 40                  <1> default_floppy	db	type_1440 << 4	; one 1.44 MB floppy drive
   297 000011A4 21                  <1> default_equip	db	21h		; CGA 80x25, one floppy drive
   298                              <1> %ifdef BIOS_SETUP
   299 000011A5 00                  <1> default_config_a db	00000000b	; NVRAM BIOS configuration byte A
   300                              <1> ;			||||||`---------; 00 = 4.77 MHz / Turbo off
   301                              <1> ;			|||||`----------; 0 = F0000-F7FFF ROM scan enabled
   302                              <1> ;			||||`-----------; 0 = Memory test enabled
   303                              <1> ;                       |||`------------; 0 = Fast wait states for FE2010A
   304                              <1> ;			`---------------; reserved
   305                              <1> nvram_trbo_mask equ	03h		; turbo mask
   306                              <1> nvram_ext_scan	equ	04h		; F0000-F7FFF BIOS extension scan bit
   307                              <1> 					; (0 - enabled, 1 - disabled)
   308                              <1> nvram_mem_test	equ	08h		; Memory test bit
   309                              <1> 					; (0 - enabled, 1 - disabled)
   310                              <1> nvram_fast_ws	equ	10h		; Less wait states for FE2010A 
   311                              <1> 					; (0 - enabled, 1 - disabled)
   312                              <1> %endif ; BIOS_SETUP
   313                              <1> 
   314                              <1> ;=========================================================================
   315                              <1> ; nvram_setup - NVRAM configuration utility
   316                              <1> ; Input:
   317                              <1> ;	none
   318                              <1> ; Output:
   319                              <1> ;	none
   320                              <1> ;-------------------------------------------------------------------------
   321                              <1> nvram_setup:
   322 000011A6 50                  <1> 	push	ax
   323 000011A7 53                  <1> 	push	bx
   324 000011A8 51                  <1> 	push	cx
   325 000011A9 52                  <1> 	push	dx
   326 000011AA 56                  <1> 	push	si
   327                              <1> 
   328 000011AB E828FE              <1> 	call	get_config_a		; read BIOS configuration byte A
   329 000011AE 88C5                <1> 	mov	ch,al			; save it to CH
   330 000011B0 E833FE              <1> 	call	get_floppy		; read currently configured floppies
   331 000011B3 88C1                <1> 	mov	cl,al			; save it to CL
   332                              <1> 	
   333 000011B5 BE[9304]            <1> 	mov	si,msg_set_welcome
   334 000011B8 E8B516              <1> 	call	print
   335                              <1> 
   336                              <1> .menu_loop:
   337 000011BB BE[3606]            <1> 	mov	si,msg_set_prompt
   338 000011BE E8AF16              <1> 	call	print
   339                              <1> 
   340                              <1> .menu_input:
   341 000011C1 B400                <1> 	mov	ah,00h
   342 000011C3 CD16                <1> 	int	16h
   343 000011C5 0C20                <1> 	or	al,20h			; convert to lower case
   344 000011C7 B200                <1> 	mov	dl,0			; floppy 0
   345 000011C9 3C66                <1> 	cmp	al,'f'
   346 000011CB 7471                <1> 	je	.set_floppy
   347 000011CD FEC2                <1> 	inc	dl			; floppy 1
   348 000011CF 3C67                <1> 	cmp	al,'g'
   349 000011D1 746B                <1> 	je	.set_floppy
   350 000011D3 3C70                <1> 	cmp	al,'p'
   351 000011D5 7503E93F01          <1> 	je	.print_settings
   352                              <1> %ifdef TURBO_MODE
   353 000011DA 3C63                <1> 	cmp	al,'c'
   354 000011DC 7503E9C300          <1> 	je	.set_cpu_clk
   355                              <1> %endif ; TURBO_MODE
   356                              <1> %ifdef MACHINE_FE2010A
   357 000011E1 3C73                <1> 	cmp	al,'s'
   358 000011E3 7503E97B03          <1> 	je	.set_ws
   359                              <1> %endif ; MACHINE_FE2010A
   360                              <1> %ifdef AT_RTC
   361                              <1> 	%ifdef AT_RTC_AUTODETECT
   362 000011E8 E8CEFD              <1> 		call	rtc_detect
   363 000011EB 720E                <1> 		jc	.rtc_absent_2
   364                              <1> 	%endif ; AT_RTC_AUTODETECT
   365 000011ED 3C74                <1> 	cmp	al,'t'
   366 000011EF 7503E99C01          <1> 	je	.set_time
   367 000011F4 3C64                <1> 	cmp	al,'d'
   368 000011F6 7503E91002          <1> 	je	.set_date
   369                              <1> 	
   370                              <1> .rtc_absent_2:
   371                              <1> %endif ; AT_RTC
   372 000011FB 3C65                <1> 	cmp	al,'e'
   373 000011FD 7503E9D102          <1> 	je	.set_ext_scan
   374 00001202 3C6D                <1> 	cmp	al,'m'
   375 00001204 7503E91203          <1> 	je	.set_mem_test
   376 00001209 3C77                <1> 	cmp	al,'w'
   377 0000120B 7503E9AE03          <1> 	je	.save
   378 00001210 3C71                <1> 	cmp	al,'q'
   379 00001212 7503E9B603          <1> 	je	.no_save
   380 00001217 3C68                <1> 	cmp	al,'h'
   381 00001219 7402                <1> 	je	.help
   382 0000121B EBA4                <1> 	jmp	.menu_input
   383                              <1> 
   384                              <1> .help:
   385 0000121D B40E                <1> 	mov	ah,0Eh			; echo
   386 0000121F BB0700              <1> 	mov	bx,0007h
   387 00001222 CD10                <1> 	int	10h
   388 00001224 BE[B704]            <1> 	mov	si,msg_set_help
   389 00001227 E84616              <1> 	call	print
   390                              <1> 
   391                              <1> %ifdef AT_RTC
   392                              <1> 	
   393                              <1> %ifdef AT_RTC_AUTODETECT
   394 0000122A E88CFD              <1> 	call	rtc_detect
   395 0000122D 7206                <1> 	jc	.rtc_absent
   396                              <1> %endif ; AT_RTC_AUTODETECT
   397                              <1> 
   398 0000122F BE[AC05]            <1> 	mov	si,msg_set_rtc_help
   399 00001232 E83B16              <1> 	call	print
   400                              <1> 
   401                              <1> .rtc_absent:
   402                              <1> %endif ; AT_RTC
   403                              <1> 
   404 00001235 BE[C905]            <1> 	mov	si,msg_set_def_help
   405 00001238 E83516              <1> 	call	print
   406 0000123B E97DFF              <1> 	jmp	.menu_loop
   407                              <1> 
   408                              <1> .set_floppy:
   409 0000123E B40E                <1> 	mov	ah,0Eh			; echo
   410 00001240 BB0700              <1> 	mov	bx,0007h
   411 00001243 CD10                <1> 	int	10h
   412                              <1> 
   413                              <1> .set_floppy_prompt:
   414 00001245 BE[FA07]            <1> 	mov	si,msg_set_fd_prmt
   415 00001248 E82516              <1> 	call	print
   416                              <1> 
   417                              <1> .floppy_input:
   418 0000124B B400                <1> 	mov	ah,00h
   419 0000124D CD16                <1> 	int	16h
   420 0000124F 0C20                <1> 	or	al,20h			; convert to lower case
   421 00001251 3C72                <1> 	cmp	al,'r'
   422 00001253 7430                <1> 	je	.floppy_exit
   423 00001255 3C68                <1> 	cmp	al,'h'
   424 00001257 7436                <1> 	je	.floppy_help
   425 00001259 3C30                <1> 	cmp	al,'0'
   426 0000125B 72EE                <1> 	jb	.floppy_input
   427 0000125D 3C36                <1> 	cmp	al,'6'
   428 0000125F 77EA                <1> 	ja	.floppy_input
   429 00001261 3C35                <1> 	cmp	al,'5'
   430 00001263 74E6                <1> 	je	.floppy_input
   431 00001265 B40E                <1> 	mov	ah,0Eh			; echo
   432 00001267 BB0700              <1> 	mov	bx,0007h
   433 0000126A CD10                <1> 	int	10h
   434 0000126C 2C30                <1> 	sub	al,'0'
   435 0000126E B6F0                <1> 	mov	dh,0F0h
   436 00001270 08D2                <1> 	or	dl,dl			; drive	0?
   437 00001272 750A                <1> 	jnz	.drive_1
   438 00001274 D0E0                <1> 	shl	al,1
   439 00001276 D0E0                <1> 	shl	al,1
   440 00001278 D0E0                <1> 	shl	al,1
   441 0000127A D0E0                <1> 	shl	al,1
   442 0000127C B60F                <1> 	mov	dh,0Fh
   443                              <1> .drive_1:
   444 0000127E 20F1                <1> 	and	cl,dh
   445 00001280 08C1                <1> 	or	cl,al
   446 00001282 E936FF              <1> 	jmp	.menu_loop
   447                              <1> 
   448                              <1> .floppy_exit:
   449 00001285 B40E                <1> 	mov	ah,0Eh			; echo
   450 00001287 BB0700              <1> 	mov	bx,0007h
   451 0000128A CD10                <1> 	int	10h
   452 0000128C E92CFF              <1> 	jmp	.menu_loop
   453                              <1> 
   454                              <1> .floppy_help:
   455 0000128F B40E                <1> 	mov	ah,0Eh			; echo
   456 00001291 BB0700              <1> 	mov	bx,0007h
   457 00001294 CD10                <1> 	int	10h
   458 00001296 BE[2B07]            <1> 	mov	si,msg_set_fd_help
   459 00001299 E8D415              <1> 	call	print
   460 0000129C BE[B707]            <1> 	mov	si,msg_set_sub_help
   461 0000129F E8CE15              <1> 	call	print
   462 000012A2 EBA1                <1> 	jmp	.set_floppy_prompt
   463                              <1> 
   464                              <1> %ifdef TURBO_MODE
   465                              <1> .set_cpu_clk:
   466 000012A4 B40E                <1> 	mov	ah,0Eh			; echo
   467 000012A6 BB0700              <1> 	mov	bx,0007h
   468 000012A9 CD10                <1> 	int	10h
   469                              <1> 
   470                              <1> .set_cpu_clk_prompt:
   471 000012AB BE[A006]            <1> 	mov	si,msg_set_clk_prmt
   472 000012AE E8BF15              <1> 	call	print
   473                              <1> 
   474                              <1> .cpu_clk_input:
   475 000012B1 B400                <1> 	mov	ah,00h
   476 000012B3 CD16                <1> 	int	16h
   477 000012B5 0C20                <1> 	or	al,20h			; convert to lower case
   478 000012B7 3C72                <1> 	cmp	al,'r'
   479 000012B9 743F                <1> 	je	.cpu_clk_exit
   480 000012BB 3C68                <1> 	cmp	al,'h'
   481 000012BD 7445                <1> 	je	.cpu_clk_help
   482 000012BF 3C34                <1> 	cmp	al,'4'
   483 000012C1 740A                <1> 	je	.cpu_clk_4_77mhz
   484                              <1> %ifdef MACHINE_FE2010A
   485 000012C3 3C37                <1> 	cmp	al,'7'
   486 000012C5 7413                <1> 	je	.cpu_clk_7_16mhz
   487 000012C7 3C39                <1> 	cmp	al,'9'
   488 000012C9 741F                <1> 	je	.cpu_clk_9_55mhz
   489                              <1> %else ; MACHINE_FE2010A
   490                              <1> 	cmp	al,'t'
   491                              <1> 	je	.cpu_clk_turbo
   492                              <1> %endif ; MACHINE_FE2010A
   493 000012CB EBE4                <1> 	jmp	.cpu_clk_input
   494                              <1> 
   495                              <1> .cpu_clk_4_77mhz:
   496 000012CD B40E                <1> 	mov	ah,0Eh			; echo
   497 000012CF BB0700              <1> 	mov	bx,0007h
   498 000012D2 CD10                <1> 	int	10h
   499 000012D4 80E5FC              <1> 	and	ch,~nvram_trbo_mask	; CH[1:0] = 0 -> 4.77 MHz
   500 000012D7 E9E1FE              <1> 	jmp	.menu_loop
   501                              <1> 
   502                              <1> %ifdef MACHINE_FE2010A
   503                              <1> .cpu_clk_7_16mhz:
   504 000012DA B40E                <1> 	mov	ah,0Eh			; echo
   505 000012DC BB0700              <1> 	mov	bx,0007h
   506 000012DF CD10                <1> 	int	10h
   507 000012E1 80E5FC              <1> 	and	ch,~nvram_trbo_mask	; clear turbo bits
   508 000012E4 80CD01              <1> 	or	ch,1			; CH[1:0] = 1 -> 7.16 MHz
   509 000012E7 E9D1FE              <1> 	jmp	.menu_loop
   510                              <1> 
   511                              <1> .cpu_clk_9_55mhz:
   512 000012EA B40E                <1> 	mov	ah,0Eh			; echo
   513 000012EC BB0700              <1> 	mov	bx,0007h
   514 000012EF CD10                <1> 	int	10h
   515 000012F1 80E5FC              <1> 	and	ch,~nvram_trbo_mask	; clear turbo bits
   516 000012F4 80CD02              <1> 	or	ch,2			; CH[1:0] = 2 -> 9.55 MHz
   517 000012F7 E9C1FE              <1> 	jmp	.menu_loop
   518                              <1> %else ; MACHINE_FE2010A
   519                              <1> .cpu_clk_turbo:
   520                              <1> 	mov	ah,0Eh			; echo
   521                              <1> 	mov	bx,0007h
   522                              <1> 	int	10h
   523                              <1> 	and	ch,~nvram_trbo_mask	; clear turbo bits
   524                              <1> 	or	ch,1			; CH[1:0] = 1 -> Turbo
   525                              <1> 	jmp	.menu_loop
   526                              <1> %endif ; MACHINE_FE2010A
   527                              <1> 
   528                              <1> .cpu_clk_exit:
   529 000012FA B40E                <1> 	mov	ah,0Eh			; echo
   530 000012FC BB0700              <1> 	mov	bx,0007h
   531 000012FF CD10                <1> 	int	10h
   532 00001301 E9B7FE              <1> 	jmp	.menu_loop
   533                              <1> 
   534                              <1> .cpu_clk_help:
   535 00001304 B40E                <1> 	mov	ah,0Eh			; echo
   536 00001306 BB0700              <1> 	mov	bx,0007h
   537 00001309 CD10                <1> 	int	10h
   538 0000130B BE[5506]            <1> 	mov	si,msg_set_clk_help
   539 0000130E E85F15              <1> 	call	print
   540 00001311 BE[B707]            <1> 	mov	si,msg_set_sub_help
   541 00001314 E85915              <1> 	call	print
   542 00001317 EB92                <1> 	jmp	.set_cpu_clk_prompt
   543                              <1> %endif ; TURBO_MODE
   544                              <1> 
   545                              <1> .print_settings:
   546 00001319 B40E                <1> 	mov	ah,0Eh			; echo
   547 0000131B BB0700              <1> 	mov	bx,0007h
   548 0000131E CD10                <1> 	int	10h
   549 00001320 BE[8B00]            <1> 	mov	si,msg_crlf
   550 00001323 E84A15              <1> 	call	print
   551                              <1> 
   552                              <1> %ifdef TURBO_MODE
   553 00001326 BE[9900]            <1> 	mov	si,msg_cpu_clk
   554 00001329 E84415              <1> 	call	print
   555 0000132C 88E8                <1> 	mov	al,ch
   556 0000132E E8A714              <1> 	call	print_cpu_clk
   557 00001331 BE[8B00]            <1> 	mov	si,msg_crlf
   558 00001334 E83915              <1> 	call	print
   559                              <1> %endif ; TURBO_MODE
   560                              <1> 
   561                              <1> %ifdef MACHINE_FE2010A
   562 00001337 BE[D709]            <1> 	mov	si,msg_ws
   563 0000133A E83315              <1> 	call	print
   564 0000133D BE[F409]            <1> 	mov	si,msg_enabled		; assume fast wait states
   565 00001340 F6C510              <1> 	test	ch,nvram_fast_ws
   566 00001343 7403                <1> 	jz	.print_ws
   567 00001345 BE[FC09]            <1> 	mov	si,msg_disabled
   568                              <1> 
   569                              <1> .print_ws:
   570 00001348 E82515              <1> 	call	print
   571 0000134B BE[8B00]            <1> 	mov	si,msg_crlf
   572 0000134E E81F15              <1> 	call	print
   573                              <1> %endif ; MACHINE_FE2010A
   574                              <1> 
   575                              <1> %ifdef AT_RTC
   576 00001351 E8F3FB              <1> 	call	print_rtc		; print current RTC time
   577                              <1> %endif ; AT_RTC
   578 00001354 88C8                <1> 	mov	al,cl			; floppy bytes to AL
   579 00001356 E89E0C              <1> 	call	print_floppy
   580 00001359 BE[5908]            <1> 	mov	si,msg_ext_scan
   581 0000135C E81115              <1> 	call	print
   582 0000135F BE[F409]            <1> 	mov	si,msg_enabled		; assume F0000-F7FFF ROM scan enabled
   583 00001362 F6C504              <1> 	test	ch,nvram_ext_scan
   584 00001365 7403                <1> 	jz	.print_ext_scan
   585 00001367 BE[FC09]            <1> 	mov	si,msg_disabled		; F0000-F7FFF ROM scan disabled
   586                              <1> 
   587                              <1> .print_ext_scan:
   588 0000136A E80315              <1> 	call	print
   589 0000136D BE[8B00]            <1> 	mov	si,msg_crlf
   590 00001370 E8FD14              <1> 	call	print
   591 00001373 BE[9108]            <1> 	mov	si,msg_mem_test
   592 00001376 E8F714              <1> 	call	print
   593 00001379 BE[F409]            <1> 	mov	si,msg_enabled		; assume memory test enabled
   594 0000137C F6C508              <1> 	test	ch,nvram_mem_test
   595 0000137F 7403                <1> 	jz	.print_mem_test
   596 00001381 BE[FC09]            <1> 	mov	si,msg_disabled
   597                              <1> 
   598                              <1> .print_mem_test:
   599 00001384 E8E914              <1> 	call	print
   600 00001387 BE[8B00]            <1> 	mov	si,msg_crlf
   601 0000138A E8E314              <1> 	call	print
   602 0000138D E92BFE              <1> 	jmp	.menu_loop
   603                              <1> 
   604                              <1> %ifdef AT_RTC
   605                              <1> .set_time:
   606 00001390 51                  <1> 	push	cx
   607 00001391 57                  <1> 	push	di
   608 00001392 06                  <1> 	push	es
   609 00001393 B40E                <1> 	mov	ah,0Eh			; echo
   610 00001395 BB0700              <1> 	mov	bx,0007h
   611 00001398 CD10                <1> 	int	10h
   612 0000139A BE[8B00]            <1> 	mov	si,msg_crlf
   613 0000139D E8D014              <1> 	call	print
   614                              <1> 
   615 000013A0 BE[CB06]            <1> 	mov	si,msg_set_time
   616 000013A3 E8CA14              <1> 	call	print
   617                              <1> 
   618 000013A6 B402                <1> 	mov	ah,02h
   619 000013A8 CD1A                <1> 	int	1Ah			; get current time
   620                              <1> 
   621 000013AA B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
   622 000013AD 8EC0                <1> 	mov	es,ax
   623 000013AF 31FF                <1> 	xor	di,di
   624 000013B1 B80800              <1> 	mov	ax,8			; length of the time string
   625                              <1> 
   626 000013B4 E82902              <1> 	call	get_line
   627                              <1> 
   628 000013B7 09C0                <1> 	or	ax,ax			; empty string?
   629 000013B9 7442                <1> 	jz	.set_time_exit
   630                              <1> 
   631 000013BB E89402              <1> 	call	atoi
   632                              <1> 
   633 000013BE 83F817              <1> 	cmp	ax,23			; hours are greater than 23?
   634 000013C1 7740                <1> 	ja	.set_time_invalid
   635                              <1> 
   636 000013C3 E8B102              <1> 	call	bin_to_bcd		; convert to BCD
   637                              <1> 
   638 000013C6 88C5                <1> 	mov	ch,al			; CH = hours
   639                              <1> 
   640 000013C8 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
   641 000013CC 7535                <1> 	jne	.set_time_invalid
   642                              <1> 
   643 000013CE 47                  <1> 	inc	di
   644                              <1> 
   645 000013CF E88002              <1> 	call	atoi
   646                              <1> 
   647 000013D2 83F83B              <1> 	cmp	ax,59			; minutes are greater than 59?
   648 000013D5 772C                <1> 	ja	.set_time_invalid
   649                              <1> 
   650 000013D7 E89D02              <1> 	call	bin_to_bcd
   651                              <1> 
   652 000013DA 88C1                <1> 	mov	cl,al			; CL = minutes
   653                              <1> 
   654 000013DC 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
   655 000013E0 7521                <1> 	jne	.set_time_invalid
   656                              <1> 
   657 000013E2 47                  <1> 	inc	di
   658                              <1> 
   659 000013E3 E86C02              <1> 	call	atoi
   660                              <1> 
   661 000013E6 83F83B              <1> 	cmp	ax,59			; seconds are greater than 59?
   662 000013E9 7718                <1> 	ja	.set_time_invalid
   663                              <1> 
   664 000013EB E88902              <1> 	call	bin_to_bcd
   665                              <1> 
   666 000013EE 88C6                <1> 	mov	dh,al			; DH = seconds
   667                              <1> 
   668 000013F0 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
   669 000013F4 750D                <1> 	jne	.set_time_invalid
   670                              <1> 
   671 000013F6 B403                <1> 	mov	ah,03h			; set RTC time
   672 000013F8 CD1A                <1> 	int	1Ah
   673 000013FA E86FFA              <1> 	call	set_system_timer		; set timer variables to RTC time
   674                              <1> 
   675                              <1> .set_time_exit:
   676 000013FD 07                  <1> 	pop	es
   677 000013FE 5F                  <1> 	pop	di
   678 000013FF 59                  <1> 	pop	cx
   679 00001400 E9B8FD              <1> 	jmp	.menu_loop
   680                              <1> 
   681                              <1> .set_time_invalid:
   682 00001403 BE[FD06]            <1> 	mov	si,msg_time_inval
   683 00001406 E86714              <1> 	call	print
   684 00001409 EBF2                <1> 	jmp	.set_time_exit
   685                              <1> 
   686                              <1> .set_date:
   687 0000140B 51                  <1> 	push	cx
   688 0000140C 57                  <1> 	push	di
   689 0000140D 06                  <1> 	push	es
   690 0000140E B40E                <1> 	mov	ah,0Eh			; echo
   691 00001410 BB0700              <1> 	mov	bx,0007h
   692 00001413 CD10                <1> 	int	10h
   693 00001415 BE[8B00]            <1> 	mov	si,msg_crlf
   694 00001418 E85514              <1> 	call	print
   695 0000141B BE[E306]            <1> 	mov	si,msg_set_date
   696 0000141E E84F14              <1> 	call	print
   697                              <1> 
   698 00001421 B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
   699 00001424 8EC0                <1> 	mov	es,ax
   700 00001426 31FF                <1> 	xor	di,di
   701 00001428 B80A00              <1> 	mov	ax,10			; length of the date string
   702                              <1> 
   703 0000142B E8B201              <1> 	call	get_line
   704                              <1> 
   705 0000142E 09C0                <1> 	or	ax,ax			; empty string?
   706 00001430 7503E99000          <1> 	jz	.set_date_exit
   707                              <1> 
   708 00001435 E81A02              <1> 	call	atoi
   709                              <1> 
   710 00001438 3D0F27              <1> 	cmp	ax,9999			; year is greater than 9999?
   711 0000143B 7603E98B00          <1> 	ja	.set_date_invalid
   712                              <1> 
   713 00001440 89C3                <1> 	mov	bx,ax			; store binary year in BX
   714                              <1> 
   715 00001442 E83202              <1> 	call	bin_to_bcd		; convert to BCD
   716                              <1> 
   717 00001445 89C1                <1> 	mov	cx,ax			; CH = century, CL = year
   718                              <1> 	
   719 00001447 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
   720 0000144B 757E                <1> 	jne	.set_date_invalid
   721                              <1> 
   722 0000144D 47                  <1> 	inc	di
   723                              <1> 
   724 0000144E E80102              <1> 	call	atoi
   725                              <1> 
   726 00001451 83F801              <1> 	cmp	ax,1			; month is lower than 1?
   727 00001454 7275                <1> 	jb	.set_date_invalid
   728                              <1> 
   729 00001456 83F80C              <1> 	cmp	ax,12			; month is greater than 12?
   730 00001459 7770                <1> 	ja	.set_date_invalid
   731                              <1> 
   732 0000145B E81902              <1> 	call	bin_to_bcd
   733                              <1> 
   734 0000145E 88C6                <1> 	mov	dh,al			; DH = month
   735                              <1> 
   736 00001460 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
   737 00001464 7565                <1> 	jne	.set_date_invalid
   738                              <1> 
   739 00001466 47                  <1> 	inc	di
   740                              <1> 
   741 00001467 E8E801              <1> 	call	atoi
   742                              <1> 
   743 0000146A 83F801              <1> 	cmp	ax,1			; day is lower than 1?
   744 0000146D 725C                <1> 	jb	.set_date_invalid
   745                              <1> 
   746 0000146F 80FE02              <1> 	cmp	dh,02h			; February
   747 00001472 7430                <1> 	je	.set_date_february
   748                              <1> 
   749 00001474 80FE04              <1> 	cmp	dh,04h			; April
   750 00001477 7416                <1> 	je	.set_date_30_days
   751                              <1> 
   752 00001479 80FE06              <1> 	cmp	dh,06h			; July
   753 0000147C 7411                <1> 	je	.set_date_30_days
   754                              <1> 
   755 0000147E 80FE09              <1> 	cmp	dh,09h			; September
   756 00001481 740C                <1> 	je	.set_date_30_days
   757                              <1> 
   758 00001483 80FE11              <1> 	cmp	dh,11h			; November
   759 00001486 7407                <1> 	je	.set_date_30_days
   760                              <1> 
   761                              <1> .set_date_31_days:
   762 00001488 83F81F              <1> 	cmp	ax,31			; day of month is greater than 31?
   763 0000148B 773E                <1> 	ja	.set_date_invalid
   764 0000148D EB27                <1> 	jmp	.set_date_set_day
   765                              <1> 
   766                              <1> .set_date_30_days:
   767 0000148F 83F81E              <1> 	cmp	ax,30			; day of month is greater than 30?
   768 00001492 7737                <1> 	ja	.set_date_invalid
   769 00001494 EB20                <1> 	jmp	.set_date_set_day
   770                              <1> 
   771                              <1> .set_date_29_days:
   772 00001496 83F81D              <1> 	cmp	ax,29			; day of month is greater than 28?
   773 00001499 7730                <1> 	ja	.set_date_invalid
   774 0000149B EB19                <1> 	jmp	.set_date_set_day
   775                              <1> 
   776                              <1> .set_date_28_days:
   777 0000149D 83F81C              <1> 	cmp	ax,28			; day of month is greater than 28?
   778 000014A0 7729                <1> 	ja	.set_date_invalid
   779 000014A2 EB12                <1> 	jmp	.set_date_set_day
   780                              <1> 
   781                              <1> .set_date_february:
   782 000014A4 F7C30300            <1> 	test	bx,0003h		; check if years divides by 4
   783 000014A8 75F3                <1> 	jnz	.set_date_28_days	; not a leap year
   784                              <1> 
   785 000014AA 80F900              <1> 	cmp	cl,00h			; year doesn't end with 00
   786 000014AD 75E7                <1> 	jne	.set_date_29_days	; a leap year
   787                              <1> 
   788 000014AF F6C503              <1> 	test	ch,03h			; check if century divides by 4
   789 000014B2 74E2                <1> 	jz	.set_date_29_days	; year divides by 400
   790 000014B4 EBE7                <1> 	jmp	.set_date_28_days	; year divides by 100 but not by 400
   791                              <1> 
   792                              <1> .set_date_set_day:
   793 000014B6 E8BE01              <1> 	call	bin_to_bcd
   794                              <1> 
   795 000014B9 88C2                <1> 	mov	dl,al			; DL = date (day of month)
   796                              <1> 
   797 000014BB 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
   798 000014BF 750A                <1> 	jne	.set_date_invalid
   799                              <1> 
   800 000014C1 B405                <1> 	mov	ah,05h			; set RTC date
   801 000014C3 CD1A                <1> 	int	1Ah
   802                              <1> 
   803                              <1> .set_date_exit:
   804 000014C5 07                  <1> 	pop	es
   805 000014C6 5F                  <1> 	pop	di
   806 000014C7 59                  <1> 	pop	cx
   807 000014C8 E9F0FC              <1> 	jmp	.menu_loop
   808                              <1> 
   809                              <1> .set_date_invalid:
   810 000014CB BE[1407]            <1> 	mov	si,msg_date_inval
   811 000014CE E89F13              <1> 	call	print
   812 000014D1 EBF2                <1> 	jmp	.set_date_exit
   813                              <1> 
   814                              <1> %endif ; AT_RTC
   815                              <1> 
   816                              <1> .set_ext_scan:
   817 000014D3 B40E                <1> 	mov	ah,0Eh			; echo
   818 000014D5 BB0700              <1> 	mov	bx,0007h
   819 000014D8 CD10                <1> 	int	10h
   820 000014DA BE[8B00]            <1> 	mov	si,msg_crlf
   821 000014DD E89013              <1> 	call	print
   822 000014E0 BE[2308]            <1> 	mov	si,msg_set_ext
   823 000014E3 E88A13              <1> 	call	print
   824                              <1> 
   825                              <1> .set_ext_input:
   826 000014E6 B400                <1> 	mov	ah,00h
   827 000014E8 CD16                <1> 	int	16h
   828 000014EA 3C0D                <1> 	cmp	al,0Dh
   829 000014EC 7424                <1> 	je	.set_ext_exit
   830 000014EE 0C20                <1> 	or	al,20h			; convert to lower case
   831 000014F0 3C6E                <1> 	cmp	al,'n'
   832 000014F2 7406                <1> 	je	.set_ext_disable
   833 000014F4 3C79                <1> 	cmp	al,'y'
   834 000014F6 740E                <1> 	je	.set_ext_enable
   835 000014F8 EBEC                <1> 	jmp	.set_ext_input
   836                              <1> 
   837                              <1> .set_ext_disable:
   838 000014FA B40E                <1> 	mov	ah,0Eh			; echo
   839 000014FC BB0700              <1> 	mov	bx,0007h
   840 000014FF CD10                <1> 	int	10h
   841 00001501 80CD04              <1> 	or	ch,nvram_ext_scan	; bit set = disable scan
   842 00001504 EB0C                <1> 	jmp	.set_ext_exit
   843                              <1> 
   844                              <1> .set_ext_enable:
   845 00001506 B40E                <1> 	mov	ah,0Eh			; echo
   846 00001508 BB0700              <1> 	mov	bx,0007h
   847 0000150B CD10                <1> 	int	10h
   848 0000150D 80E5FB              <1> 	and	ch,~nvram_ext_scan	; bit clear = enable scan
   849 00001510 EB00                <1> 	jmp	.set_ext_exit
   850                              <1> 
   851                              <1> .set_ext_exit:
   852 00001512 BE[8B00]            <1> 	mov	si,msg_crlf
   853 00001515 E85813              <1> 	call	print
   854 00001518 E9A0FC              <1> 	jmp	.menu_loop
   855                              <1> 
   856                              <1> .set_mem_test:
   857 0000151B B40E                <1> 	mov	ah,0Eh			; echo
   858 0000151D BB0700              <1> 	mov	bx,0007h
   859 00001520 CD10                <1> 	int	10h
   860 00001522 BE[8B00]            <1> 	mov	si,msg_crlf
   861 00001525 E84813              <1> 	call	print
   862 00001528 BE[7608]            <1> 	mov	si,msg_set_mem_tst
   863 0000152B E84213              <1> 	call	print
   864                              <1> 
   865                              <1> .set_mem_test_input:
   866 0000152E B400                <1> 	mov	ah,00h
   867 00001530 CD16                <1> 	int	16h
   868 00001532 3C0D                <1> 	cmp	al,0Dh
   869 00001534 7424                <1> 	je	.set_mem_test_exit
   870 00001536 0C20                <1> 	or	al,20h			; convert to lower case
   871 00001538 3C6E                <1> 	cmp	al,'n'
   872 0000153A 7406                <1> 	je	.set_mem_test_disable
   873 0000153C 3C79                <1> 	cmp	al,'y'
   874 0000153E 740E                <1> 	je	.set_mem_test_enable
   875 00001540 EBEC                <1> 	jmp	.set_mem_test_input
   876                              <1> 
   877                              <1> .set_mem_test_disable:
   878 00001542 B40E                <1> 	mov	ah,0Eh			; echo
   879 00001544 BB0700              <1> 	mov	bx,0007h
   880 00001547 CD10                <1> 	int	10h
   881 00001549 80CD08              <1> 	or	ch,nvram_mem_test	; bit set = disable test
   882 0000154C EB0C                <1> 	jmp	.set_mem_test_exit
   883                              <1> 
   884                              <1> .set_mem_test_enable:
   885 0000154E B40E                <1> 	mov	ah,0Eh			; echo
   886 00001550 BB0700              <1> 	mov	bx,0007h
   887 00001553 CD10                <1> 	int	10h
   888 00001555 80E5F7              <1> 	and	ch,~nvram_mem_test	; bit clear = enable test
   889 00001558 EB00                <1> 	jmp	.set_mem_test_exit
   890                              <1> 
   891                              <1> .set_mem_test_exit:
   892 0000155A BE[8B00]            <1> 	mov	si,msg_crlf
   893 0000155D E81013              <1> 	call	print
   894 00001560 E958FC              <1> 	jmp	.menu_loop
   895                              <1> 
   896                              <1> %ifdef MACHINE_FE2010A
   897                              <1> .set_ws:
   898 00001563 B40E                <1> 	mov	ah,0Eh			; echo
   899 00001565 BB0700              <1> 	mov	bx,0007h
   900 00001568 CD10                <1> 	int	10h
   901 0000156A BE[8B00]            <1> 	mov	si,msg_crlf
   902 0000156D E80013              <1> 	call	print
   903                              <1> .set_ws_loop:
   904 00001570 BE[AE08]            <1> 	mov	si,msg_set_ws
   905 00001573 E8FA12              <1> 	call	print
   906                              <1> 
   907                              <1> .set_ws_input:
   908 00001576 B400                <1> 	mov	ah,00h
   909 00001578 CD16                <1> 	int	16h
   910 0000157A 3C0D                <1> 	cmp	al,0Dh
   911 0000157C 7437                <1> 	je	.set_ws_exit
   912 0000157E 0C20                <1> 	or	al,20h			; convert to lower case
   913 00001580 3C6E                <1> 	cmp	al,'n'
   914 00001582 740A                <1> 	je	.set_ws_disable
   915 00001584 3C79                <1> 	cmp	al,'y'
   916 00001586 7412                <1> 	je	.set_ws_enable
   917 00001588 3C68                <1> 	cmp	al,'h'
   918 0000158A 741A                <1> 	je	.set_ws_help
   919 0000158C EBE8                <1> 	jmp	.set_ws_input
   920                              <1> 
   921                              <1> .set_ws_disable:
   922 0000158E B40E                <1> 	mov	ah,0Eh			; echo
   923 00001590 BB0700              <1> 	mov	bx,0007h
   924 00001593 CD10                <1> 	int	10h
   925 00001595 80CD10              <1> 	or	ch,nvram_fast_ws	; bit set = fast waitstates
   926 00001598 EB1B                <1> 	jmp	.set_ws_exit
   927                              <1> 
   928                              <1> .set_ws_enable:
   929 0000159A B40E                <1> 	mov	ah,0Eh			; echo
   930 0000159C BB0700              <1> 	mov	bx,0007h
   931 0000159F CD10                <1> 	int	10h
   932 000015A1 80E5EF              <1> 	and	ch,~nvram_fast_ws	; bit clear = normal waitstates
   933 000015A4 EB0F                <1> 	jmp	.set_ws_exit
   934                              <1> 
   935                              <1> .set_ws_help:
   936 000015A6 B40E                <1> 	mov	ah,0Eh			; echo
   937 000015A8 BB0700              <1> 	mov	bx,0007h
   938 000015AB CD10                <1> 	int	10h
   939 000015AD BE[D308]            <1> 	mov	si,msg_ws_help
   940 000015B0 E8BD12              <1> 	call	print
   941 000015B3 EBBB                <1> 	jmp	.set_ws_loop
   942                              <1> 
   943                              <1> .set_ws_exit:
   944 000015B5 BE[8B00]            <1> 	mov	si,msg_crlf
   945 000015B8 E8B512              <1> 	call	print
   946 000015BB E9FDFB              <1> 	jmp	.menu_loop
   947                              <1> %endif ; MACHINE_FE2010A
   948                              <1> 
   949                              <1> .save:
   950 000015BE B40E                <1> 	mov	ah,0Eh			; echo
   951 000015C0 BB0700              <1> 	mov	bx,0007h
   952 000015C3 CD10                <1> 	int	10h
   953                              <1> 
   954                              <1> %ifdef AT_RTC_NVRAM
   955                              <1> 	call	nvram_save
   956                              <1> %endif ; AT_RTC_NVRAM
   957                              <1> %ifdef FLASH_NVRAM
   958 000015C5 E84BFA              <1> 	call	flash_save
   959                              <1> %endif ; FLASH_NVRAM
   960 000015C8 E8F509              <1> 	call	detect_floppy		; set floppies in equipment_list
   961 000015CB EB07                <1> 	jmp	.exit
   962                              <1> 
   963                              <1> .no_save:
   964 000015CD B40E                <1> 	mov	ah,0Eh			; echo
   965 000015CF BB0700              <1> 	mov	bx,0007h
   966 000015D2 CD10                <1> 	int	10h
   967                              <1> 
   968                              <1> .exit:
   969 000015D4 BE[8B00]            <1> 	mov	si,msg_crlf
   970 000015D7 E89612              <1> 	call	print
   971 000015DA 5E                  <1> 	pop	si
   972 000015DB 5A                  <1> 	pop	dx
   973 000015DC 59                  <1> 	pop	cx
   974 000015DD 5B                  <1> 	pop	bx
   975 000015DE 58                  <1> 	pop	ax
   976 000015DF C3                  <1> 	ret
   977                              <1> 
   978                              <1> ;=========================================================================
   979                              <1> ; get_line - read an ASCIIZ string from the console
   980                              <1> ; Input:
   981                              <1> ;	ES:DI - pointer to the buffer
   982                              <1> ;	AX - max string length
   983                              <1> ; Output:
   984                              <1> ;	AX - string length
   985                              <1> ; Notes:
   986                              <1> ;	Buffer must have size of max string length + 1 to accomodate 00h
   987                              <1> ;-------------------------------------------------------------------------
   988                              <1> get_line:
   989 000015E0 53                  <1> 	push	bx
   990 000015E1 52                  <1> 	push	dx
   991 000015E2 56                  <1> 	push	si
   992 000015E3 57                  <1> 	push	di
   993                              <1> 
   994 000015E4 FC                  <1> 	cld
   995 000015E5 89FE                <1> 	mov	si,di
   996 000015E7 01C6                <1> 	add	si,ax			; SI = last character position
   997 000015E9 31D2                <1> 	xor	dx,dx			; DX = 0 - string length
   998                              <1> 
   999                              <1> .read_char_loop:
  1000 000015EB B400                <1> 	mov	ah,00h			; read character from keyboard
  1001 000015ED CD16                <1> 	int	16h
  1002                              <1> 
  1003 000015EF 3C08                <1> 	cmp	al,08h			; <Backspace> key
  1004 000015F1 741B                <1> 	jz	.backspace
  1005                              <1> 
  1006 000015F3 3C0D                <1> 	cmp	al,0Dh			; <Enter> key
  1007 000015F5 7441                <1> 	jz	.enter
  1008                              <1> 
  1009 000015F7 3C20                <1> 	cmp	al,20h			; below printable ASCII code?
  1010 000015F9 7233                <1> 	jb	.error_input
  1011                              <1> 
  1012 000015FB 3C7E                <1> 	cmp	al,7Eh			; above printable ASCII code?
  1013 000015FD 772F                <1> 	ja	.error_input
  1014                              <1> 
  1015 000015FF 39F7                <1> 	cmp	di,si			; end of buffer reached?
  1016 00001601 732B                <1> 	jae	.error_input
  1017                              <1> 
  1018 00001603 AA                  <1> 	stosb				; store character in the buffer
  1019 00001604 42                  <1> 	inc	dx			; increment strng length
  1020                              <1> 
  1021 00001605 B40E                <1> 	mov	ah,0Eh			; teletype output (echo)
  1022 00001607 BB0700              <1> 	mov	bx,0007h
  1023 0000160A CD10                <1> 	int	10h
  1024                              <1> 
  1025 0000160C EBDD                <1> 	jmp	.read_char_loop
  1026                              <1> 
  1027                              <1> .backspace:
  1028 0000160E 09D2                <1> 	or	dx,dx			; empty string?
  1029 00001610 741C                <1> 	jz	.error_input
  1030                              <1> 
  1031 00001612 4F                  <1> 	dec	di			; move pointer back
  1032 00001613 4A                  <1> 	dec	dx			; decrement string size
  1033                              <1> 
  1034 00001614 B8080E              <1> 	mov	ax,0E08h		; move the cursor back
  1035 00001617 BB0700              <1> 	mov	bx,0007h
  1036 0000161A CD10                <1> 	int	10h
  1037                              <1> 
  1038 0000161C B8200E              <1> 	mov	ax,0E20h		; erase the character under the cursor
  1039 0000161F BB0700              <1> 	mov	bx,0007h
  1040 00001622 CD10                <1> 	int	10h
  1041                              <1> 
  1042 00001624 B8080E              <1> 	mov	ax,0E08h		; move the cursor back again
  1043 00001627 BB0700              <1> 	mov	bx,0007h
  1044 0000162A CD10                <1> 	int	10h
  1045                              <1> 
  1046 0000162C EBBD                <1> 	jmp	.read_char_loop
  1047                              <1> 
  1048                              <1> .error_input:
  1049 0000162E B8070E              <1> 	mov	ax,0E07h		; beep
  1050 00001631 BB0700              <1> 	mov	bx,0007h
  1051 00001634 CD10                <1> 	int	10h
  1052                              <1> 
  1053 00001636 EBB3                <1> 	jmp	.read_char_loop
  1054                              <1> 
  1055                              <1> .enter:
  1056 00001638 B000                <1> 	mov	al,00h			; store 00h at the end of the string
  1057 0000163A AA                  <1> 	stosb
  1058                              <1> 
  1059 0000163B B80D0E              <1> 	mov	ax,0E0Dh		; CR
  1060 0000163E BB0700              <1> 	mov	bx,0007h
  1061 00001641 CD10                <1> 	int	10h
  1062                              <1> 
  1063 00001643 B80A0E              <1> 	mov	ax,0E0Ah		; LF
  1064 00001646 BB0700              <1> 	mov	bx,0007h
  1065 00001649 CD10                <1> 	int	10h
  1066                              <1> 
  1067 0000164B 89D0                <1> 	mov	ax,dx			; string length to AX
  1068                              <1> 
  1069 0000164D 5F                  <1> 	pop	di
  1070 0000164E 5E                  <1> 	pop	si
  1071 0000164F 5A                  <1> 	pop	dx
  1072 00001650 5B                  <1> 	pop	bx
  1073 00001651 C3                  <1> 	ret
  1074                              <1> 
  1075                              <1> ;=========================================================================
  1076                              <1> ; atoi - convert ASCIIZ string to an 16-bit integer number
  1077                              <1> ; Input:
  1078                              <1> ;	ES:DI - pointer to string
  1079                              <1> ; Output:
  1080                              <1> ;	AX - number
  1081                              <1> ; 	ES:DI - pointer moved to the position following the number
  1082                              <1> ;-------------------------------------------------------------------------
  1083                              <1> atoi:
  1084 00001652 53                  <1> 	push	bx
  1085 00001653 51                  <1> 	push	cx
  1086 00001654 52                  <1> 	push	dx
  1087                              <1> 
  1088 00001655 31C0                <1> 	xor	ax,ax			; zero the result
  1089 00001657 BB0A00              <1> 	mov	bx,10			; multiplier
  1090                              <1> 
  1091                              <1> .atoi_loop:
  1092 0000165A 268A0D              <1>     es	mov	cl,byte [di]
  1093                              <1> 
  1094 0000165D 80F930              <1> 	cmp	cl,'0'			; ASCII code below '0'
  1095 00001660 7211                <1> 	jb	.exit
  1096                              <1> 
  1097 00001662 80F939              <1> 	cmp	cl,'9'			; ASCII code above '9'
  1098 00001665 770C                <1> 	ja	.exit
  1099                              <1> 
  1100 00001667 47                  <1> 	inc	di			; move to the next character
  1101                              <1> 
  1102 00001668 80E930              <1> 	sub	cl,'0'			; convert to ASCII to binary
  1103                              <1> 
  1104 0000166B F7E3                <1> 	mul	bx			; DX:AX = AX * 10
  1105 0000166D B500                <1> 	mov	ch,0
  1106 0000166F 01C8                <1> 	add	ax,cx			; AX = AX + CX
  1107                              <1> 	
  1108 00001671 EBE7                <1> 	jmp	.atoi_loop
  1109                              <1> 
  1110                              <1> .exit:
  1111 00001673 5A                  <1> 	pop	dx
  1112 00001674 59                  <1> 	pop	cx
  1113 00001675 5B                  <1> 	pop	bx
  1114 00001676 C3                  <1> 	ret
  1115                              <1> 
  1116                              <1> ;=========================================================================
  1117                              <1> ; bin_to_bcd - convert binary number to a packed BCD
  1118                              <1> ; Input:
  1119                              <1> ;	AX - binary number
  1120                              <1> ; Output:
  1121                              <1> ;	AX - packed BCD number
  1122                              <1> ;-------------------------------------------------------------------------
  1123                              <1> bin_to_bcd:
  1124 00001677 53                  <1> 	push	bx
  1125 00001678 51                  <1> 	push	cx
  1126 00001679 52                  <1> 	push	dx
  1127 0000167A 56                  <1> 	push	si
  1128                              <1> 
  1129 0000167B B100                <1> 	mov	cl,0			; shift amount
  1130 0000167D 31F6                <1> 	xor	si,si			; zero result
  1131 0000167F BB0A00              <1> 	mov	bx,10			; BX - divisor
  1132                              <1> 
  1133                              <1> .bin_to_bcd_loop:
  1134 00001682 31D2                <1> 	xor	dx,dx			; DX - zero for 32-bit div operand
  1135 00001684 F7F3                <1> 	div	bx
  1136                              <1> 
  1137 00001686 D3E2                <1> 	shl	dx,cl			; shift digit to the required position
  1138 00001688 80C104              <1> 	add	cl,4			; calculate next position
  1139                              <1> 
  1140 0000168B 01D6                <1> 	add	si,dx			; add reminder to the result
  1141 0000168D 09C0                <1> 	or	ax,ax			; quotient is zero?
  1142 0000168F 75F1                <1> 	jnz	.bin_to_bcd_loop
  1143                              <1> 
  1144 00001691 89F0                <1> 	mov	ax,si			; result to AX
  1145                              <1> 
  1146 00001693 5E                  <1> 	pop	si
  1147 00001694 5A                  <1> 	pop	dx
  1148 00001695 59                  <1> 	pop	cx
  1149 00001696 5B                  <1> 	pop	bx
  1150 00001697 C3                  <1> 	ret
   271                                  %endif ; BIOS_SETUP
   272                                  %include	"delay.inc"		; delay function
   273                              <1> ;=========================================================================
   274                              <1> ; delay.inc - Delay functions
   275                              <1> ;-------------------------------------------------------------------------
   276                              <1> ;
   277                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   278                              <1> ;
   279                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
   280                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   281                              <1> ;
   282                              <1> ; This program is free software: you can redistribute it and/or modify
   283                              <1> ; it under the terms of the GNU General Public License as published by
   284                              <1> ; the Free Software Foundation, either version 3 of the License, or
   285                              <1> ; (at your option) any later version.
   286                              <1> ;
   287                              <1> ; This program is distributed in the hope that it will be useful,
   288                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   289                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   290                              <1> ; GNU General Public License for more details.
   291                              <1> ;
   292                              <1> ; You should have received a copy of the GNU General Public License
   293                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   294                              <1> ;
   295                              <1> ;=========================================================================
   296                              <1> 
   297                              <1> %ifdef AT_DELAY
   298                              <1> 
   299                              <1> ;=========================================================================
   300                              <1> ; delay_15us - delay for multiplies of 15 microseconds
   301                              <1> ; Input:
   302                              <1> ;	CX = time to delay (in 15 microsecond units)
   303                              <1> ; Notes:
   304                              <1> ;	1.  Actual delay will be between (CX - 1) * 15us and CX * 15us
   305                              <1> ;	2.  This relies on the "refresh" bit of port 61h and therefore on
   306                              <1> ;	    timer channel 1. Will not function properly if timer gets
   307                              <1> ;	    reprogrammed by an application or if it was not initialized yet
   308                              <1> ;-------------------------------------------------------------------------
   309                              <1> delay_15us:
   310                              <1> 	push	ax
   311                              <1> 	push	cx
   312                              <1> .zero:
   313                              <1> 	in	al,ppi_pb_reg
   314                              <1> 	test	al,refresh_flag
   315                              <1> 	jz	.zero
   316                              <1> 	dec	cx
   317                              <1> 	jz	.exit
   318                              <1> .one:
   319                              <1> 	in	al,ppi_pb_reg
   320                              <1> 	test	al,refresh_flag
   321                              <1> 	jnz	.one
   322                              <1> 	dec	cx
   323                              <1> 	jnz	.zero
   324                              <1> .exit:
   325                              <1> 	pop	cx
   326                              <1> 	pop	ax
   327                              <1> 	ret
   328                              <1> 
   329                              <1> %else ; AT_DELAY
   330                              <1> %ifdef PIT_DELAY
   331                              <1> 
   332                              <1> ;=========================================================================
   333                              <1> ; delay_15us - delay for multiplies of 15 microseconds using PIT
   334                              <1> ; Input:
   335                              <1> ;	CX = time to delay (in 15 microsecond units)
   336                              <1> ;
   337                              <1> ; - Calculate the total number of PIT ticks necessary
   338                              <1> ;	1,193,182 / 1000 ms / 1000 us / * 15 us * 2 = ~ 36 ticks/us
   339                              <1> ; - Latch the PIT and draw down the countdown total on each read.
   340                              <1> ; - Exit when countdown underflows.
   341                              <1> ;
   342                              <1> ; Note: Mode 3 (Square Wave) decrements the readable counter by 2, so the
   343                              <1> ; effective frequency of the counter is actually 2,386,360 Hz.
   344                              <1> ;
   345                              <1> ; Contributed by @640-KB (under GPL-3.0 license)
   346                              <1> ; Based on contribution by @Raffzahn (under CC BY-SA 4.0):
   347                              <1> ; https://retrocomputing.stackexchange.com/a/24874/21323
   348                              <1> ;-------------------------------------------------------------------------
   349                              <1> delay_15us:
   350 00001698 50                  <1> 	push	ax
   351 00001699 53                  <1> 	push	bx
   352 0000169A 51                  <1> 	push	cx
   353 0000169B 52                  <1> 	push	dx
   354 0000169C B82400              <1> 	mov	ax,2*15*pic_freq/1000/1000+1	; ~ 36 ticks/us	
   355 0000169F F7E1                <1> 	mul	cx		; dx:ax = countdown of pit ticks to wait
   356 000016A1 93                  <1> 	xchg	ax,bx		; dx:bx = countdown ticks
   357 000016A2 E81500              <1> 	call	io_wait_latch	; ax = start read
   358 000016A5 89C1                <1> 	mov	cx,ax		; cx = last read
   359                              <1> .tick_loop:
   360 000016A7 E81000              <1> 	call	io_wait_latch	; ax = current counter reading
   361 000016AA 29C1                <1> 	sub	cx,ax		; cx = # of ticks elapsed since last reading
   362 000016AC 29CB                <1> 	sub	bx,cx		; subtract change in ticks from countdown
   363 000016AE 89C1                <1> 	mov	cx,ax		; cx = save the last read
   364 000016B0 83DA00              <1> 	sbb	dx,0		; borrow out of high word (if necessary)
   365 000016B3 73F2                <1> 	jae	.tick_loop	; loop while countdown >= 0
   366 000016B5 5A                  <1> 	pop	dx
   367 000016B6 59                  <1> 	pop	cx
   368 000016B7 5B                  <1> 	pop	bx
   369 000016B8 58                  <1> 	pop	ax
   370 000016B9 C3                  <1> 	ret
   371                              <1> 
   372                              <1> ;=========================================================================
   373                              <1> ; Latch PIT 0 and read counter
   374                              <1> ; Output:
   375                              <1> ;	AX = current counter
   376                              <1> ;-------------------------------------------------------------------------
   377                              <1> io_wait_latch:
   378 000016BA B000                <1> 	mov	al,0		; counter 0, latch (00b)
   379 000016BC 9C                  <1> 	pushf			; save current IF
   380 000016BD FA                  <1> 	cli			; disable interrupts
   381 000016BE E643                <1> 	out	pit_ctl_reg,al	; write command to ctc
   382 000016C0 E440                <1> 	in	al,pit_ch0_reg	; read low byte of counter 0 latch
   383 000016C2 88C4                <1> 	mov	ah,al		; save it
   384 000016C4 E440                <1> 	in	al,pit_ch0_reg	; read high byte of counter 0 latch
   385 000016C6 9D                  <1> 	popf			; restore IF state
   386 000016C7 86C4                <1> 	xchg	al,ah		; convert endian
   387 000016C9 C3                  <1> 	ret
   388                              <1> 
   389                              <1> %else ; LOOP_DELAY
   390                              <1> 
   391                              <1> ;=========================================================================
   392                              <1> ; delay_15us - delay for multiplies of approximately 15 microseconds
   393                              <1> ; Input:
   394                              <1> ;	CX = time to delay (in 15 microsecond units)
   395                              <1> ; Notes:
   396                              <1> ;	This implementation does not provide precise timing
   397                              <1> ;	The actual delay depends on the CPU clock frequency
   398                              <1> ;-------------------------------------------------------------------------
   399                              <1> delay_15us:
   400                              <1> 	push	ax
   401                              <1> 	push	cx
   402                              <1> .1:
   403                              <1> 	mov	al,4
   404                              <1> .2:
   405                              <1> 	dec	al
   406                              <1> 	jnz	.2
   407                              <1> 	loop	.1
   408                              <1> 	pop	cx
   409                              <1> 	pop	ax
   410                              <1> 	ret
   411                              <1> 
   412                              <1> %endif ; PIT_DELAY
   413                              <1> %endif ; AT_DELAY
   414                              <1> 
   415                              <1> %if 0
   416                              <1> ;=========================================================================
   417                              <1> ; divide_32 - divide 64-bit argument by 32-bit, return 64-bit result
   418                              <1> ; Input:
   419                              <1> ;	DX:AX	- dividend
   420                              <1> ;	CX	- divisor
   421                              <1> ; Output:
   422                              <1> ;	DX:AX	- quotient
   423                              <1> ;-------------------------------------------------------------------------
   424                              <1> divide_32:
   425                              <1> 	or	dx,dx
   426                              <1> 	jnz	.1
   427                              <1> 	div	cx
   428                              <1> 	xor	dx,dx
   429                              <1> 	ret
   430                              <1> .1:
   431                              <1> 	push	bx
   432                              <1> 	mov	bx,ax
   433                              <1> 	mov	ax,dx
   434                              <1> 	xor	dx,dx
   435                              <1> 	div	cx
   436                              <1> 	xchg	bx,ax
   437                              <1> 	div	cx
   438                              <1> 	mov	dx,bx
   439                              <1> 	pop	bx
   440                              <1> 	ret
   441                              <1> %endif ; 0
   273                                  %include	"time1.inc"		; time services
   274                              <1> ;=========================================================================
   275                              <1> ; time1.inc - BIOS Time Services
   276                              <1> ;       INT 1Ah - BIOS Time Services
   277                              <1> ;		functions AH=00h to AH=07h
   278                              <1> ;	INT 70h - IRQ8 interrupt handler (RTC alarm)
   279                              <1> ;-------------------------------------------------------------------------
   280                              <1> ;
   281                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   282                              <1> ;
   283                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
   284                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   285                              <1> ;
   286                              <1> ; This program is free software: you can redistribute it and/or modify
   287                              <1> ; it under the terms of the GNU General Public License as published by
   288                              <1> ; the Free Software Foundation, either version 3 of the License, or
   289                              <1> ; (at your option) any later version.
   290                              <1> ;
   291                              <1> ; This program is distributed in the hope that it will be useful,
   292                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   293                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   294                              <1> ; GNU General Public License for more details.
   295                              <1> ;
   296                              <1> ; You should have received a copy of the GNU General Public License
   297                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   298                              <1> ;
   299                              <1> ;=========================================================================
   300                              <1> 
   301                              <1> ;=========================================================================
   302                              <1> ; int_1A_fn00 - Read current time
   303                              <1> ; Input:
   304                              <1> ;	AH = 0 - read current time
   305                              <1> ; Output:
   306                              <1> ;	CX = high word of tick count
   307                              <1> ;	DX = low word of tick count
   308                              <1> ;	AL = midnight flag: non-zero if midnight passed since time last read
   309                              <1> ;-------------------------------------------------------------------------
   310                              <1> int_1A_fn00:
   311 000016CA 8B166C00            <1> 	mov	dx,word [ticks_lo]
   312 000016CE 8B0E6E00            <1> 	mov	cx,word [ticks_hi]
   313 000016D2 A07000              <1> 	mov	al,byte [new_day]	; read new_day to al
   314 000016D5 30067000            <1> 	xor	byte [new_day],al	; new_day = 0
   315 000016D9 E9B947              <1> 	jmp	int_1A_exit
   316                              <1> 
   317                              <1> ;=========================================================================
   318                              <1> ; int_1A_fn01 - Set current time and clear midnight flag
   319                              <1> ; Input:
   320                              <1> ;	AH = 01h - function 01h - set current time and clear midnight flag
   321                              <1> ;	CX = high word of tick count
   322                              <1> ;	DX = low word of tick count
   323                              <1> ; Output:
   324                              <1> ;	None
   325                              <1> ;-------------------------------------------------------------------------
   326                              <1> int_1A_fn01:
   327 000016DC 89166C00            <1> 	mov	word [ticks_lo],dx
   328 000016E0 890E6E00            <1> 	mov	word [ticks_hi],cx
   329 000016E4 C606700000          <1> 	mov	byte [new_day],00h
   330 000016E9 E9A947              <1> 	jmp	int_1A_exit
   331                              <1> 
   332                              <1> %ifdef AT_RTC
   333                              <1> 
   334                              <1> ;=========================================================================
   335                              <1> ; int_1A_fn02 - Read real time clock (RTC)
   336                              <1> ; Input:
   337                              <1> ;	AH = 02h - function 02h - read RTC time
   338                              <1> ; Output:
   339                              <1> ;	CF set if RTC update is in progress and operation was not performed
   340                              <1> ;	CH = BCD hours
   341                              <1> ;	CL = BCD minutes
   342                              <1> ;	DH = BCD seconds
   343                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
   344                              <1> ;-------------------------------------------------------------------------
   345                              <1> int_1A_fn02:
   346                              <1> %ifdef AT_RTC_AUTODETECT
   347 000016EC E8CAF8              <1> 	call	rtc_detect		; check that RTC is present
   348 000016EF 7303E9A447          <1> 	jc	int_1A_exitf		; error - no RTC
   349                              <1> %endif ; AT_RTC_AUTODETECT
   350 000016F4 50                  <1> 	push	ax
   351 000016F5 B00A                <1> 	mov	al,cmos_control_a
   352 000016F7 E850F7              <1> 	call	rtc_read		; read control A register
   353 000016FA A880                <1> 	test	al,cmos_uip
   354 000016FC 7405                <1> 	jz	.1			; no update in progess
   355 000016FE F9                  <1> 	stc
   356 000016FF 58                  <1> 	pop	ax
   357 00001700 E99547              <1> 	jmp	int_1A_exitf
   358                              <1> .1:
   359 00001703 B00B                <1> 	mov	al,cmos_control_b
   360 00001705 E842F7              <1> 	call	rtc_read		; read control B register
   361 00001708 2401                <1> 	and	al,cmos_dse		; mask the daylight savings bit
   362 0000170A 88C2                <1> 	mov	dl,al
   363 0000170C B000                <1> 	mov	al,cmos_seconds
   364 0000170E E839F7              <1> 	call	rtc_read		; read seconds
   365 00001711 88C6                <1> 	mov	dh,al
   366 00001713 B002                <1> 	mov	al,cmos_minutes
   367 00001715 E832F7              <1> 	call	rtc_read		; read minutes
   368 00001718 88C1                <1> 	mov	cl,al
   369 0000171A B004                <1> 	mov	al,cmos_hours
   370 0000171C E82BF7              <1> 	call	rtc_read		; read hours
   371 0000171F 88C5                <1> 	mov	ch,al
   372 00001721 F8                  <1> 	clc
   373 00001722 58                  <1> 	pop	ax
   374 00001723 E97247              <1> 	jmp	int_1A_exitf
   375                              <1> 
   376                              <1> ;=========================================================================
   377                              <1> ; int_1A_fn03 - Set real time clock
   378                              <1> ; Input:
   379                              <1> ;	AH = 03h - function 03h - set RTC time
   380                              <1> ;	CH = BCD hours
   381                              <1> ;	CL = BCD minutes
   382                              <1> ;	DH = BCD seconds
   383                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
   384                              <1> ; Output:
   385                              <1> ;	None
   386                              <1> ;-------------------------------------------------------------------------
   387                              <1> int_1A_fn03:
   388                              <1> %ifdef AT_RTC_AUTODETECT
   389 00001726 E890F8              <1> 	call	rtc_detect		; check that RTC is present
   390 00001729 7303E96A47          <1> 	jc	int_1A_exitf		; error - no RTC
   391                              <1> %endif ; AT_RTC_AUTODETECT
   392 0000172E 50                  <1> 	push	ax
   393 0000172F B00B                <1> 	mov	al,cmos_control_b
   394 00001731 E816F7              <1> 	call	rtc_read		; read control B register
   395 00001734 88C4                <1> 	mov	ah,al
   396 00001736 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
   397 00001739 B00B                <1> 	mov	al,cmos_control_b
   398 0000173B E81BF7              <1> 	call	rtc_write		; write control B register
   399                              <1> 
   400 0000173E 80E201              <1> 	and	dl,cmos_dse		; mask the daylight saving flag
   401 00001741 80E4FE              <1> 	and	ah,~cmos_dse		; clear daylight saving flag for now
   402 00001744 08D4                <1> 	or	ah,dl			; add it from the input
   403 00001746 B00B                <1> 	mov	al,cmos_control_b
   404 00001748 E80EF7              <1> 	call	rtc_write		; write control B register
   405                              <1> 
   406 0000174B B000                <1> 	mov	al,cmos_seconds
   407 0000174D 88F4                <1> 	mov	ah,dh
   408 0000174F E807F7              <1> 	call	rtc_write		; write seconds
   409 00001752 B002                <1> 	mov	al,cmos_minutes
   410 00001754 88CC                <1> 	mov	ah,cl
   411 00001756 E800F7              <1> 	call	rtc_write		; write minutes
   412 00001759 B004                <1> 	mov	al,cmos_hours
   413 0000175B 88EC                <1> 	mov	ah,ch
   414 0000175D E8F9F6              <1> 	call	rtc_write		; write hours
   415                              <1> 
   416 00001760 B00B                <1> 	mov	al,cmos_control_b
   417 00001762 E8E5F6              <1> 	call	rtc_read		; read control B register
   418 00001765 88C4                <1> 	mov	ah,al
   419 00001767 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
   420 0000176A B00B                <1> 	mov	al,cmos_control_b
   421 0000176C E8EAF6              <1> 	call	rtc_write		; write control B register
   422 0000176F 58                  <1> 	pop	ax
   423 00001770 E92247              <1> 	jmp	int_1A_exit
   424                              <1> 
   425                              <1> ;=========================================================================
   426                              <1> ; int_1A_fn04 - Read date from real time clock
   427                              <1> ; Input:
   428                              <1> ;	AH = 04h - function 04h - read RTC date
   429                              <1> ; Output:
   430                              <1> ;	CF set if RTC update is in progress and operation was not performed
   431                              <1> ;	CH = BCD century
   432                              <1> ;	CL = BCD year
   433                              <1> ;	DH = BCD month
   434                              <1> ;	DL = BCD date
   435                              <1> ;-------------------------------------------------------------------------
   436                              <1> int_1A_fn04:
   437                              <1> %ifdef AT_RTC_AUTODETECT
   438 00001773 E843F8              <1> 	call	rtc_detect		; check that RTC is present
   439 00001776 7303E91D47          <1> 	jc	int_1A_exitf		; error - no RTC
   440                              <1> %endif ; AT_RTC_AUTODETECT
   441 0000177B 50                  <1> 	push	ax
   442 0000177C B00A                <1> 	mov	al,cmos_control_a
   443 0000177E E8C9F6              <1> 	call	rtc_read		; read control A register
   444 00001781 A880                <1> 	test	al,cmos_uip
   445 00001783 7405                <1> 	jz	.1			; no update in progess
   446 00001785 F9                  <1> 	stc
   447 00001786 58                  <1> 	pop	ax
   448 00001787 E90E47              <1> 	jmp	int_1A_exitf
   449                              <1> .1:
   450 0000178A B007                <1> 	mov	al,cmos_date
   451 0000178C E8BBF6              <1> 	call	rtc_read		; read date
   452 0000178F 88C2                <1> 	mov	dl,al
   453 00001791 B008                <1> 	mov	al,cmos_month
   454 00001793 E8B4F6              <1> 	call	rtc_read		; read month
   455 00001796 88C6                <1> 	mov	dh,al
   456 00001798 B009                <1> 	mov	al,cmos_year
   457 0000179A E8ADF6              <1> 	call	rtc_read		; read year
   458 0000179D 88C1                <1> 	mov	cl,al
   459 0000179F B032                <1> 	mov	al,cmos_century
   460 000017A1 E8A6F6              <1> 	call	rtc_read		; read century
   461 000017A4 88C5                <1> 	mov	ch,al
   462 000017A6 F8                  <1> 	clc
   463 000017A7 58                  <1> 	pop	ax
   464 000017A8 E9ED46              <1> 	jmp	int_1A_exitf
   465                              <1> 
   466                              <1> ;=========================================================================
   467                              <1> ; int_1A_fn05 - Set date in real time clock
   468                              <1> ; Input:
   469                              <1> ;	AH = 05h - function 05h - set RTC date
   470                              <1> ;	CH = BCD century
   471                              <1> ;	CL = BCD year
   472                              <1> ;	DH = BCD month
   473                              <1> ;	DL = BCD date
   474                              <1> ; Output:
   475                              <1> ;	None
   476                              <1> ;-------------------------------------------------------------------------
   477                              <1> int_1A_fn05:
   478                              <1> %ifdef AT_RTC_AUTODETECT
   479 000017AB E80BF8              <1> 	call	rtc_detect		; check that RTC is present
   480 000017AE 7303E9E546          <1> 	jc	int_1A_exitf		; error - no RTC
   481                              <1> %endif ; AT_RTC_AUTODETECT
   482 000017B3 50                  <1> 	push	ax
   483 000017B4 B00B                <1> 	mov	al,cmos_control_b
   484 000017B6 E891F6              <1> 	call	rtc_read		; read control B register
   485 000017B9 88C4                <1> 	mov	ah,al
   486 000017BB 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
   487 000017BE B00B                <1> 	mov	al,cmos_control_b
   488 000017C0 E896F6              <1> 	call	rtc_write		; write control B register
   489                              <1> 
   490 000017C3 B007                <1> 	mov	al,cmos_date
   491 000017C5 88D4                <1> 	mov	ah,dl
   492 000017C7 E88FF6              <1> 	call	rtc_write		; write date
   493                              <1> 
   494 000017CA B008                <1> 	mov	al,cmos_month
   495 000017CC 88F4                <1> 	mov	ah,dh
   496 000017CE E888F6              <1> 	call	rtc_write		; write month
   497 000017D1 B009                <1> 	mov	al,cmos_year
   498 000017D3 88CC                <1> 	mov	ah,cl
   499 000017D5 E881F6              <1> 	call	rtc_write		; write year
   500 000017D8 B032                <1> 	mov	al,cmos_century
   501 000017DA 88EC                <1> 	mov	ah,ch
   502 000017DC E87AF6              <1> 	call	rtc_write		; write centry
   503                              <1> 
   504 000017DF B00B                <1> 	mov	al,cmos_control_b
   505 000017E1 E866F6              <1> 	call	rtc_read		; read control B register
   506 000017E4 88C4                <1> 	mov	ah,al
   507 000017E6 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
   508 000017E9 B00B                <1> 	mov	al,cmos_control_b
   509 000017EB E86BF6              <1> 	call	rtc_write		; write control B register
   510 000017EE 58                  <1> 	pop	ax
   511 000017EF E9A346              <1> 	jmp	int_1A_exit
   512                              <1> 
   513                              <1> ;=========================================================================
   514                              <1> ; int_1A_fn06 - Set real time clock alarm
   515                              <1> ; Input:
   516                              <1> ;	AH = 06h - function 06h - set RTC alarm time
   517                              <1> ;	CH = BCD hours
   518                              <1> ;	CL = BCD minutes
   519                              <1> ;	DH = BCD seconds
   520                              <1> ; Output:
   521                              <1> ;	CF = 1 - alarm already set
   522                              <1> ;-------------------------------------------------------------------------
   523                              <1> int_1A_fn06:
   524                              <1> %ifdef AT_RTC_AUTODETECT
   525 000017F2 E8C4F7              <1> 	call	rtc_detect		; check that RTC is present
   526 000017F5 7303E99E46          <1> 	jc	int_1A_exitf		; error - no RTC
   527                              <1> %endif ; AT_RTC_AUTODETECT
   528 000017FA 50                  <1> 	push	ax
   529 000017FB B00B                <1> 	mov	al,cmos_control_b
   530 000017FD E84AF6              <1> 	call	rtc_read		; read control B register
   531 00001800 A820                <1> 	test	al,cmos_aie
   532 00001802 7405                <1> 	jz	.1			; RTC alarm interrupt is not enabled
   533 00001804 F9                  <1> 	stc
   534 00001805 58                  <1> 	pop	ax
   535 00001806 E98F46              <1> 	jmp	int_1A_exitf
   536                              <1> .1:
   537 00001809 88C4                <1> 	mov	ah,al
   538 0000180B 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
   539 0000180E B00B                <1> 	mov	al,cmos_control_b
   540 00001810 E846F6              <1> 	call	rtc_write		; write control B register
   541                              <1> 
   542 00001813 B001                <1> 	mov	al,cmos_alarm_secs
   543 00001815 88F4                <1> 	mov	ah,dh
   544 00001817 E83FF6              <1> 	call	rtc_write		; write alarm seconds
   545 0000181A B003                <1> 	mov	al,cmos_alarm_mins
   546 0000181C 88CC                <1> 	mov	ah,cl
   547 0000181E E838F6              <1> 	call	rtc_write		; write alarm minutes
   548 00001821 B005                <1> 	mov	al,cmos_alarm_hrs
   549 00001823 88EC                <1> 	mov	ah,ch
   550 00001825 E831F6              <1> 	call	rtc_write		; write alarm hours
   551                              <1> 
   552 00001828 B00B                <1> 	mov	al,cmos_control_b
   553 0000182A E81DF6              <1> 	call	rtc_read		; read control B register
   554 0000182D 88C4                <1> 	mov	ah,al
   555 0000182F 80E47F              <1> 	and	ah,~cmos_set		; set the RTC set bit
   556 00001832 B00B                <1> 	mov	al,cmos_control_b
   557 00001834 E822F6              <1> 	call	rtc_write		; write control B register
   558                              <1> 
   559 00001837 B00B                <1> 	mov	al,cmos_control_b
   560 00001839 E80EF6              <1> 	call	rtc_read		; read control B register
   561 0000183C 88C4                <1> 	mov	ah,al
   562 0000183E 80CC20              <1> 	or	ah,cmos_aie		; set alarm interrupt flag
   563 00001841 B00B                <1> 	mov	al,cmos_control_b
   564 00001843 E813F6              <1> 	call	rtc_write		; write control B register with AIE set
   565                              <1> 
   566 00001846 58                  <1> 	pop	ax
   567 00001847 F8                  <1> 	clc
   568 00001848 E94D46              <1> 	jmp	int_1A_exitf
   569                              <1> 
   570                              <1> ;=========================================================================
   571                              <1> ; int_1A_fn07 - Reset real time clock alarm
   572                              <1> ; Input:
   573                              <1> ;	AH = 07h - function 07h - set RTC time
   574                              <1> ; Output:
   575                              <1> ;	None
   576                              <1> ;-------------------------------------------------------------------------
   577                              <1> int_1A_fn07:
   578                              <1> %ifdef AT_RTC_AUTODETECT
   579 0000184B E86BF7              <1> 	call	rtc_detect		; check that RTC is present
   580 0000184E 7303E94546          <1> 	jc	int_1A_exitf		; error - no RTC
   581                              <1> %endif ; AT_RTC_AUTODETECT
   582 00001853 50                  <1> 	push	ax
   583                              <1> 
   584 00001854 B00B                <1> 	mov	al,cmos_control_b
   585 00001856 E8F1F5              <1> 	call	rtc_read		; read control B register
   586 00001859 88C4                <1> 	mov	ah,al
   587 0000185B 80E4DF              <1> 	and	ah,~cmos_aie		; clear alarm interrupt flag
   588 0000185E B00B                <1> 	mov	al,cmos_control_b
   589 00001860 E8F6F5              <1> 	call	rtc_write		; write control B reg. with AIE cleared
   590                              <1> 
   591 00001863 58                  <1> 	pop	ax
   592 00001864 E92E46              <1> 	jmp	int_1A_exit
   593                              <1> 	
   594                              <1> %ifdef SECOND_PIC
   595                              <1> ;=========================================================================
   596                              <1> ; int_70 - RTC interrupt service routine (IRQ8)
   597                              <1> ; Notes:
   598                              <1> ;	Calls INT 4Ah if interrupt is caused by RTC alarm
   599                              <1> ;-------------------------------------------------------------------------
   600                              <1> int_70:
   601                              <1> 	push	ax
   602                              <1> 	mov	al,20h
   603                              <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
   604                              <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
   605                              <1> 	mov	al,cmos_control_c
   606                              <1> 	call	rtc_read		; read control C register
   607                              <1> 	test	al,cmos_af		; check for alarm flag
   608                              <1> 	jz	.1
   609                              <1> 	int	4Ah			; call INT 4Ah
   610                              <1> .1:
   611                              <1> 	pop	ax
   612                              <1> 	iret
   613                              <1> %endif ; SECOND_PIC
   614                              <1> 
   615                              <1> %endif ; AT_RTC
   274                                  %include	"floppy1.inc"		; floppy services
   275                              <1> ;=========================================================================
   276                              <1> ; floppy1.inc - BIOS floppy disk services (part 1 of 2)
   277                              <1> ;	INT 13h, function AH=00h
   278                              <1> ;	INT 13h, function AH=01h
   279                              <1> ;	INT 13h, function AH=08h
   280                              <1> ;	INT 13h, function AH=15h
   281                              <1> ;	INT 13h, function AH=16h
   282                              <1> ;	INT 13h, function AH=17h
   283                              <1> ;	INT 13h, function AH=18h
   284                              <1> ;	INT 13h, function AH=08h
   285                              <1> ;	- see floppy2.inc for other INT 13h functions
   286                              <1> ;-------------------------------------------------------------------------
   287                              <1> ;
   288                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   289                              <1> ;
   290                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
   291                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   292                              <1> ;
   293                              <1> ; This program is free software: you can redistribute it and/or modify
   294                              <1> ; it under the terms of the GNU General Public License as published by
   295                              <1> ; the Free Software Foundation, either version 3 of the License, or
   296                              <1> ; (at your option) any later version.
   297                              <1> ;
   298                              <1> ; This program is distributed in the hope that it will be useful,
   299                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   300                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   301                              <1> ; GNU General Public License for more details.
   302                              <1> ;
   303                              <1> ; You should have received a copy of the GNU General Public License
   304                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   305                              <1> ;
   306                              <1> ;=========================================================================
   307                              <1> 
   308                              <1> ;-------------------------------------------------------------------------
   309                              <1> ; FDC registers
   310                              <1> 
   311                              <1> fdc_dor_reg	equ	3F2h		; FDC digital output register (W)
   312                              <1> fdc_status_reg	equ	3F4h		; FDC main status register (R)
   313                              <1> fdc_data_reg	equ	3F5h		; FDC data register (R/W)
   314                              <1> fdc_dir_reg	equ	3F7h		; FDC digital input register (W)
   315                              <1> fdc_ccr_reg	equ	3F7h		; FDC control configuration register (R)
   316                              <1> 
   317                              <1> ; FDC status register bits
   318                              <1> fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
   319                              <1> fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
   320                              <1> fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
   321                              <1> fdc_stat_busy	equ	10h		; 1 = FDC is busy
   322                              <1> 
   323                              <1> ;-------------------------------------------------------------------------
   324                              <1> ; DMAC registers
   325                              <1> 
   326                              <1> dmac_ch0_addr_reg	equ	00h	; DMAC channel 0 base addres (W)
   327                              <1> dmac_ch0_count_reg	equ	01h	; DMAC channel 0 word count (W)
   328                              <1> dmac_ch1_addr_reg	equ	02h	; DMAC channel 1 base addres (W)
   329                              <1> dmac_ch1_count_reg	equ	03h	; DMAC channel 1 word count (W)
   330                              <1> dmac_ch2_addr_reg	equ	04h	; DMAC channel 2 base addres (W)
   331                              <1> dmac_ch2_count_reg	equ	05h	; DMAC channel 2 word count (W)
   332                              <1> dmac_mask_reg		equ	0Ah	; DMAC single mask bit register (W)
   333                              <1> dmac_mode_reg		equ	0Bh	; DMAC mode register (R/W)
   334                              <1> dmac_ff_reg		equ	0Ch	; DMAC set (R) or clear (W)
   335                              <1> 					; first / last flip-flop
   336                              <1> dmapage_ch2_reg		equ	81h	; DMA page channel 2 register
   337                              <1> 
   338                              <1> ;-------------------------------------------------------------------------
   339                              <1> ; Floppy disk services - error codes
   340                              <1> 
   341                              <1> fdc_e_success	equ	00h		; successful completion
   342                              <1> fdc_e_invalid	equ	01h		; invalid function or parameter
   343                              <1> fdc_e_address	equ	02h		; address mark not found
   344                              <1> fdc_e_wprotect	equ	03h		; disk write-protected
   345                              <1> fdc_e_notfound	equ	04h		; sector not found
   346                              <1> fdc_e_changed	equ	06h		; disk changed
   347                              <1> fdc_e_dma	equ	08h		; DMA overrun
   348                              <1> fdc_e_boundary	equ	09h		; attempted DMA across 64K boundary
   349                              <1> fdc_e_format	equ	0Ch		; not supported or drive type unknown
   350                              <1> fdc_e_crc	equ	10h		; uncorrectable CRC error on read
   351                              <1> fdc_e_failure	equ	20h		; controller failure
   352                              <1> fdc_e_seek	equ	40h		; seek failed
   353                              <1> fdc_e_timeout	equ	80h		; timeout / device not ready
   354                              <1> 
   355                              <1> ;-------------------------------------------------------------------------
   356                              <1> ; Drive media state for fdc_media_state
   357                              <1> 
   358                              <1> fdc_m_rate_bits		equ	0C0h	; bits 7-6: data transfer rate
   359                              <1> 					; 00b = 500 Kbit/sec
   360                              <1> 					; 01b = 300 Kbit/sec
   361                              <1> 					; 10b = 250 Kbit/sec
   362                              <1> 					; 11b = 1 Mbit/sec
   363                              <1> fdc_m_double_step	equ	20h	; bit 5:    1 = double stepping required
   364                              <1> fdc_m_established	equ	10h	; bit 4:    1 = media/drive established
   365                              <1> fdc_m_state_bits	equ	07h	; bits 2-0: media state bits
   366                              <1> 					; 000b = trying 360K in 360K drive
   367                              <1> 					; 001b = trying 360K in 1.2M drive
   368                              <1> 					; 010b = trying 1.2M in 1.2M drive
   369                              <1> 					; 011b = known 360K in 360K drive
   370                              <1> 					; 100b = known 360K in 1.2M drive
   371                              <1> 					; 101b = known 1.2M in 1.2M drive
   372                              <1> 					; 110b = not used
   373                              <1> 					; 111b = 720K in 720K or 1.44M in 1.44M
   374                              <1> fdc_m_360in360		equ	93h	; 250 Kbps, established, 360K in 360K
   375                              <1> fdc_m_720		equ	97h	; 250 Kbps, established, other drive
   376                              <1> fdc_m_try_360in1200	equ	61h	; 300 Kbps, not established, 360K in 1.2
   377                              <1> fdc_m_360in1200		equ	74h	; 300 Kbps, established, 360K in 1.2M
   378                              <1> fdc_m_try_1200in1200	equ	02h	; 500 Kbps, not established, 1.2M in 1.2
   379                              <1> fdc_m_1200in1200	equ	15h	; 500 Kbps, established, 1.2M in 1.2M
   380                              <1> fdc_m_try_1440		equ	07h	; 500 Kbps, not established, other drive
   381                              <1> fdc_m_1440		equ	17h	; 500 Kbps, established, other drive
   382                              <1> fdc_m_try_2880		equ	0C7h	; 1 Mbps, not established, other drive
   383                              <1> fdc_m_2880		equ	0D7h	; 1 Mbps, established, other drive
   384                              <1> 
   385                              <1> ;-------------------------------------------------------------------------
   386                              <1> ; IRQ flag - fdc_calib_state, bit 7. Set by INT 0Eh (IRQ6) interrupt handler
   387                              <1> ;	     when IRQ6 happens to indicate completion of an I/O operation
   388                              <1> 
   389                              <1> fdc_irq_flag	equ	80h		; IRQ6 had occurred
   390                              <1> 
   391                              <1> ; write flag - fdc_motor_state, bit 7. Set for write or format,
   392                              <1> ;	       unset for read or verify
   393                              <1> 
   394                              <1> fdc_write_flag	equ	80h		; write or format operation
   395                              <1> 
   396                              <1> ;-------------------------------------------------------------------------
   397                              <1> ; floppy drive type definitions
   398                              <1> 
   399                              <1> type_none	equ	00h
   400                              <1> type_360	equ	01h
   401                              <1> type_1200	equ	02h
   402                              <1> type_720	equ	03h
   403                              <1> type_1440	equ	04h
   404                              <1> type_2880	equ	06h
   405                              <1> 
   406                              <1> ;=========================================================================
   407                              <1> ; int_13_fn00: Reset disk system
   408                              <1> ; Input:
   409                              <1> ;	AH = 00h
   410                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
   411                              <1> ; Output:
   412                              <1> ;	CF clear if successful
   413                              <1> ;		AH = 00h - successful completion
   414                              <1> ;	CF set on error
   415                              <1> ;		AH = 20h - controller failure
   416                              <1> ;		AH = 80h - timeout / device not ready
   417                              <1> ; Note:
   418                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
   419                              <1> ;	normally will call this functions if bit 7 of DL is not set
   420                              <1> ;-------------------------------------------------------------------------
   421                              <1> int_13_fn00:
   422 00001867 E80700              <1> 	call	fdc_init
   423 0000186A 88264100            <1> 	mov	byte [fdc_last_error],ah  ; save the error code
   424 0000186E E98034              <1> 	jmp	int_13_exit
   425                              <1> 
   426                              <1> ;=========================================================================
   427                              <1> ; fdc_init - Initialize floppy disk controller
   428                              <1> ; Input:
   429                              <1> ;	none
   430                              <1> ; Output:
   431                              <1> ;	CF clear on success
   432                              <1> ;		AH = 00h - successful completion
   433                              <1> ;	CF set if error
   434                              <1> ;		AH = 20h - controller failure
   435                              <1> ;		AH = 80h - timeout / device not ready
   436                              <1> ;-------------------------------------------------------------------------
   437                              <1> fdc_init:
   438 00001871 80263E00F0          <1> 	and	byte [fdc_calib_state],0F0h ; require recalibration
   439 00001876 E8BA05              <1> 	call	fdc_reset		; reset FDC
   440 00001879 7257                <1> 	jc	fdc_init_error
   441 0000187B BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
   442 0000187E EC                  <1> 	in	al,dx
   443 0000187F A880                <1> 	test	al,80h
   444 00001881 7404                <1> 	jz	.try_again		; try again if FDC not ready
   445 00001883 A840                <1> 	test	al,40h
   446 00001885 740F                <1> 	jz	.fdc_ready		; FDC ready to recieve data
   447                              <1> .try_again:
   448 00001887 E8A905              <1> 	call	fdc_reset
   449 0000188A BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
   450 0000188D EC                  <1> 	in	al,dx
   451 0000188E A880                <1> 	test	al,80h
   452 00001890 7440                <1> 	jz	fdc_init_error
   453 00001892 A840                <1> 	test	al,40h
   454 00001894 753C                <1> 	jnz	fdc_init_error
   455                              <1> .fdc_ready:
   456 00001896 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
   457 00001898 E8D904              <1> 	call	fdc_write		; send the command
   458 0000189B 7235                <1> 	jc	fdc_init_error
   459 0000189D E83105              <1> 	call	fdc_read		; read ST0
   460 000018A0 7230                <1> 	jc	fdc_init_error
   461 000018A2 A24200              <1> 	mov	byte [fdc_ctrl_status],al  ; save ST0
   462 000018A5 88C4                <1> 	mov	ah,al			; save AL to AH
   463 000018A7 E82705              <1> 	call	fdc_read		; read current cylinder
   464 000018AA 7226                <1> 	jc	fdc_init_error
   465 000018AC A24300              <1> 	mov	byte [fdc_ctrl_status+1],al  ; save
   466 000018AF 80E4C0              <1> 	and	ah,0C0h
   467 000018B2 80FCC0              <1> 	cmp	ah,0C0h			; abnormal termination?
   468 000018B5 751B                <1> 	jne	fdc_init_error	; not an abnormal termination
   469                              <1> 
   470                              <1> ; fall through to fdc_send_specify
   471                              <1> 
   472                              <1> ;=========================================================================
   473                              <1> ; fdc_send_specify - Send specify command to FDC
   474                              <1> ; Input:
   475                              <1> ;	none
   476                              <1> ; Output:
   477                              <1> ;	CF clear on success
   478                              <1> ;		AH = 00 - successful completion
   479                              <1> ;	CF set if error
   480                              <1> ;		AH = 20h - controller failure
   481                              <1> ;	AX,CL,SI trashed
   482                              <1> ; Note:
   483                              <1> ;	Specify command parameters are obtained from table at INT 1Eh vector
   484                              <1> ;-------------------------------------------------------------------------
   485                              <1> fdc_send_specify:
   486 000018B7 1E                  <1> 	push	ds
   487 000018B8 31F6                <1> 	xor	si,si
   488 000018BA 8EDE                <1> 	mov	ds,si
   489 000018BC C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   490 000018C0 B003                <1> 	mov	al,3		 	; FDC Specify command
   491 000018C2 8A24                <1> 	mov	ah,byte [si]		; specify command - byte 0
   492 000018C4 8B7401              <1> 	mov	si,word [si+1]		; specify command - byte 1
   493 000018C7 B103                <1> 	mov	cl,3			; command length 3 bytes (AX, SI - low)
   494 000018C9 1F                  <1> 	pop	ds
   495 000018CA E85B04              <1> 	call	fdc_send_cmd		; send specify command to FDC
   496 000018CD 7203                <1> 	jc	fdc_init_error
   497 000018CF B400                <1> 	mov	ah,fdc_e_success	; successful completion
   498 000018D1 C3                  <1> 	ret
   499                              <1> 
   500                              <1> fdc_init_error:
   501 000018D2 B420                <1> 	mov	ah,fdc_e_failure
   502 000018D4 F9                  <1> 	stc
   503 000018D5 C3                  <1> 	ret
   504                              <1> 
   505                              <1> ;=========================================================================
   506                              <1> ; int_13_fn01 - Get status of last operation
   507                              <1> ; Input:
   508                              <1> ;	AH = 01h
   509                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
   510                              <1> ; Output:
   511                              <1> ;	CF clear if last operation was successful
   512                              <1> ;		AH = 00h - successful completion
   513                              <1> ;	CF set on error
   514                              <1> ;		AH - error code of the last operation
   515                              <1> ; Note:
   516                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
   517                              <1> ;	normally will call this functions if bit 7 of DL is not set
   518                              <1> ;-------------------------------------------------------------------------
   519                              <1> int_13_fn01:
   520 000018D6 8A264100            <1> 	mov	ah,byte [fdc_last_error]
   521 000018DA 08E4                <1> 	or	ah,ah
   522 000018DC 7401                <1> 	jz	.no_error
   523 000018DE F9                  <1> 	stc
   524                              <1> .no_error:
   525 000018DF E90F34              <1> 	jmp	int_13_exit
   526                              <1> 
   527                              <1> ;=========================================================================
   528                              <1> ; int_13_fn08: Get drive parameters
   529                              <1> ; Input:
   530                              <1> ;	AH = 08h
   531                              <1> ;	DL = drive number (0 - 7Fh)
   532                              <1> ; Output:
   533                              <1> ;	CF clear if successful
   534                              <1> ;		AX = 0000h
   535                              <1> ;		BH = 00h
   536                              <1> ;		BL = drive type
   537                              <1> ;		CH = maximal cylinder number - 1
   538                              <1> ;		CL = maximal sector number
   539                              <1> ;		DH = maximal head number
   540                              <1> ;		DL = number of drives
   541                              <1> ;		ES:DI -> diskette parameter table
   542                              <1> ;	CF set on error
   543                              <1> ;		AH = 01h - drive number is greater than 7Fh
   544                              <1> ; Notes:
   545                              <1> ;	- If non-existent drive number is specified, function returns zeros in
   546                              <1> ;	AX,BX,CX,DH,ES,DI and number of floppy drives in DL (0 if no floppies)
   547                              <1> ;	- If media type is not established function sets media parameters 
   548                              <1> ;	based on drive type
   549                              <1> ;-------------------------------------------------------------------------
   550                              <1> int_13_fn08:
   551 000018E2 80FA80              <1> 	cmp	dl,80h			; valid floppy drive number?
   552 000018E5 7203E99E00          <1> 	jae	.invalid_drive		; hard drive number specified
   553 000018EA A01000              <1> 	mov	al,byte [equipment_list]
   554 000018ED 2441                <1> 	and	al,equip_floppies|equip_floppy2
   555 000018EF B402                <1> 	mov	ah,2			; assume two floppy drives
   556 000018F1 3C41                <1> 	cmp	al,equip_floppies|equip_floppy2 ; two floppy drives?
   557 000018F3 7406                <1> 	je	.check_drive_number
   558 000018F5 FECC                <1> 	dec	ah			; assume one floppy drive
   559 000018F7 3C01                <1> 	cmp	al,equip_floppies	; one floppy drive?
   560 000018F9 757B                <1> 	jne	.no_drives
   561                              <1> 
   562                              <1> .check_drive_number:
   563 000018FB 886608              <1> 	mov	byte [bp+int_13_dl],ah	; pass number of drives to caller
   564 000018FE 38E2                <1> 	cmp	dl,ah			; requested drive number is larger
   565                              <1> 					; than number of disks?
   566 00001900 7378                <1> 	jnb	.non_existent_drive	; jump if non existent drive requested
   567 00001902 E8D106              <1> 	call	get_drive_type		; returns drive type in AL
   568 00001905 7273                <1> 	jc	.non_existent_drive	; return no drive if there is an error
   569                              <1> 
   570 00001907 C6460901            <1> 	mov	byte [bp+int_13_dh],1	; maximal head number is 1 for floppy
   571 0000190B 88460C              <1> 	mov	byte [bp+int_13_bl],al	; pass drive type to caller
   572 0000190E 8CC9                <1> 	mov	cx,cs
   573 00001910 8EC1                <1> 	mov	es,cx			; diskette parameter table segment
   574                              <1> 
   575 00001912 3C01                <1> 	cmp	al,type_360
   576 00001914 7417                <1> 	je	.set_360
   577 00001916 3C03                <1> 	cmp	al,type_720
   578 00001918 741E                <1> 	je	.set_720
   579 0000191A 3C02                <1> 	cmp	al,type_1200
   580 0000191C 7425                <1> 	je	.set_1200
   581 0000191E 3C04                <1> 	cmp	al,type_1440
   582 00001920 742C                <1> 	je	.set_1440
   583                              <1> 
   584                              <1> .set_2880:
   585 00001922 B0C7                <1> 	mov	al,fdc_m_try_2880	; try 2.88M in 2.88M drive
   586 00001924 8D3E[B04F]          <1> 	lea	di,[media_2880]		; only 2.88M uses 1 Mbps rate
   587 00001928 B9244F              <1> 	mov	cx,4F24h		; 2.88M - 80 cylinders, 36 sectors
   588 0000192B EB2A                <1> 	jmp	.set_media_type
   589                              <1> 
   590                              <1> .set_360:
   591 0000192D B093                <1> 	mov	al,fdc_m_360in360
   592 0000192F 8D3E[6F4F]          <1> 	lea	di,[media_360_in_360]
   593 00001933 B90927              <1> 	mov	cx,2709h		; 360K - 40 cylinders, 9 sectors
   594 00001936 EB1F                <1> 	jmp	.set_media_type
   595                              <1> 
   596                              <1> .set_720:
   597 00001938 B097                <1> 	mov	al,fdc_m_720
   598 0000193A 8D3E[894F]          <1> 	lea	di,[media_720]
   599 0000193E B9094F              <1> 	mov	cx,4F09h		; 720K - 80 cylinders, 9 sectors
   600 00001941 EB14                <1> 	jmp	.set_media_type
   601                              <1> 
   602                              <1> .set_1200:
   603 00001943 B002                <1> 	mov	al,fdc_m_try_1200in1200
   604 00001945 8D3E[7C4F]          <1> 	lea	di,[media_1200]
   605 00001949 B90F4F              <1> 	mov	cx,4F0Fh		; 1.2M - 80 cylinders, 15 sectors
   606 0000194C EB09                <1> 	jmp	.set_media_type
   607                              <1> 
   608                              <1> .set_1440:
   609 0000194E B007                <1> 	mov	al,fdc_m_try_1440
   610 00001950 8D3E[964F]          <1> 	lea	di,[media_1440]
   611 00001954 B9124F              <1> 	mov	cx,4F12h		; 1.44M - 80 cylinders, 18 sectors
   612                              <1> 
   613                              <1> .set_media_type:
   614 00001957 E81C06              <1> 	call	get_media_state
   615 0000195A F6C310              <1> 	test	bl,fdc_m_established	; media type established?
   616 0000195D 7503                <1> 	jnz	.set_parameters		; no need to update if established
   617 0000195F E81E06              <1> 	call	set_media_state
   618                              <1> 
   619                              <1> .set_parameters:
   620 00001962 31C0                <1> 	xor	ax,ax			; AH = 00h - successful completion
   621 00001964 88460E              <1> 	mov	byte [bp+int_13_al],al	; successful completion
   622 00001967 A24100              <1> 	mov	byte [fdc_last_error],al
   623 0000196A 88460D              <1> 	mov	byte [bp+int_13_bh],al	; clear BH just in case
   624 0000196D 894E0A              <1> 	mov	word [bp+int_13_cx],cx	; cylinders / sectors
   625 00001970 897E04              <1> 	mov	word [bp+int_13_di],di	; diskette parameter table pointer
   626 00001973 E97B33              <1> 	jmp	int_13_exit
   627                              <1> 
   628                              <1> .no_drives:
   629 00001976 C6460800            <1> 	mov	byte [bp+int_13_dl],0	; zero drives
   630                              <1> 
   631                              <1> .non_existent_drive:
   632 0000197A 31C9                <1> 	xor	cx,cx
   633 0000197C 31FF                <1> 	xor	di,di
   634 0000197E 884E0C              <1> 	mov	byte [bp+int_13_bl],cl	; drive type is zero
   635 00001981 884E09              <1> 	mov	byte [bp+int_13_dh],cl	; maximal head number is zero
   636 00001984 8EC1                <1> 	mov	es,cx			; disk parameter table segment = 0000h
   637 00001986 EBDA                <1> 	jmp	.set_parameters
   638                              <1> 
   639                              <1> .invalid_drive:
   640 00001988 B401                <1> 	mov	ah,fdc_e_invalid
   641 0000198A F9                  <1> 	stc
   642 0000198B E96333              <1> 	jmp	int_13_exit
   643                              <1> 
   644                              <1> ;=========================================================================
   645                              <1> ; int_13_fn15: Get disk type
   646                              <1> ; Input:
   647                              <1> ;	AH = 15h
   648                              <1> ;	DL = drive number (0 or 1)
   649                              <1> ; Output:
   650                              <1> ;	AH = type code:
   651                              <1> ;		00h - no such drive (invalid drive specified)
   652                              <1> ;		01h - floppy without change-line support
   653                              <1> ;		02h - floppy with change-line support
   654                              <1> ;-------------------------------------------------------------------------
   655                              <1> int_13_fn15:
   656 0000198E B400                <1> 	mov	ah,00h			; assume no drive
   657 00001990 3C00                <1> 	cmp	al,type_none
   658 00001992 740C                <1> 	je	.exit
   659 00001994 B401                <1> 	mov	ah,01h			; assume no change-line support
   660 00001996 3C01                <1> 	cmp	al,type_360
   661 00001998 7406                <1> 	je	.exit
   662 0000199A 3C03                <1> 	cmp	al,type_720		; no change-line support on 720K drives?
   663 0000199C 7402                <1> 	je	.exit
   664 0000199E B402                <1> 	mov	ah,02h			; otherwise it supports change-line
   665                              <1> 
   666                              <1> .exit:
   667 000019A0 F8                  <1> 	clc
   668 000019A1 C606410000          <1> 	mov	byte [fdc_last_error],0
   669 000019A6 E94833              <1> 	jmp	int_13_exit
   670                              <1> 
   671                              <1> ;=========================================================================
   672                              <1> ; int_13_fn16 - Detect disk change
   673                              <1> ; Input:
   674                              <1> ;	AH = 16h
   675                              <1> ;	DL = drive number (0 or 1)
   676                              <1> ; Output:
   677                              <1> ;	CF clear if change line inactive
   678                              <1> ;		AH = 00h - disk not changed
   679                              <1> ;	CF set if change line active or error
   680                              <1> ;		AH = 01h - invalid drive number
   681                              <1> ;		AH = 06h - disk changed or change line not supported
   682                              <1> ;		AH = 80h - timeout / device not ready
   683                              <1> ;-------------------------------------------------------------------------
   684                              <1> int_13_fn16:
   685 000019A9 3C01                <1> 	cmp	al,type_360
   686 000019AB 742E                <1> 	je	.no_change_line		; report disk changed for 360K drives
   687 000019AD 3C03                <1> 	cmp	al,type_720
   688 000019AF 742A                <1> 	je	.no_change_line		; report disk changed for 720K drives
   689                              <1> 
   690 000019B1 E81602              <1> 	call	fdc_motor_on		; turn motor on
   691 000019B4 30E4                <1> 	xor	ah,ah			; assume disk not changed
   692 000019B6 BAF703              <1> 	mov	dx,fdc_dir_reg		; get digital input register address
   693 000019B9 EC                  <1> 	in	al,dx			; read disk change line
   694 000019BA D0E0                <1> 	shl	al,1			; bit 7 to CF
   695 000019BC 7303                <1> 	jnc	.exit
   696 000019BE B406                <1> 	mov	ah,fdc_e_changed
   697 000019C0 F9                  <1> 	stc
   698                              <1> 
   699                              <1> .exit:
   700 000019C1 88264100            <1> 	mov	byte [fdc_last_error],ah  ; save the error code
   701 000019C5 9C                  <1> 	pushf
   702 000019C6 1E                  <1> 	push	ds
   703 000019C7 31F6                <1> 	xor	si,si
   704 000019C9 8EDE                <1> 	mov	ds,si
   705 000019CB C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   706 000019CF 8A4C02              <1> 	mov	cl,byte [si+2]
   707 000019D2 1F                  <1> 	pop	ds
   708 000019D3 880E4000            <1> 	mov	byte [fdc_motor_tout],cl ; ticks before turning off the motor
   709 000019D7 9D                  <1> 	popf
   710 000019D8 E91633              <1> 	jmp	int_13_exit
   711                              <1> 
   712                              <1> .no_change_line:
   713 000019DB B406                <1> 	mov	ah,fdc_e_changed	; can't detect - report disk changed
   714 000019DD F9                  <1> 	stc
   715 000019DE 88264100            <1> 	mov	byte [fdc_last_error],ah
   716 000019E2 E90C33              <1> 	jmp	int_13_exit
   717                              <1> 
   718                              <1> .invalid_drive:
   719 000019E5 B401                <1> 	mov	ah,fdc_e_invalid
   720 000019E7 F9                  <1> 	stc
   721 000019E8 E90633              <1> 	jmp	int_13_exit
   722                              <1> 
   723                              <1> ;=========================================================================
   724                              <1> ; int_13_fn17 - Set disk type for format
   725                              <1> ; Input:
   726                              <1> ;	AH = 17h
   727                              <1> ;	AL = format type
   728                              <1> ;		01h - 320K / 360K disk in 360K drive
   729                              <1> ;		02h - 320K / 360K disk in 1.2M drive
   730                              <1> ;		03h - 1.2M disk in 1.2M drive
   731                              <1> ;		04h - 720K disk in 720K or 1.2M drive
   732                              <1> ;	DL = drive number (0 or 1)
   733                              <1> ; Output:
   734                              <1> ;	CF clear if successful
   735                              <1> ;		AH = 00h - successful completion
   736                              <1> ;	CF set on error
   737                              <1> ;		AH = 01h - invalid drive number
   738                              <1> ;		AH = 06h - disk changed
   739                              <1> ;		AH = 80h - timeout / device not ready
   740                              <1> ;-------------------------------------------------------------------------
   741                              <1> int_13_fn17:
   742 000019EB 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; get original AL value to CL
   743 000019EE 80F900              <1> 	cmp	cl,0			; validate parameters
   744 000019F1 744F                <1> 	je	.invalid_parameters
   745 000019F3 80F904              <1> 	cmp	cl,4
   746 000019F6 774A                <1> 	ja	.invalid_parameters
   747 000019F8 80F901              <1> 	cmp	cl,1			; 360K disk in 360K drive?
   748 000019FB 7506                <1> 	jne	.not_360in360
   749 000019FD B400                <1> 	mov	ah,0			; no error
   750 000019FF B093                <1> 	mov	al,fdc_m_360in360	; 360K disk in 360K drive
   751 00001A01 EB30                <1> 	jmp	.exit_check_error
   752                              <1> 
   753                              <1> .not_360in360:
   754 00001A03 E8C401              <1> 	call	fdc_motor_on
   755 00001A06 E86602              <1> 	call	fdc_disk_change		; check if disk has been changed
   756 00001A09 80FC06              <1> 	cmp	ah,fdc_e_changed
   757 00001A0C 7611                <1> 	jbe	.set_type		; disk changed (no errors other than
   758                              <1> 					; "disk changed" from fdc_disk_change)
   759 00001A0E 80FC80              <1> 	cmp	ah,fdc_e_timeout
   760 00001A11 750C                <1> 	jne	.set_type		; floppy disk is installed
   761 00001A13 E86005              <1> 	call	get_media_state		; BL = media state
   762 00001A16 80FB97              <1> 	cmp	bl,fdc_m_720		; 250 Kbps and not 5.25?
   763 00001A19 7418                <1> 	je	.exit_check_error
   764 00001A1B B061                <1> 	mov	al,fdc_m_try_360in1200	; 300 Kpbs, try 360 in 1.2M
   765 00001A1D EB14                <1> 	jmp	.exit_check_error
   766                              <1> 
   767                              <1> .set_type:
   768 00001A1F 80F904              <1> 	cmp	cl,4			; 720K in 720K?
   769 00001A22 7504                <1> 	jne	.check_360in1200	; jump if not 720K in 720K
   770 00001A24 B097                <1> 	mov	al,fdc_m_720
   771 00001A26 EB0B                <1> 	jmp	.exit_check_error
   772                              <1> 
   773                              <1> .check_360in1200:
   774 00001A28 80F902              <1> 	cmp	cl,2			; 360K in 1.2M?
   775 00001A2B 7504                <1> 	jne	.set_1200in1200		; jump if not 360K in 1.2M
   776 00001A2D B074                <1> 	mov	al,fdc_m_360in1200
   777 00001A2F EB02                <1> 	jmp	.exit_check_error
   778                              <1> 
   779                              <1> .set_1200in1200:
   780 00001A31 B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M
   781                              <1> 
   782                              <1> .exit_check_error:
   783 00001A33 E84A05              <1> 	call	set_media_state		; set media state to value in AL
   784 00001A36 88264100            <1> 	mov	byte [fdc_last_error],ah
   785 00001A3A 08E4                <1> 	or	ah,ah
   786 00001A3C 7401                <1> 	jz	.exit			; jump if no error
   787 00001A3E F9                  <1> 	stc				; indicate error
   788                              <1> 
   789                              <1> .exit:
   790 00001A3F E99032              <1> 	jmp	int_13_upd_exit
   791                              <1> 
   792                              <1> .invalid_parameters:
   793 00001A42 B401                <1> 	mov	ah,fdc_e_invalid
   794 00001A44 EBF9                <1> 	jmp	.exit
   795                              <1> 
   796                              <1> ;=========================================================================
   797                              <1> ; int_13_fn18 - Set media type for format
   798                              <1> ; Input:
   799                              <1> ;	AH = 18h
   800                              <1> ;	DL = drive number (0 or 1)
   801                              <1> ;	CH = number of cylinders - 1
   802                              <1> ;	CL = sectors per track
   803                              <1> ; Output:
   804                              <1> ;	CF = clear if successful
   805                              <1> ;		AH = 00h - requested format is supported
   806                              <1> ;		ES:DI -> diskette parameter table
   807                              <1> ;	CF = set on error
   808                              <1> ;		AH = 01h - invalid drive number specified
   809                              <1> ;		AH = 0Ch - format is not supported or drive type is unknown
   810                              <1> ;-------------------------------------------------------------------------
   811                              <1> int_13_fn18:
   812 00001A46 3C01                <1> 	cmp	al,type_360		; 360K drive?
   813 00001A48 750E                <1> 	jne	.try_drive_1200
   814 00001A4A 81F90927            <1> 	cmp	cx,2709h	 	; 40 tracks 9 sectors?
   815 00001A4E 7573                <1> 	jnz	.unsupported_format
   816 00001A50 B093                <1> 	mov	al,fdc_m_360in360	; 360K in 360K established, 250 Kbps
   817 00001A52 8D3E[6F4F]          <1> 	lea	di,[media_360_in_360]
   818 00001A56 EB54                <1> 	jmp	.set_media
   819                              <1> 
   820                              <1> .try_drive_1200:
   821 00001A58 3C02                <1> 	cmp	al,type_1200		; 1.2M drive?
   822 00001A5A 751C                <1> 	jne	.try_drive_2880
   823 00001A5C 81F90F4F            <1> 	cmp	cx,4F0Fh		; 80 tracks 15 sectors?
   824 00001A60 7508                <1> 	jne	.try_media_360_in_1200
   825 00001A62 B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M established, 500Kbps
   826 00001A64 8D3E[7C4F]          <1> 	lea	di,[media_1200]		; 1.2M
   827 00001A68 EB42                <1> 	jmp	.set_media
   828                              <1> 
   829                              <1> .try_media_360_in_1200:
   830 00001A6A 81F90927            <1> 	cmp	cx,2709h		; 80 tracks 9 sectors?
   831 00001A6E 7553                <1> 	jne	.unsupported_format
   832 00001A70 B074                <1> 	mov	al,fdc_m_360in1200	; 360K in 1.2M established, 300Kbps
   833 00001A72 8D3E[A34F]          <1> 	lea	di,[media_360_in_1200]	; 360K in 1.2M
   834 00001A76 EB34                <1> 	jmp	.set_media
   835                              <1> 
   836                              <1> .try_drive_2880:
   837 00001A78 3C06                <1> 	cmp	al,type_2880		; 2.88M drive?
   838 00001A7A 750E                <1> 	jne	.try_drive_1440
   839 00001A7C 81F9244F            <1> 	cmp	cx,4F24h		; 80 tracks 36 sectors?
   840 00001A80 750C                <1> 	jne	.try_media_1440
   841 00001A82 B0D7                <1> 	mov	al,fdc_m_2880		; indicate 2.88M
   842 00001A84 8D3E[B04F]          <1> 	lea	di,[media_2880]
   843 00001A88 EB22                <1> 	jmp	.set_media
   844                              <1> 
   845                              <1> .try_drive_1440:
   846 00001A8A 3C04                <1> 	cmp	al,type_1440		; 1.44M drive?
   847 00001A8C 750E                <1> 	jne	.try_drive_720
   848                              <1> 
   849                              <1> .try_media_1440:
   850 00001A8E 81F9124F            <1> 	cmp	cx,4F12h		; 80 tracks 18 sectors?
   851 00001A92 750C                <1> 	jne	.try_media_720
   852 00001A94 B017                <1> 	mov	al,fdc_m_1440		; indicate 1.44M
   853 00001A96 8D3E[964F]          <1> 	lea	di,[media_1440]
   854 00001A9A EB10                <1> 	jmp	.set_media
   855                              <1> 
   856                              <1> .try_drive_720:
   857 00001A9C 3C03                <1> 	cmp	al,type_720		; 720K drive?
   858 00001A9E 7523                <1> 	jne	.unsupported_format	; should never happen...
   859                              <1> 
   860                              <1> .try_media_720:	
   861 00001AA0 81F9094F            <1> 	cmp	cx,4F09h		; 80 tracks 9 sectors?
   862 00001AA4 751D                <1> 	jne	.unsupported_format
   863 00001AA6 B097                <1> 	mov	al,fdc_m_720		; other established, 250Kbps
   864 00001AA8 8D3E[894F]          <1> 	lea	di,[media_720]		; 720K
   865                              <1> 
   866                              <1> .set_media:
   867 00001AAC E8D104              <1> 	call	set_media_state		; set drive media state (in AL)
   868 00001AAF E87404              <1> 	call	fdc_set_rate		; transfer rate in AL (bits 7-6)
   869 00001AB2 897E04              <1> 	mov	word [bp+int_13_di],di	; return parameters table - offset
   870 00001AB5 8CC9                <1> 	mov	cx,cs
   871 00001AB7 8EC1                <1> 	mov	es,cx			; return parameters table - segment
   872 00001AB9 C606410000          <1> 	mov	byte [fdc_last_error],0	; no errors
   873 00001ABE 30E4                <1> 	xor	ah,ah
   874 00001AC0 E90F32              <1> 	jmp	int_13_upd_exit
   875                              <1> 
   876                              <1> .unsupported_format:
   877 00001AC3 B40C                <1> 	mov	ah,fdc_e_format		; not supported or drive type unknown
   878 00001AC5 F9                  <1> 	stc
   879 00001AC6 E90932              <1> 	jmp	int_13_upd_exit
   880                              <1> 
   881                              <1> ;=========================================================================
   882                              <1> ; fdc_recalibrate - Recalibrate disk drive, seek to cylinder 0
   883                              <1> ; Input:
   884                              <1> ;	[BP+int_13_dl] = drive number (0 or 1)
   885                              <1> ; Output:
   886                              <1> ;	CF clear if successful
   887                              <1> ;		AH = 00h - successful completion
   888                              <1> ;	CF set on error
   889                              <1> ;		AH = 20h - controller failure
   890                              <1> ;		AH = 20h - timeout
   891                              <1> ;	AH trashed
   892                              <1> ;-------------------------------------------------------------------------
   893                              <1> fdc_recalibrate:
   894 00001AC9 56                  <1> 	push	si
   895 00001ACA 51                  <1> 	push	cx
   896 00001ACB 52                  <1> 	push	dx
   897 00001ACC B007                <1> 	mov	al,07h			; FDC Recalibrate command
   898 00001ACE 8A6608              <1> 	mov	ah,byte [bp+int_13_dl]	; drive number - 2nd byte of command
   899 00001AD1 B102                <1> 	mov	cl,2			; 2 bytes command
   900 00001AD3 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
   901 00001AD8 E84D02              <1> 	call	fdc_send_cmd
   902 00001ADB 7236                <1> 	jc	recal_end		; failure
   903 00001ADD E85F04              <1> 	call	fdc_wait_irq		; wait for IRQ
   904 00001AE0 7231                <1> 	jc	recal_end		; timeout waiting for interrupt
   905 00001AE2 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
   906 00001AE4 B101                <1> 	mov	cl,1			; 1 byte command
   907 00001AE6 E83F02              <1> 	call	fdc_send_cmd
   908 00001AE9 7228                <1> 	jc	recal_end		; failure
   909 00001AEB B90200              <1> 	mov	cx,2			; 2 bytes result
   910 00001AEE E8A902              <1> 	call	fdc_get_result		; store result
   911 00001AF1 7220                <1> 	jc	recal_end		; failure
   912 00001AF3 BB4200              <1> 	mov	bx,fdc_ctrl_status
   913 00001AF6 B440                <1> 	mov	ah,fdc_e_seek
   914 00001AF8 8A17                <1> 	mov	dl,byte [bx]			; ST0
   915 00001AFA 80E260              <1> 	and	dl,60h
   916 00001AFD 80FA60              <1> 	cmp	dl,60h			; abnormal termination + seek end
   917 00001B00 F9                  <1> 	stc				; indicate error
   918 00001B01 7410                <1> 	je	recal_end		; failure
   919                              <1> 
   920 00001B03 B500                <1> 	mov	ch,0
   921 00001B05 E89004              <1> 	call	set_cylinder		; set current cylinder to 0
   922 00001B08 E8A704              <1> 	call	set_drive_calibrated	; set drive calibrated in data area
   923 00001B0B B94300              <1> 	mov	cx,43h
   924 00001B0E E887FB              <1> 	call	delay_15us		; 1 ms delay
   925 00001B11 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
   926                              <1> 
   927                              <1> recal_end:
   928 00001B13 88264100            <1> 	mov	byte [fdc_last_error],ah
   929 00001B17 5A                  <1> 	pop	dx
   930 00001B18 59                  <1> 	pop	cx
   931 00001B19 5E                  <1> 	pop	si
   932 00001B1A C3                  <1> 	ret
   933                              <1> 
   934                              <1> ;=========================================================================
   935                              <1> ; fdc_seek - Move floppy drive head to the specified cylinder
   936                              <1> ; Input:
   937                              <1> ;	DL = drive number
   938                              <1> ;	DH = head number
   939                              <1> ;	CH = cylinder
   940                              <1> ; Output:
   941                              <1> ;	CF clear if successful
   942                              <1> ;		AH = 00h - successful completion
   943                              <1> ;	CF set on error
   944                              <1> ;		AH = 20h - controller failure
   945                              <1> ;		AH = 40h - seek failed
   946                              <1> ;		AH = 80h - timeout / device not ready
   947                              <1> ;-------------------------------------------------------------------------
   948                              <1> fdc_seek:
   949 00001B1B 53                  <1> 	push	bx
   950 00001B1C 51                  <1> 	push	cx
   951 00001B1D 52                  <1> 	push	dx
   952 00001B1E E88304              <1> 	call	check_drive_calibrated
   953 00001B21 720A                <1> 	jc	.skip_recalibrate	; jump if drive is already calibrated
   954 00001B23 E8A3FF              <1> 	call	fdc_recalibrate
   955 00001B26 7305                <1> 	jnc	.skip_recalibrate	; jump if calibration successful
   956 00001B28 E89EFF              <1> 	call	fdc_recalibrate		; try recalibrating again
   957 00001B2B 727B                <1> 	jc	.exit			; no luck...
   958                              <1> 
   959                              <1> .skip_recalibrate:
   960 00001B2D E84604              <1> 	call	get_media_state		; BL = media state
   961 00001B30 F6C320              <1> 	test	bl,fdc_m_double_step 	; check double stepping bit
   962 00001B33 7402                <1> 	jz	.no_double_stepping
   963 00001B35 D0E5                <1> 	shl	ch,1			; CH = CH * 2 (double cylinder number)
   964                              <1> 
   965                              <1> .no_double_stepping:
   966 00001B37 E85204              <1> 	call	check_cylinder		; already at the right cylinder?
   967 00001B3A 750B                <1> 	jnz	.do_seek		; jump if seek is required
   968 00001B3C 803E410040          <1> 	cmp	byte [fdc_last_error],fdc_e_seek
   969 00001B41 7404                <1> 	je	.do_seek		; jump if it was a seek error
   970 00001B43 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - success
   971 00001B45 EB61                <1> 	jmp	.exit
   972                              <1> 
   973                              <1> .do_seek:
   974 00001B47 88E8                <1> 	mov	al,ch			; cylinder
   975 00001B49 89C6                <1> 	mov	si,ax			; SI - low = cylinder number
   976 00001B4B B00F                <1> 	mov	al,0Fh			; FDC Seek command
   977 00001B4D 88F4                <1> 	mov	ah,dh			; head
   978 00001B4F D0E4                <1> 	shl	ah,1			; move head to bit 2
   979 00001B51 D0E4                <1> 	shl	ah,1
   980 00001B53 0A6608              <1> 	or	ah,byte [bp+int_13_dl]	; seek - byte 1 (head / drive)
   981 00001B56 B103                <1> 	mov	cl,3			; 3 bytes command
   982 00001B58 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
   983 00001B5D E8C801              <1> 	call	fdc_send_cmd
   984 00001B60 7242                <1> 	jc	.set_result		; seek error
   985 00001B62 E8DA03              <1> 	call	fdc_wait_irq		; wait for IRQ
   986 00001B65 723D                <1> 	jc	.set_result		; timeout waiting for interrupt
   987                              <1> 
   988 00001B67 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
   989 00001B69 B101                <1> 	mov	cl,1			; 1 byte command
   990 00001B6B E8BA01              <1> 	call	fdc_send_cmd
   991 00001B6E 7234                <1> 	jc	.set_result		; failure
   992 00001B70 B102                <1> 	mov	cl,2
   993 00001B72 53                  <1> 	push	bx
   994 00001B73 E82402              <1> 	call	fdc_get_result		; read result bytes
   995 00001B76 5B                  <1> 	pop	bx
   996 00001B77 722B                <1> 	jc	.set_result		; error
   997 00001B79 B440                <1> 	mov	ah,fdc_e_seek
   998 00001B7B A04200              <1> 	mov	al,byte [fdc_ctrl_status] ; ST0
   999 00001B7E 2460                <1> 	and	al,60h
  1000 00001B80 3C60                <1> 	cmp	al,60h			; abnormal termination + seek end
  1001 00001B82 F9                  <1> 	stc
  1002 00001B83 741F                <1> 	je	.set_result		; seek error
  1003 00001B85 E81004              <1> 	call	set_cylinder		; save new cylinder number
  1004                              <1> 
  1005 00001B88 1E                  <1> 	push	ds
  1006 00001B89 31F6                <1> 	xor	si,si
  1007 00001B8B 8EDE                <1> 	mov	ds,si
  1008 00001B8D C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1009 00001B91 8A4409              <1> 	mov	al,byte [si+9]		; AL = head settle time in ms
  1010 00001B94 1F                  <1> 	pop	ds
  1011                              <1> 
  1012 00001B95 08C0                <1> 	or	al,al			; head settle time is zero?!
  1013 00001B97 7413                <1> 	jz	.get_settle_time
  1014                              <1> 
  1015 00001B99 B143                <1> 	mov	cl,67			; 15 us * 67 ~= 1 ms
  1016 00001B9B F6E1                <1> 	mul	cl			; AX = delay in 15 us intervals
  1017 00001B9D 89C1                <1> 	mov	cx,ax
  1018                              <1> 
  1019                              <1> .wait:
  1020 00001B9F E8F6FA              <1> 	call	delay_15us
  1021                              <1> 
  1022                              <1> .wait_end:
  1023 00001BA2 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
  1024                              <1> 
  1025                              <1> .set_result:
  1026 00001BA4 88264100            <1> 	mov	byte [fdc_last_error],ah
  1027                              <1> 
  1028                              <1> .exit:
  1029 00001BA8 5A                  <1> 	pop	dx
  1030 00001BA9 59                  <1> 	pop	cx
  1031 00001BAA 5B                  <1> 	pop	bx
  1032 00001BAB C3                  <1> 	ret
  1033                              <1> 
  1034                              <1> .get_settle_time:
  1035 00001BAC F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; test the write bit
  1036 00001BB1 74EF                <1> 	jz	.wait_end		; jump if read / verify - no wait
  1037                              <1> 
  1038 00001BB3 E8C003              <1> 	call	get_media_state	
  1039 00001BB6 88DC                <1> 	mov	ah,bl			; AH = media state
  1040 00001BB8 80E407              <1> 	and	ah,fdc_m_state_bits	; leave only drive media state bits
  1041 00001BBB B92D05              <1> 	mov	cx,1325			; 20 ms delay for 360K drives
  1042 00001BBE 74DF                <1> 	jz	.wait			; jump if 360K, media not established
  1043 00001BC0 80FC03              <1> 	cmp	ah,fdc_m_360in360 & fdc_m_state_bits
  1044 00001BC3 74DA                <1> 	je	.wait			; jump if 360K, media established
  1045 00001BC5 B9E303              <1> 	mov	cx,995			; 15 ms delay for other drives
  1046 00001BC8 EBD5                <1> 	jmp	.wait
  1047                              <1> 
  1048                              <1> ;=========================================================================
  1049                              <1> ; fdc_motor_on - Turn motor on (if it is not on yet)
  1050                              <1> ; Input:
  1051                              <1> ;	DL = drive number (0 or 1) -- FIXME: Does it receive DL?
  1052                              <1> ; Output:
  1053                              <1> ;	none
  1054                              <1> ;-------------------------------------------------------------------------
  1055                              <1> fdc_motor_on:
  1056 00001BCA 50                  <1> 	push	ax
  1057 00001BCB 51                  <1> 	push	cx
  1058 00001BCC 52                  <1> 	push	dx
  1059 00001BCD FA                  <1> 	cli				; entering critical section
  1060 00001BCE C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh  ; set timeout to maximum
  1061 00001BD3 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; DL = drive number
  1062 00001BD6 88D1                <1> 	mov	cl,dl			; CL = drive number
  1063 00001BD8 FEC1                <1> 	inc	cl			; CL = drive number + 1
  1064 00001BDA A03F00              <1> 	mov	al,byte [fdc_motor_state] ; AL = motor state byte
  1065 00001BDD 88C6                <1> 	mov	dh,al			; keep a copy in motor state in DH
  1066 00001BDF 24CF                <1> 	and	al,0CFh			; clear drive select bits (5-4)
  1067                              <1> 
  1068 00001BE1 D0E2                <1> 	shl	dl,1			; shift drive number to bits (5-4)
  1069 00001BE3 D0E2                <1> 	shl	dl,1
  1070 00001BE5 D0E2                <1> 	shl	dl,1
  1071 00001BE7 D0E2                <1> 	shl	dl,1
  1072 00001BE9 08D0                <1> 	or	al,dl			; select drive
  1073 00001BEB D2EE                <1> 	shr	dh,cl			; set CF if motor for is on
  1074 00001BED 724A                <1> 	jc	.already_on
  1075 00001BEF B201                <1> 	mov	dl,1
  1076 00001BF1 FEC9                <1> 	dec	cl
  1077 00001BF3 D2E2                <1> 	shl	dl,cl
  1078 00001BF5 08D0                <1> 	or	al,dl			; indicate that motor is on
  1079 00001BF7 A23F00              <1> 	mov	byte [fdc_motor_state],al ; update motor state in data area
  1080 00001BFA FB                  <1> 	sti
  1081 00001BFB 0C40                <1> 	or	al,40h			; no reset
  1082 00001BFD E86703              <1> 	call	set_fdc_dor
  1083 00001C00 B8FD90              <1> 	mov	ax,90FDh
  1084 00001C03 CD15                <1> 	int	15h			; call OS hook
  1085 00001C05 722E                <1> 	jc	.exit
  1086 00001C07 1E                  <1> 	push	ds
  1087 00001C08 56                  <1> 	push	si
  1088 00001C09 31F6                <1> 	xor	si,si
  1089 00001C0B 8EDE                <1> 	mov	ds,si
  1090 00001C0D C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1091 00001C11 8A440A              <1> 	mov	al,byte [si+0Ah]	; AL = motor start time in 1/8 second
  1092 00001C14 5E                  <1> 	pop	si
  1093 00001C15 1F                  <1> 	pop	ds
  1094                              <1> 
  1095 00001C16 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; test the write bit
  1096 00001C1B 7408                <1> 	jz	.read_verify		; jump if not write operation
  1097 00001C1D 3C08                <1> 	cmp	al,8
  1098 00001C1F 730A                <1> 	jae	.wait_loop		; jump if at least 1 second start time
  1099 00001C21 B008                <1> 	mov	al,8			; wait at least 1 second for write
  1100 00001C23 EB06                <1> 	jmp	.wait_loop
  1101                              <1> 
  1102                              <1> .read_verify:
  1103 00001C25 3C05                <1> 	cmp	al,5
  1104 00001C27 7302                <1> 	jae	.wait_loop		; jump if at least 625 ms start time
  1105 00001C29 B005                <1> 	mov	al,5			; wait at least 625 ms for read / verify
  1106                              <1> 
  1107                              <1> .wait_loop:
  1108 00001C2B B95F20              <1> 	mov	cx,8287			; 8287 * 15.09us ~= 125ms
  1109 00001C2E E867FA              <1> 	call	delay_15us		; wait 125 ms
  1110 00001C31 FEC8                <1> 	dec	al
  1111 00001C33 75F6                <1> 	jnz	.wait_loop		; repeat until AL = 0
  1112                              <1> 
  1113                              <1> .exit:
  1114 00001C35 5A                  <1> 	pop	dx
  1115 00001C36 59                  <1> 	pop	cx
  1116 00001C37 58                  <1> 	pop	ax
  1117 00001C38 C3                  <1> 	ret
  1118                              <1> 
  1119                              <1> .already_on:
  1120 00001C39 A23F00              <1> 	mov	byte [fdc_motor_state],al ; update motor state (AL) in data area
  1121 00001C3C FB                  <1> 	sti
  1122 00001C3D 0C40                <1> 	or	al,40h			; no reset
  1123 00001C3F E82503              <1> 	call	set_fdc_dor
  1124 00001C42 EBF1                <1> 	jmp	.exit
  1125                              <1> 
  1126                              <1> ;=========================================================================
  1127                              <1> ; fdc_end_io - Set motor timeout, return next sector to be transferred
  1128                              <1> ; Input:
  1129                              <1> ;	CH = cylinder
  1130                              <1> ;	DH = head
  1131                              <1> ; Output:
  1132                              <1> ;	BL = next sector to be transferred
  1133                              <1> ;-------------------------------------------------------------------------	
  1134                              <1> fdc_end_io:
  1135 00001C44 50                  <1> 	push	ax
  1136 00001C45 1E                  <1> 	push	ds
  1137 00001C46 31DB                <1> 	xor	bx,bx
  1138 00001C48 8EDB                <1> 	mov	ds,bx
  1139 00001C4A C51E7800            <1> 	lds	bx,[1Eh*4]		; DS:BX -> INT 1Eh
  1140 00001C4E 8A6702              <1> 	mov	ah,byte [bx+2]		; motor timeout (ticks)
  1141 00001C51 8A4704              <1> 	mov	al,byte [bx+4]		; sectors per track
  1142 00001C54 FEC0                <1> 	inc	al
  1143 00001C56 1F                  <1> 	pop	ds
  1144 00001C57 BB4200              <1> 	mov	bx,fdc_ctrl_status
  1145 00001C5A 3A6F03              <1> 	cmp	ch,byte [bx+3]		; same result cylinder?
  1146 00001C5D 7508                <1> 	jne	.exit
  1147 00001C5F 3A7704              <1> 	cmp	dh,byte [bx+4]		; same result head?
  1148 00001C62 7503                <1> 	jne	.exit
  1149 00001C64 8A4705              <1> 	mov	al,byte [bx+5]		; result sector number
  1150                              <1> .exit:
  1151 00001C67 88264000            <1> 	mov	byte [fdc_motor_tout],ah  ; motor timeout
  1152 00001C6B 88C3                <1> 	mov	bl,al			; next sector to be transferred
  1153 00001C6D 58                  <1> 	pop	ax
  1154 00001C6E C3                  <1> 	ret
  1155                              <1> 
  1156                              <1> ;========================================================================
  1157                              <1> ; fdc_disk_change - Read disk change line, reset it if active
  1158                              <1> ; Input:
  1159                              <1> ;	AL = drive type
  1160                              <1> ; Output:
  1161                              <1> ;	CF clear if disk not changed
  1162                              <1> ;		AH = 00h - disk not changed
  1163                              <1> ;	CF set if disk changed or on error
  1164                              <1> ;		AH = 06h - disk changed
  1165                              <1> ;		AH = error code
  1166                              <1> ;		AL - trashed
  1167                              <1> ; Note:
  1168                              <1> ;	Motor needs to be turned on before calling this function
  1169                              <1> ;------------------------------------------------------------------------
  1170                              <1> fdc_disk_change:
  1171 00001C6F 53                  <1> 	push	bx
  1172 00001C70 51                  <1> 	push	cx
  1173 00001C71 B400                <1> 	mov	ah,0
  1174 00001C73 3C01                <1> 	cmp	al,type_360
  1175 00001C75 7443                <1> 	je	.exit			; jump if 360K drive (no change line)
  1176 00001C77 3C03                <1> 	cmp	al,type_720
  1177 00001C79 743F                <1> 	je	.exit			; jump if 720K drive (no change line)
  1178                              <1> 
  1179 00001C7B E8F802              <1> 	call	get_media_state
  1180 00001C7E 88D8                <1> 	mov	al,bl			; AL = drive media state
  1181 00001C80 2407                <1> 	and	al,fdc_m_state_bits
  1182 00001C82 7436                <1> 	jz	.exit			; jump if 360K drive (no change line)
  1183 00001C84 3C03                <1> 	cmp	al,3
  1184 00001C86 7432                <1> 	je	.exit			; jump if 360K drive (no change line)
  1185 00001C88 BAF703              <1> 	mov	dx,fdc_dir_reg		; get digital input register address
  1186 00001C8B EC                  <1> 	in	al,dx			; read disk change line
  1187 00001C8C D0E0                <1> 	shl	al,1
  1188 00001C8E 732A                <1> 	jnc	.exit			; no disk change
  1189 00001C90 88D8                <1> 	mov	al,bl			; AL = drive media state
  1190 00001C92 24EF                <1> 	and	al,~fdc_m_established	; media not detected
  1191 00001C94 E8E902              <1> 	call	set_media_state
  1192 00001C97 E8D7FB              <1> 	call	fdc_init		; full initialization
  1193 00001C9A 721E                <1> 	jc	.exit
  1194 00001C9C 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  1195 00001C9F B501                <1> 	mov	ch,1
  1196 00001CA1 E877FE              <1> 	call	fdc_seek		; seek to cylinder 1
  1197 00001CA4 7214                <1> 	jc	.exit
  1198 00001CA6 B500                <1> 	mov	ch,0
  1199 00001CA8 E870FE              <1> 	call	fdc_seek		; seek to cylinder 0
  1200 00001CAB 720D                <1> 	jc	.exit
  1201 00001CAD B406                <1> 	mov	ah,fdc_e_changed
  1202 00001CAF BAF703              <1> 	mov	dx,fdc_dir_reg		; get digital input register address
  1203 00001CB2 EC                  <1> 	in	al,dx			; read disk change line
  1204 00001CB3 D0E0                <1> 	shl	al,1
  1205 00001CB5 7302                <1> 	jnc	.changed_or_error	; jump if disk change line was reset
  1206 00001CB7 B480                <1> 	mov	ah,fdc_e_timeout	; failed: no floppy
  1207                              <1> 
  1208                              <1> .changed_or_error:
  1209 00001CB9 F9                  <1> 	stc
  1210                              <1> 
  1211                              <1> .exit:
  1212 00001CBA 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  1213 00001CBD 59                  <1> 	pop	cx
  1214 00001CBE 5B                  <1> 	pop	bx
  1215 00001CBF C3                  <1> 	ret
  1216                              <1> 
  1217                              <1> ;=========================================================================
  1218                              <1> ; fdc_configure_dma - Configure DMA controller for FDC operation (channel 2)
  1219                              <1> ; Input:
  1220                              <1> ;	AL = DMA mode byte
  1221                              <1> ;		42h - verify (single mode, addr increment, verify, channel 2)
  1222                              <1> ;		46h - read   (single mode, addr increment, write, channel 2)
  1223                              <1> ;		4Ah - write  (single mode, addr increment, read, channel 2)
  1224                              <1> ;	CX = byte count (minus 1)
  1225                              <1> ;	ES:BX -> buffer address for DMA operation (BX is from [BP+int_13_bx])
  1226                              <1> ; Output:
  1227                              <1> ;	CF clear on success
  1228                              <1> ;	CF set if error
  1229                              <1> ;		AH = 08h - DMA overrun
  1230                              <1> ;	AX,BX trashed
  1231                              <1> ; Note:
  1232                              <1> ;	Translates ES:BX to DMA page and base address and configures DMAC
  1233                              <1> ;-------------------------------------------------------------------------
  1234                              <1> fdc_configure_dma:
  1235 00001CC0 52                  <1> 	push	dx
  1236 00001CC1 8B5E0C              <1> 	mov	bx,word [bp+int_13_bx]	; get BX from the stack
  1237 00001CC4 8CC2                <1> 	mov	dx,es			; user's buffer segment
  1238 00001CC6 D1C2                <1> 	rol	dx,1
  1239 00001CC8 D1C2                <1> 	rol	dx,1
  1240 00001CCA D1C2                <1> 	rol	dx,1
  1241 00001CCC D1C2                <1> 	rol	dx,1
  1242 00001CCE 88D4                <1> 	mov	ah,dl			; calculate DMA page number
  1243 00001CD0 80E40F              <1> 	and	ah,0Fh			; AH = page number: bits 19 - 16 of ES
  1244 00001CD3 80E2F0              <1> 	and	dl,0F0h			; DX = DMA offset: bits 15 - 0 of ES
  1245 00001CD6 01DA                <1> 	add	dx,bx			; add user's buffer offset
  1246 00001CD8 80D400              <1> 	adc	ah,0			; increment page number on overflow
  1247                              <1> 
  1248 00001CDB 89D3                <1> 	mov	bx,dx			; check if crossing DMA page boundary:
  1249 00001CDD 01CB                <1> 	add	bx,cx			;   add DMA buffer address to byte count
  1250 00001CDF 7243                <1> 	jc	.dma_boundary		; jump if crossing DMA boundary (64 KiB)
  1251                              <1> 
  1252 00001CE1 FA                  <1> 	cli
  1253 00001CE2 E60B                <1> 	out	dmac_mode_reg,al	; send DMA mode byte
  1254 00001CE4 EB00                <1> 	jmp	$+2
  1255 00001CE6 EB00                <1> 	jmp	$+2
  1256 00001CE8 E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  1257 00001CEA EB00                <1> 	jmp	$+2
  1258 00001CEC EB00                <1> 	jmp	$+2
  1259 00001CEE 88C8                <1> 	mov	al,cl
  1260 00001CF0 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - low byte
  1261 00001CF2 EB00                <1> 	jmp	$+2
  1262 00001CF4 EB00                <1> 	jmp	$+2
  1263 00001CF6 88E8                <1> 	mov	al,ch
  1264 00001CF8 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - high byte
  1265 00001CFA EB00                <1> 	jmp	$+2
  1266 00001CFC EB00                <1> 	jmp	$+2
  1267 00001CFE E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  1268 00001D00 EB00                <1> 	jmp	$+2
  1269 00001D02 EB00                <1> 	jmp	$+2
  1270 00001D04 88D0                <1> 	mov	al,dl
  1271 00001D06 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - low byte
  1272 00001D08 EB00                <1> 	jmp	$+2
  1273 00001D0A EB00                <1> 	jmp	$+2
  1274 00001D0C 88F0                <1> 	mov	al,dh
  1275 00001D0E E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - high byte
  1276 00001D10 EB00                <1> 	jmp	$+2
  1277 00001D12 EB00                <1> 	jmp	$+2
  1278 00001D14 88E0                <1> 	mov	al,ah
  1279 00001D16 E681                <1> 	out	dmapage_ch2_reg,al	; channel 2 page register
  1280 00001D18 EB00                <1> 	jmp	$+2
  1281 00001D1A EB00                <1> 	jmp	$+2
  1282 00001D1C B002                <1> 	mov	al,2
  1283 00001D1E E60A                <1> 	out	dmac_mask_reg,al	; enable DMA channel 2
  1284 00001D20 FB                  <1> 	sti
  1285 00001D21 F8                  <1> 	clc				; CF = 0 - no error
  1286                              <1> 
  1287                              <1> .exit:
  1288 00001D22 5A                  <1> 	pop	dx
  1289 00001D23 C3                  <1> 	ret
  1290                              <1> 
  1291                              <1> .dma_boundary:				; Note: CF is already set
  1292 00001D24 B409                <1> 	mov	ah,fdc_e_boundary
  1293 00001D26 EBFA                <1> 	jmp	.exit
  1294                              <1> 
  1295                              <1> ;=========================================================================
  1296                              <1> ; fdc_send_cmd - Send a command to FDC
  1297                              <1> ; Input:
  1298                              <1> ;	AL = 1st byte of the command
  1299                              <1> ;	AH = 2nd byte of the command
  1300                              <1> ;	SI = 3rd and 4th bytes of the command
  1301                              <1> ;	DI = 5th and 6th bytes of the command
  1302                              <1> ;	BL = 7th byte of the command
  1303                              <1> ;	BH = 8th byte of the command
  1304                              <1> ;	CH = 9th byte of the command
  1305                              <1> ;	CL = command length (number of bytes)
  1306                              <1> ; Output:
  1307                              <1> ;	CF clear if successful
  1308                              <1> ;		AH = 00h - successful completion
  1309                              <1> ;	CF set on error
  1310                              <1> ;		AH = 20h - controller failure
  1311                              <1> ;		AH = 80h - timeout / device not ready
  1312                              <1> ;	AX trashed
  1313                              <1> ;-------------------------------------------------------------------------
  1314                              <1> fdc_send_cmd:
  1315 00001D28 E84900              <1> 	call	fdc_write		; send AL (1st byte)
  1316 00001D2B FEC9                <1> 	dec	cl
  1317 00001D2D 7644                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1318 00001D2F 88E0                <1> 	mov	al,ah
  1319 00001D31 E84000              <1> 	call	fdc_write		; send AH (2nd byte)
  1320 00001D34 FEC9                <1> 	dec	cl
  1321 00001D36 763B                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1322 00001D38 89F0                <1> 	mov	ax,si
  1323 00001D3A E83700              <1> 	call	fdc_write		; send SI / low byte (3th byte)
  1324 00001D3D FEC9                <1> 	dec	cl
  1325 00001D3F 7632                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1326 00001D41 88E0                <1> 	mov	al,ah
  1327 00001D43 E82E00              <1> 	call	fdc_write		; send SI / high byte (4th byte)
  1328 00001D46 FEC9                <1> 	dec	cl
  1329 00001D48 7629                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1330 00001D4A 89F8                <1> 	mov	ax,di
  1331 00001D4C E82500              <1> 	call	fdc_write		; send DI / low byte (5th byte)
  1332 00001D4F FEC9                <1> 	dec	cl
  1333 00001D51 7620                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1334 00001D53 88E0                <1> 	mov	al,ah
  1335 00001D55 E81C00              <1> 	call	fdc_write		; send DI / high byte (6th byte)
  1336 00001D58 FEC9                <1> 	dec	cl
  1337 00001D5A 7617                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1338 00001D5C 88D8                <1> 	mov	al,bl
  1339 00001D5E E81300              <1> 	call	fdc_write		; send BL (7rd byte)
  1340 00001D61 FEC9                <1> 	dec	cl
  1341 00001D63 760E                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1342 00001D65 88F8                <1> 	mov	al,bh
  1343 00001D67 E80A00              <1> 	call	fdc_write		; send BH (8th byte)
  1344 00001D6A FEC9                <1> 	dec	cl
  1345 00001D6C 7605                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1346 00001D6E 88E8                <1> 	mov	al,ch
  1347 00001D70 E80100              <1> 	call	fdc_write		; send CH (9th byte)
  1348                              <1> 
  1349                              <1> .send_cmd_exit:
  1350 00001D73 C3                  <1> 	ret
  1351                              <1> 
  1352                              <1> ;=========================================================================
  1353                              <1> ; fdc_write - Send byte to FDC
  1354                              <1> ; Input:
  1355                              <1> ;	AL = byte to send
  1356                              <1> ; Output:
  1357                              <1> ;	CF clear if successful
  1358                              <1> ;	CF set if timeout
  1359                              <1> ;		AH = 80h - timeout / device not ready
  1360                              <1> ;-------------------------------------------------------------------------
  1361                              <1> fdc_write:
  1362 00001D74 51                  <1> 	push	cx
  1363 00001D75 52                  <1> 	push	dx
  1364 00001D76 50                  <1> 	push	ax
  1365 00001D77 BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
  1366 00001D7A 31C9                <1> 	xor	cx,cx			; busy wait counter
  1367                              <1> 
  1368                              <1> .wait_ready:
  1369 00001D7C EC                  <1> 	in	al,dx			; read fdc_status_reg
  1370 00001D7D A880                <1> 	test	al,fdc_stat_ready	; exit loop if FDC is ready
  1371 00001D7F 7508                <1> 	jnz	.fdc_ready
  1372 00001D81 E2F9                <1> 	loop	.wait_ready
  1373 00001D83 58                  <1> 	pop	ax
  1374 00001D84 B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1375 00001D86 F9                  <1> 	stc				; indicate error
  1376 00001D87 EB08                <1> 	jmp	.exit
  1377                              <1> 
  1378                              <1> .fdc_ready:
  1379 00001D89 A860                <1> 	test	al,fdc_stat_dir|fdc_stat_dma ; check that DIR and DMA flags are 0
  1380 00001D8B 7507                <1> 	jnz	.failure		; FDC failure if they are set
  1381 00001D8D 58                  <1> 	pop	ax
  1382 00001D8E 42                  <1> 	inc	dx			; DX = fdc_data_reg = fdc_status_reg + 1
  1383 00001D8F EE                  <1> 	out	dx,al			; write byte
  1384 00001D90 F8                  <1> 	clc				; no error
  1385                              <1> 
  1386                              <1> .exit:
  1387 00001D91 5A                  <1> 	pop	dx
  1388 00001D92 59                  <1> 	pop	cx
  1389 00001D93 C3                  <1> 	ret
  1390                              <1> 
  1391                              <1> .failure:
  1392 00001D94 58                  <1> 	pop	ax
  1393 00001D95 B420                <1> 	mov	ah,fdc_e_failure	; FDC failure
  1394 00001D97 F9                  <1> 	stc
  1395 00001D98 EBF7                <1> 	jmp	.exit
  1396                              <1> 
  1397                              <1> ;=========================================================================
  1398                              <1> ; fdc_get_result - Read FDC result
  1399                              <1> ; Input:
  1400                              <1> ;	none
  1401                              <1> ; Output:
  1402                              <1> ;	CF clear if successful
  1403                              <1> ;		AH = 00h - operation successful
  1404                              <1> ;		Result is returned in fdc_ctrl_status BIOS area
  1405                              <1> ;	CF set on error
  1406                              <1> ;		AH = 20h - controller failure
  1407                              <1> ;		AH = 80h - timeout / device not ready
  1408                              <1> ;	AL,BX - trashed
  1409                              <1> ;-------------------------------------------------------------------------
  1410                              <1> fdc_get_result:
  1411 00001D9A 51                  <1> 	push	cx
  1412 00001D9B 52                  <1> 	push	dx
  1413 00001D9C BB4200              <1> 	mov	bx,fdc_ctrl_status
  1414 00001D9F BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
  1415                              <1> 
  1416                              <1> .next_byte:
  1417 00001DA2 31C9                <1>         xor     cx,cx			; busy wait counter
  1418                              <1> 
  1419                              <1> .wait_ready:
  1420 00001DA4 EC                  <1> 	in	al,dx			; read fdc_status_reg
  1421 00001DA5 A880                <1> 	test	al,fdc_stat_ready	; exit loop if FDC is ready
  1422 00001DA7 7507                <1> 	jnz	.fdc_ready
  1423 00001DA9 E2F9                <1> 	loop	.wait_ready
  1424 00001DAB B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1425 00001DAD F9                  <1> 	stc				; indicate error
  1426 00001DAE EB19                <1> 	jmp	.exit
  1427                              <1> 
  1428                              <1> .fdc_ready:
  1429 00001DB0 2470                <1> 	and	al,fdc_stat_dir|fdc_stat_dma|fdc_stat_busy
  1430 00001DB2 A8EF                <1> 	test	al,~fdc_stat_busy	; controller finished sending result?
  1431 00001DB4 7411                <1> 	je	.done
  1432 00001DB6 3C50                <1> 	cmp	al,fdc_stat_dir|fdc_stat_busy
  1433 00001DB8 7512                <1> 	jne	.failure		; invalid FDC status, indicate FDC failure
  1434 00001DBA 83FB49              <1> 	cmp	bx,fdc_ctrl_status+7	; already read 7 bytes?
  1435 00001DBD 730D                <1> 	jnb	.failure		; controller error if so
  1436 00001DBF 42                  <1> 	inc	dx			; DX = fdc_data_reg = fdc_status_reg + 1
  1437 00001DC0 EC                  <1> 	in	al,dx
  1438 00001DC1 8807                <1> 	mov	byte [bx],al
  1439 00001DC3 43                  <1> 	inc	bx
  1440 00001DC4 4A                  <1> 	dec	dx			; DX = fdc_status_reg = fdc_data_reg - 1
  1441 00001DC5 EBDB                <1> 	jmp	.next_byte
  1442                              <1> 
  1443                              <1> .done:
  1444 00001DC7 30E4                <1> 	xor	ah,ah			; operation successful
  1445                              <1> 
  1446                              <1> .exit:
  1447 00001DC9 5A                  <1> 	pop	dx
  1448 00001DCA 59                  <1> 	pop	cx
  1449 00001DCB C3                  <1> 	ret
  1450                              <1> 
  1451                              <1> .failure:
  1452 00001DCC B420                <1> 	mov	ah,fdc_e_failure
  1453 00001DCE F9                  <1> 	stc
  1454 00001DCF EBF8                <1> 	jmp	.exit
  1455                              <1> 
  1456                              <1> ;=========================================================================
  1457                              <1> ; fdc_read - Read byte from FDC
  1458                              <1> ; Input:
  1459                              <1> ;	none
  1460                              <1> ; Output:
  1461                              <1> ;	CF clear if successful
  1462                              <1> ;		AL = byte read from FDC
  1463                              <1> ;		AH - unchanged
  1464                              <1> ;	CF set on error
  1465                              <1> ;		AH = 20h - controller failure
  1466                              <1> ;		AH = 80h - timeout / device not ready
  1467                              <1> ;-------------------------------------------------------------------------
  1468                              <1> fdc_read:
  1469 00001DD1 51                  <1> 	push	cx
  1470 00001DD2 52                  <1> 	push	dx
  1471 00001DD3 BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
  1472 00001DD6 31C9                <1>         xor     cx,cx			; busy wait counter
  1473                              <1> 
  1474                              <1> .wait_ready:
  1475 00001DD8 EC                  <1> 	in	al,dx			; read fdc_status_reg
  1476 00001DD9 A880                <1> 	test	al,fdc_stat_ready	; exit loop if FDC is ready
  1477 00001DDB 7507                <1> 	jnz	.fdc_ready
  1478 00001DDD E2F9                <1> 	loop	.wait_ready
  1479 00001DDF B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1480 00001DE1 F9                  <1> 	stc				; indicate error
  1481 00001DE2 EB08                <1> 	jmp	.exit
  1482                              <1> 
  1483                              <1> .fdc_ready:
  1484 00001DE4 EC                  <1> 	in	al,dx
  1485 00001DE5 A840                <1> 	test	al,fdc_stat_dir		; FDC is ready to send a byte? 
  1486 00001DE7 7406                <1> 	jz	.failure		; jump if not ready
  1487                              <1> ;	jmp	short $+2		; I/O delay
  1488                              <1> ;	jmp	short $+2
  1489 00001DE9 42                  <1> 	inc	dx			; DX = fdc_data_reg = fdc_status_reg + 1
  1490 00001DEA EC                  <1> 	in	al,dx			; read the byte
  1491 00001DEB F8                  <1> 	clc				; no error
  1492                              <1> 
  1493                              <1> .exit:
  1494 00001DEC 5A                  <1> 	pop	dx
  1495 00001DED 59                  <1> 	pop	cx
  1496 00001DEE C3                  <1> 	ret
  1497                              <1> 
  1498                              <1> .failure:
  1499 00001DEF B420                <1> 	mov	ah,fdc_e_failure
  1500 00001DF1 F9                  <1> 	stc
  1501 00001DF2 EBF8                <1> 	jmp	.exit
  1502                              <1> 
  1503                              <1> ;=========================================================================
  1504                              <1> ; fdc_get_error - Translate FDC status to BIOS error number
  1505                              <1> ; Input:
  1506                              <1> ;	DS:[fdc_ctrl_status] - FDC status bytes
  1507                              <1> ; Output:
  1508                              <1> ;	AH = error code
  1509                              <1> ;-------------------------------------------------------------------------
  1510                              <1> fdc_get_error:
  1511 00001DF4 8B1E4200            <1> 	mov	bx,word [fdc_ctrl_status]
  1512 00001DF8 F6C3C0              <1> 	test	bl,0C0h			; BL = ST1
  1513 00001DFB B400                <1> 	mov	ah,fdc_e_success
  1514 00001DFD 7433                <1> 	jz	.exit			; jump if successful completion
  1515 00001DFF F6C340              <1> 	test	bl,40h			; abnormal termination?
  1516 00001E02 B420                <1> 	mov	ah,fdc_e_failure
  1517 00001E04 742C                <1> 	jz	.exit
  1518 00001E06 F6C701              <1> 	test	bh,1			; address mark not found?
  1519 00001E09 B402                <1> 	mov	ah,fdc_e_address
  1520 00001E0B 7525                <1> 	jnz	.exit
  1521 00001E0D F6C702              <1> 	test	bh,2			; disk write protected?
  1522 00001E10 B403                <1> 	mov	ah,fdc_e_wprotect
  1523 00001E12 751E                <1> 	jnz	.exit
  1524 00001E14 F6C704              <1> 	test	bh,4			; sector not found?
  1525 00001E17 B404                <1> 	mov	ah,fdc_e_notfound
  1526 00001E19 7517                <1> 	jnz	.exit
  1527 00001E1B F6C710              <1> 	test	bh,10H			; DMA overrun?
  1528 00001E1E B408                <1> 	mov	ah,fdc_e_dma
  1529 00001E20 7510                <1> 	jnz	.exit
  1530 00001E22 F6C720              <1> 	test	bh,20H			; CRC error?
  1531 00001E25 B410                <1> 	mov	ah,fdc_e_crc
  1532 00001E27 7509                <1> 	jnz	.exit
  1533 00001E29 F6C780              <1> 	test	bh,80h			; access after last sector?
  1534 00001E2C B404                <1> 	mov	ah,fdc_e_notfound
  1535 00001E2E 7502                <1> 	jnz	.exit
  1536 00001E30 B420                <1> 	mov	ah,fdc_e_failure	; return FDC failure for other errors
  1537                              <1> 
  1538                              <1> .exit:
  1539 00001E32 C3                  <1> 	ret
  1540                              <1> 
  1541                              <1> ;=========================================================================
  1542                              <1> ; fdc_reset - Reset FDC
  1543                              <1> ; Input:
  1544                              <1> ;	none
  1545                              <1> ; Output:
  1546                              <1> ;	Resets FDC flags in BIOS area
  1547                              <1> ;	AX,CX,DX - trashed 
  1548                              <1> ;-------------------------------------------------------------------------
  1549                              <1> fdc_reset:
  1550 00001E33 FA                  <1> 	cli
  1551 00001E34 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  1552 00001E39 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; clear the write bit
  1553 00001E3E A03F00              <1> 	mov	al,byte [fdc_motor_state] ; AL = motor state byte
  1554 00001E41 24BF                <1> 	and	al,0BFh			; clear bit 6 - reset
  1555 00001E43 50                  <1> 	push	ax			; set_fdc_dor trashes AX, save it
  1556 00001E44 E82001              <1> 	call	set_fdc_dor
  1557 00001E47 58                  <1> 	pop	ax
  1558 00001E48 B90300              <1> 	mov	cx,3
  1559 00001E4B E84AF8              <1> 	call	delay_15us		; 30-45 us delay
  1560 00001E4E 0C40                <1> 	or	al,40h			; set bit 6 - no reset
  1561 00001E50 E81401              <1> 	call	set_fdc_dor
  1562 00001E53 FB                  <1> 	sti
  1563 00001E54 E8E800              <1> 	call	fdc_wait_irq		; wait for IRQ
  1564 00001E57 7207                <1> 	jc	.exit
  1565 00001E59 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  1566 00001E5E 30E4                <1> 	xor	ah,ah			; no errors
  1567                              <1> .exit:
  1568 00001E60 C3                  <1> 	ret
  1569                              <1> 
  1570                              <1> ;=========================================================================
  1571                              <1> ; fdc_detect_media - Detect media type, update it in fdc_media_state[drive]
  1572                              <1> ; Input:
  1573                              <1> ;	[BP+int_13_dl] = drive number
  1574                              <1> ; Output:
  1575                              <1> ;	CF clear if successful
  1576                              <1> ;		AH = 00h
  1577                              <1> ;	CF set on error
  1578                              <1> ;		AH = 20h - invalid drive type
  1579                              <1> ;-------------------------------------------------------------------------
  1580                              <1> fdc_detect_media:
  1581 00001E61 52                  <1> 	push	dx
  1582 00001E62 51                  <1> 	push	cx
  1583                              <1> 
  1584 00001E63 B420                <1> 	mov	ah,fdc_e_failure	; in case the get_drive_type fails
  1585 00001E65 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; restore DL in case it was trashed
  1586 00001E68 E86B01              <1> 	call	get_drive_type		; get drive type to AL
  1587 00001E6B 726B                <1> 	jc	.exit			; drive doesn't exist or invalid type
  1588                              <1> 
  1589 00001E6D 3C03                <1> 	cmp	al,type_720
  1590 00001E6F 7410                <1> 	je	.set_720
  1591 00001E71 3C02                <1> 	cmp	al,type_1200
  1592 00001E73 7415                <1> 	je	.detect_1200
  1593 00001E75 3C04                <1> 	cmp	al,type_1440
  1594 00001E77 7427                <1> 	je	.detect_1440
  1595 00001E79 3C06                <1> 	cmp	al,type_2880
  1596 00001E7B 7439                <1> 	je	.detect_2880
  1597                              <1> 
  1598 00001E7D B093                <1> 	mov	al,fdc_m_360in360	; set 360K disk in 360K drive
  1599 00001E7F EB02                <1> 	jmp	.set_rate
  1600                              <1> 
  1601                              <1> .set_720:
  1602 00001E81 B097                <1> 	mov	al,fdc_m_720
  1603                              <1> 
  1604                              <1> .set_rate:
  1605 00001E83 50                  <1> 	push	ax
  1606 00001E84 E89F00              <1> 	call	fdc_set_rate		; transfer rate in AL
  1607 00001E87 58                  <1> 	pop	ax
  1608 00001E88 EB49                <1> 	jmp	.exit_set_media
  1609                              <1> 
  1610                              <1> .detect_1200:
  1611 00001E8A B000                <1> 	mov	al,0			; try 500 Kbps
  1612 00001E8C E85000              <1> 	call	fdc_read_id
  1613 00001E8F B015                <1> 	mov	al,fdc_m_1200in1200
  1614 00001E91 7340                <1> 	jnc	.exit_set_media		; jump if successful
  1615 00001E93 B040                <1> 	mov	al,40h			; try 300 Kbps
  1616 00001E95 E84700              <1> 	call	fdc_read_id
  1617 00001E98 B074                <1> 	mov	al,fdc_m_360in1200
  1618 00001E9A 7337                <1> 	jnc	.exit_set_media		; jump if successful
  1619 00001E9C B002                <1> 	mov	al,fdc_m_try_1200in1200
  1620 00001E9E EB33                <1> 	jmp	.exit_set_media
  1621                              <1> 
  1622                              <1> .detect_1440:
  1623 00001EA0 B000                <1> 	mov	al,0			; try 500 Kbps
  1624 00001EA2 E83A00              <1> 	call	fdc_read_id
  1625 00001EA5 B017                <1> 	mov	al,fdc_m_1440
  1626 00001EA7 732A                <1> 	jnc	.exit_set_media		; jump if successful
  1627 00001EA9 B080                <1> 	mov	al,80h			; try 250 Kbps
  1628 00001EAB E83100              <1> 	call	fdc_read_id
  1629 00001EAE B097                <1> 	mov	al,fdc_m_720
  1630 00001EB0 7321                <1> 	jnc	.exit_set_media		; jump if successful
  1631 00001EB2 B007                <1> 	mov	al,fdc_m_try_1440
  1632 00001EB4 EB1D                <1> 	jmp	.exit_set_media
  1633                              <1> 
  1634                              <1> .detect_2880:
  1635 00001EB6 B0C0                <1> 	mov	al,0C0h			; try 1 Mbps
  1636 00001EB8 E82400              <1> 	call	fdc_read_id
  1637 00001EBB B0D7                <1> 	mov	al,fdc_m_2880
  1638 00001EBD 7314                <1> 	jnc	.exit_set_media		; jump if successful
  1639 00001EBF B000                <1> 	mov	al,0			; try 500 Kbps
  1640 00001EC1 E81B00              <1> 	call	fdc_read_id
  1641 00001EC4 B017                <1> 	mov	al,fdc_m_1440
  1642 00001EC6 730B                <1> 	jnc	.exit_set_media		; jump if successful
  1643 00001EC8 B080                <1> 	mov	al,80h			; try 250 Kbps
  1644 00001ECA E81200              <1> 	call	fdc_read_id
  1645 00001ECD B097                <1> 	mov	al,fdc_m_720
  1646 00001ECF 7302                <1> 	jnc	.exit_set_media		; jump_if successful
  1647 00001ED1 B0C7                <1> 	mov	al,fdc_m_try_2880
  1648                              <1> 
  1649                              <1> .exit_set_media:
  1650 00001ED3 E8AA00              <1> 	call	set_media_state		; set media state
  1651 00001ED6 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
  1652                              <1> .exit:
  1653 00001ED8 88264100            <1> 	mov	byte [fdc_last_error],ah
  1654 00001EDC 59                  <1> 	pop	cx
  1655 00001EDD 5A                  <1> 	pop	dx
  1656 00001EDE C3                  <1> 	ret
  1657                              <1> 
  1658                              <1> ;=========================================================================
  1659                              <1> ; fdc_read_id - Read ID
  1660                              <1> ; Input:
  1661                              <1> ;	[BP+int_13_dl] = drive number
  1662                              <1> ; Output:
  1663                              <1> ;	CF clear if successful
  1664                              <1> ;		AH = 0 - successful completion
  1665                              <1> ;		AL = ID (bits 7-6)
  1666                              <1> ;	CF set on error
  1667                              <1> ;		AH = error code
  1668                              <1> ;	AX,CX - trashed
  1669                              <1> ;-------------------------------------------------------------------------
  1670                              <1> fdc_read_id:
  1671 00001EDF 53                  <1> 	push	bx
  1672 00001EE0 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh ; set timeout to maximum
  1673 00001EE5 E83E00              <1> 	call	fdc_set_rate		; transfer rate in AL
  1674 00001EE8 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]
  1675 00001EEB E8DBFB              <1> 	call	fdc_recalibrate		; recalibrate
  1676 00001EEE 7305                <1> 	jnc	.do_read_id
  1677 00001EF0 E8D6FB              <1> 	call	fdc_recalibrate		; second attempt
  1678 00001EF3 722E                <1> 	jc	.error
  1679                              <1> 
  1680                              <1> .do_read_id:
  1681 00001EF5 B90300              <1> 	mov	cx,3			; 3 attempts
  1682                              <1> 
  1683                              <1> .read_id_loop:
  1684 00001EF8 51                  <1> 	push	cx
  1685 00001EF9 B04A                <1> 	mov	al,4Ah			; FDC Read ID command
  1686                              <1> ; FIXME - does drive number in DL gets to here?
  1687                              <1> ;	mov	ah,dl			; read id - byte 1 (head = 0 / drive)
  1688 00001EFB 8A6608              <1> 	mov	ah,byte [bp+int_13_dl]	; read id - byte 1 (head = 0 / drive)
  1689 00001EFE B102                <1> 	mov	cl,2			; 2 byte commands
  1690 00001F00 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  1691 00001F05 E820FE              <1> 	call	fdc_send_cmd
  1692 00001F08 7218                <1> 	jc	.error_cmd
  1693 00001F0A E83200              <1> 	call	fdc_wait_irq		; wait for IRQ6
  1694 00001F0D 7213                <1> 	jc	.error_cmd		; timeout waiting for interrupt
  1695 00001F0F B107                <1> 	mov	cl,7
  1696 00001F11 E886FE              <1> 	call	fdc_get_result		; read result bytes
  1697 00001F14 720C                <1> 	jc	.error_cmd
  1698 00001F16 E8DBFE              <1> 	call	fdc_get_error		; get error code
  1699 00001F19 59                  <1> 	pop	cx
  1700 00001F1A 08E4                <1> 	or	ah,ah
  1701 00001F1C 7406                <1> 	jz	.exit			; if no errors
  1702 00001F1E E2D8                <1> 	loop	.read_id_loop		; retry
  1703 00001F20 EB01                <1> 	jmp	.error
  1704                              <1> 
  1705                              <1> .error_cmd:
  1706 00001F22 59                  <1> 	pop	cx
  1707                              <1> 
  1708                              <1> .error:
  1709 00001F23 F9                  <1> 	stc
  1710                              <1> 
  1711                              <1> .exit:
  1712 00001F24 5B                  <1> 	pop	bx
  1713 00001F25 C3                  <1> 	ret
  1714                              <1> 
  1715                              <1> ;=========================================================================
  1716                              <1> ; fdc_set_rate - Set transfer rate
  1717                              <1> ; Input:
  1718                              <1> ;	AL = transfer rate (bits 7 and 6)
  1719                              <1> ;		00h - 500 Kbps (1.2M and 1.44M disks)
  1720                              <1> ;		40h - 300 Kbps (360K disk in 1.2M drive)
  1721                              <1> ;		80h - 250 Kbps (360K disk in 360K drive, or 720K disk)
  1722                              <1> ;		0C0h - 1 Mbps (2.88M disks)
  1723                              <1> ; Output:
  1724                              <1> ;	none
  1725                              <1> ;-------------------------------------------------------------------------
  1726                              <1> fdc_set_rate:
  1727 00001F26 50                  <1> 	push	ax
  1728 00001F27 24C0                <1> 	and	al,fdc_m_rate_bits	; get the data rate bits only
  1729 00001F29 80268B003F          <1> 	and	byte [fdc_last_rate],~fdc_m_rate_bits ; clear rate bits
  1730 00001F2E 08068B00            <1> 	or	byte [fdc_last_rate],al	; set new rate bits
  1731 00001F32 D0C0                <1> 	rol	al,1
  1732 00001F34 D0C0                <1> 	rol	al,1
  1733 00001F36 BAF703              <1> 	mov	dx,fdc_ccr_reg		; get control configuration register address
  1734 00001F39 EE                  <1> 	out	dx,al
  1735 00001F3A 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  1736 00001F3D 58                  <1> 	pop	ax
  1737 00001F3E C3                  <1> 	ret
  1738                              <1> 
  1739                              <1> ;=========================================================================
  1740                              <1> ; fdc_wait_irq - Wait for FDC interrupt for 2 seconds
  1741                              <1> ; Input:
  1742                              <1> ;	none
  1743                              <1> ; Output:
  1744                              <1> ;	CF clear if interrupt had occurred
  1745                              <1> ;		AH = 00h - successful completion
  1746                              <1> ;	CF set if no interrupt
  1747                              <1> ;		AH = 80h - timeout
  1748                              <1> ;	BX = fdc_calib_state
  1749                              <1> ;	AL - trashed
  1750                              <1> ;-------------------------------------------------------------------------
  1751                              <1> fdc_wait_irq:
  1752 00001F3F 51                  <1> 	push	cx
  1753 00001F40 FB                  <1> 	sti
  1754 00001F41 F8                  <1> 	clc
  1755 00001F42 B80190              <1> 	mov	ax,9001h
  1756 00001F45 CD15                <1> 	int	15h			; call OS hook
  1757 00001F47 7212                <1> 	jc	.timeout
  1758 00001F49 BB3E00              <1> 	mov	bx,fdc_calib_state	; contains IRQ flag
  1759 00001F4C 31C9                <1> 	xor	cx,cx
  1760                              <1> 
  1761                              <1> %ifdef AT_DELAY
  1762                              <1> 
  1763                              <1> .zero_loop:
  1764                              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  1765                              <1> 	jnz	.exit			; exit loop if interrupt had occurred
  1766                              <1> 	in	al,ppi_pb_reg
  1767                              <1> 	test	al,refresh_flag
  1768                              <1> 	jz	.zero_loop		; wait 15.09 us
  1769                              <1> 	loop	.one_loop		; DEC CX; JNZ .one_loop
  1770                              <1> 	jmp	.timeout
  1771                              <1> 
  1772                              <1> .one_loop:
  1773                              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  1774                              <1> 	jnz	.exit			; exit loop if interrupt had occurred
  1775                              <1> 	in	al,ppi_pb_reg
  1776                              <1> 	test	al,refresh_flag
  1777                              <1> 	jnz	.one_loop		; wait 15.09 us
  1778                              <1> 	loop	.zero_loop		; DEC CX; JNZ .zero_loop
  1779                              <1> 
  1780                              <1> %else ; AT_DELAY
  1781                              <1> 
  1782                              <1> .1:
  1783                              <1> 	; wait 38.13 us (Intel 8088 CPU running on 4.77 MHz)
  1784 00001F4E B00A                <1> 	mov	al,10
  1785                              <1> .2:
  1786 00001F50 F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  1787 00001F53 750B                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  1788 00001F55 FEC8                <1> 	dec	al
  1789 00001F57 75F7                <1> 	jnz	.2
  1790 00001F59 E2F3                <1> 	loop	.1
  1791                              <1> 
  1792                              <1> %endif ; AT_DELAY
  1793                              <1> 
  1794                              <1> .timeout:
  1795 00001F5B B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1796 00001F5D F9                  <1> 	stc
  1797 00001F5E 59                  <1> 	pop	cx
  1798 00001F5F C3                  <1> 	ret
  1799                              <1> 
  1800                              <1> .exit:
  1801 00001F60 80277F              <1> 	and	byte [bx],~fdc_irq_flag	; clear IRQ flag
  1802 00001F63 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
  1803 00001F65 59                  <1> 	pop	cx
  1804 00001F66 C3                  <1> 	ret
  1805                              <1> 
  1806                              <1> ;=========================================================================
  1807                              <1> ; set_fdc_dor - set FDC Digital Output Register - DOR
  1808                              <1> ; Input:
  1809                              <1> ;	AL = new motor state
  1810                              <1> ; Output:
  1811                              <1> ;	AL, DX trashed
  1812                              <1> ;-------------------------------------------------------------------------
  1813                              <1> set_fdc_dor:
  1814 00001F67 D0C8                <1> 	ror	al,1
  1815 00001F69 D0C8                <1> 	ror	al,1
  1816 00001F6B D0C8                <1> 	ror	al,1
  1817 00001F6D D0C8                <1> 	ror	al,1
  1818 00001F6F 0C08                <1> 	or	al,08h			; DMA+IRQ enabled
  1819 00001F71 BAF203              <1> 	mov	dx,fdc_dor_reg		; get digital output register address
  1820 00001F74 EE                  <1> 	out	dx,al			; send the state to FDC
  1821 00001F75 C3                  <1> 	ret
  1822                              <1> 
  1823                              <1> ;=========================================================================
  1824                              <1> ; get_media_state - Get drive's media state from the data area
  1825                              <1> ; Input:
  1826                              <1> ;	[BP+int_13_dl] = drive number
  1827                              <1> ; Output:
  1828                              <1> ;	BL = drive's media state
  1829                              <1> ;	BH = 0 (destroyed)
  1830                              <1> ;-------------------------------------------------------------------------
  1831                              <1> get_media_state:
  1832 00001F76 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1833 00001F79 B700                <1> 	mov	bh,0			; BX = drive number
  1834 00001F7B 8A9F9000            <1> 	mov	bl,byte [fdc_media_state+bx]
  1835 00001F7F C3                  <1> 	ret
  1836                              <1> 
  1837                              <1> ;=========================================================================
  1838                              <1> ; set_media_state - Store drive's media state in the data area
  1839                              <1> ; Input:
  1840                              <1> ;	AL = media state
  1841                              <1> ;	[BP+int_13_dl] = drive number
  1842                              <1> ; Output:
  1843                              <1> ;	none
  1844                              <1> ;-------------------------------------------------------------------------
  1845                              <1> set_media_state:
  1846 00001F80 53                  <1> 	push	bx
  1847 00001F81 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1848 00001F84 B700                <1> 	mov	bh,0			; BX = drive number
  1849 00001F86 88879000            <1> 	mov	byte [fdc_media_state+bx],al
  1850 00001F8A 5B                  <1> 	pop	bx
  1851 00001F8B C3                  <1> 	ret
  1852                              <1> 
  1853                              <1> ;=========================================================================
  1854                              <1> ; check_cylinder - Compare specified cylinder with value in the BIOS data area
  1855                              <1> ; Input:
  1856                              <1> ;	CH = current cylinder
  1857                              <1> ;	[BP+int_13_dl] = drive number
  1858                              <1> ; Output:
  1859                              <1> ;	ZF = 1 - cylinder matches
  1860                              <1> ;-------------------------------------------------------------------------
  1861                              <1> check_cylinder:
  1862 00001F8C 53                  <1> 	push	bx
  1863 00001F8D 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1864 00001F90 B700                <1> 	mov	bh,0			; BX = drive number
  1865 00001F92 38AF9400            <1> 	cmp	byte [fdc_cylinder+bx],ch
  1866 00001F96 5B                  <1> 	pop	bx
  1867 00001F97 C3                  <1> 	ret
  1868                              <1> 
  1869                              <1> ;=========================================================================
  1870                              <1> ; set_cylinder - Store drive's current cylinder into the BIOS data area
  1871                              <1> ; Input:
  1872                              <1> ;	CH = current cylinder
  1873                              <1> ;	[BP+int_13_dl] = drive number
  1874                              <1> ; Output:
  1875                              <1> ;	none
  1876                              <1> ;-------------------------------------------------------------------------
  1877                              <1> set_cylinder:
  1878 00001F98 53                  <1> 	push	bx
  1879 00001F99 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1880 00001F9C B700                <1> 	mov	bh,0			; BX = drive number
  1881 00001F9E 88AF9400            <1> 	mov	byte [fdc_cylinder+bx],ch
  1882 00001FA2 5B                  <1> 	pop	bx
  1883 00001FA3 C3                  <1> 	ret
  1884                              <1> 
  1885                              <1> ;=========================================================================
  1886                              <1> ; check_drive_calibrated - Check if the drive calibrated bit is set
  1887                              <1> ;			   in the BIOS data area
  1888                              <1> ; Input:
  1889                              <1> ;	[BP+int_13_dl] = drive number
  1890                              <1> ; Output:
  1891                              <1> ;	CF = 1 - bit set (drive calibrated)
  1892                              <1> ;-------------------------------------------------------------------------
  1893                              <1> check_drive_calibrated:
  1894 00001FA4 51                  <1> 	push	cx
  1895 00001FA5 8A2E3E00            <1> 	mov	ch,byte [fdc_calib_state] ; calibration state for primary FDC
  1896 00001FA9 8A4E08              <1> 	mov	cl,byte [bp+int_13_dl]	; CL = drive number
  1897 00001FAC FEC1                <1> 	inc	cl
  1898 00001FAE D2ED                <1> 	shr	ch,cl			; set CF if drive is calibrated
  1899 00001FB0 59                  <1> 	pop	cx
  1900 00001FB1 C3                  <1> 	ret
  1901                              <1> 
  1902                              <1> ;=========================================================================
  1903                              <1> ; set_drive_calibrated - Set drive calibrated bit in the BIOS data area
  1904                              <1> ; Input:
  1905                              <1> ;	[BP+int_13_dl] = drive number
  1906                              <1> ; Output:
  1907                              <1> ;	none
  1908                              <1> ;-------------------------------------------------------------------------
  1909                              <1> set_drive_calibrated:
  1910 00001FB2 51                  <1> 	push	cx
  1911 00001FB3 8A4E08              <1> 	mov	cl,byte [bp+int_13_dl]	; CL = drive number
  1912 00001FB6 B501                <1> 	mov	ch,1			; bit 0 set
  1913 00001FB8 D2E5                <1> 	shl	ch,cl			; move it into the right position
  1914 00001FBA 082E3E00            <1> 	or	byte [fdc_calib_state],ch ; set the bit for the primary FDC
  1915 00001FBE 59                  <1> 	pop	cx
  1916 00001FBF C3                  <1> 	ret
  1917                              <1> 
  1918                              <1> ;=========================================================================
  1919                              <1> ; detect_floppy - Detect floppy configuration
  1920                              <1> ;                 set equipment bits accordingly
  1921                              <1> ; Input:
  1922                              <1> ;	none
  1923                              <1> ; Ouput:
  1924                              <1> ;	AL = NVRAM floppy configuration byte
  1925                              <1> ;-------------------------------------------------------------------------
  1926                              <1> detect_floppy:
  1927                              <1> %ifdef BIOS_SETUP
  1928 00001FC0 E823F0              <1> 	call	get_floppy
  1929                              <1> %else ; BIOS_SETUP
  1930                              <1> 	mov	al,DEFAULT_FLOPPIES	
  1931                              <1> %endif ; BIOS_SETUP
  1932 00001FC3 3C00                <1> 	cmp	al,00h			; No floppy drives?
  1933 00001FC5 740E                <1> 	je	.exit
  1934 00001FC7 800E100001          <1> 	or	byte [equipment_list],equip_floppies
  1935 00001FCC A80F                <1> 	test	al,0Fh			; Second floppy drive installed?
  1936 00001FCE 7405                <1> 	jz	.exit
  1937 00001FD0 800E100040          <1> 	or	byte [equipment_list],equip_floppy2
  1938                              <1> .exit:
  1939 00001FD5 C3                  <1> 	ret
  1940                              <1> 
  1941                              <1> ;=========================================================================
  1942                              <1> ; get_drive_type - Read drive type from NVRAM or Flash ROM configuration
  1943                              <1> ; Input:
  1944                              <1> ;	DL = drive number (0 or 1)
  1945                              <1> ; Output:
  1946                              <1> ;	CF clear if successful
  1947                              <1> ;		AL = drive type
  1948                              <1> ;	CF set on error (invalid drive type)
  1949                              <1> ;=========================================================================
  1950                              <1> 
  1951                              <1> get_drive_type:
  1952                              <1> %ifdef BIOS_SETUP
  1953 00001FD6 E80DF0              <1> 	call	get_floppy
  1954                              <1> %else ; BIOS_SETUP
  1955                              <1> 	mov	al,DEFAULT_FLOPPIES
  1956                              <1> %endif ; BIOS_SETUP
  1957 00001FD9 08D2                <1> 	or	dl,dl			; drive 0?
  1958 00001FDB 7508                <1> 	jnz	.drive_1		; jump if drive 1 - type in bits 3-0
  1959 00001FDD D0E8                <1> 	shr	al,1			; shift drive 0 bits 7-4 to 3-0
  1960 00001FDF D0E8                <1> 	shr	al,1
  1961 00001FE1 D0E8                <1> 	shr	al,1
  1962 00001FE3 D0E8                <1> 	shr	al,1
  1963                              <1> .drive_1:
  1964 00001FE5 240F                <1> 	and	al,0Fh			; mask drive bits
  1965 00001FE7 3C00                <1> 	cmp	al,type_none
  1966 00001FE9 740A                <1> 	je	.error
  1967 00001FEB 3C05                <1> 	cmp	al,5			; invalid value
  1968 00001FED 7406                <1> 	je	.error
  1969 00001FEF 3C06                <1> 	cmp	al,type_2880
  1970 00001FF1 7702                <1> 	ja	.error
  1971 00001FF3 F8                  <1> 	clc
  1972 00001FF4 C3                  <1> 	ret
  1973                              <1> 
  1974                              <1> .error:
  1975 00001FF5 F9                  <1> 	stc
  1976 00001FF6 C3                  <1> 	ret
  1977                              <1> 
  1978                              <1> ;=========================================================================
  1979                              <1> ; print_floppy - Print floppy configuration
  1980                              <1> ; Input:
  1981                              <1> ;	AL = NVRAM floppy configuration byte
  1982                              <1> ; Ouput:
  1983                              <1> ;	none
  1984                              <1> ;-------------------------------------------------------------------------
  1985                              <1> print_floppy:
  1986 00001FF7 50                  <1> 	push	ax
  1987 00001FF8 56                  <1> 	push	si
  1988 00001FF9 BE[A502]            <1> 	mov	si,msg_floppy
  1989 00001FFC E87108              <1> 	call	print
  1990 00001FFF D0C8                <1> 	ror	al,1
  1991 00002001 D0C8                <1> 	ror	al,1
  1992 00002003 D0C8                <1> 	ror	al,1
  1993 00002005 D0C8                <1> 	ror	al,1
  1994 00002007 89C6                <1> 	mov	si,ax
  1995 00002009 83E607              <1> 	and	si,0007h
  1996 0000200C D1E6                <1> 	shl	si,1
  1997 0000200E 2E8BB4[3A0A]        <1>     cs	mov	si,word [tbl_floppy+si]
  1998 00002013 E85A08              <1> 	call	print
  1999 00002016 BE[CB02]            <1> 	mov	si,msg_floppy_2
  2000 00002019 E85408              <1> 	call	print
  2001 0000201C D0C8                <1> 	ror	al,1
  2002 0000201E D0C8                <1> 	ror	al,1
  2003 00002020 D0C8                <1> 	ror	al,1
  2004 00002022 D0C8                <1> 	ror	al,1
  2005 00002024 89C6                <1> 	mov	si,ax
  2006 00002026 83E607              <1> 	and	si,0007h
  2007 00002029 D1E6                <1> 	shl	si,1
  2008 0000202B 2E8BB4[3A0A]        <1>     cs	mov	si,word [tbl_floppy+si]
  2009 00002030 E83D08              <1> 	call	print
  2010 00002033 BE[8B00]            <1> 	mov	si,msg_crlf
  2011 00002036 E83708              <1> 	call	print
  2012 00002039 5E                  <1> 	pop	si
  2013 0000203A 58                  <1> 	pop	ax
  2014 0000203B C3                  <1> 	ret
   275                                  %ifdef AT_KEYBOARD
   276                                  %include	"at_kbc.inc"		; keyboard controller functions
   277                                  %endif ; AT_KEYBOARD
   278                                  %include	"scancode.inc"		; keyboard scancodes translation func.
   279                              <1> ;=========================================================================
   280                              <1> ; scancode.inc - Keyboard scancode to ASCII code conversion
   281                              <1> ;		 and related INT 16h functions:
   282                              <1> ;	INT 16h - BIOS Keyboard Services
   283                              <1> ;		- function AH=00h
   284                              <1> ;		- function AH=01h
   285                              <1> ;		- function AH=10h
   286                              <1> ;		- function AH=11h
   287                              <1> ;-------------------------------------------------------------------------
   288                              <1> ;
   289                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   290                              <1> ;
   291                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
   292                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   293                              <1> ;
   294                              <1> ; This program is free software: you can redistribute it and/or modify
   295                              <1> ; it under the terms of the GNU General Public License as published by
   296                              <1> ; the Free Software Foundation, either version 3 of the License, or
   297                              <1> ; (at your option) any later version.
   298                              <1> ;
   299                              <1> ; This program is distributed in the hope that it will be useful,
   300                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   301                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   302                              <1> ; GNU General Public License for more details.
   303                              <1> ;
   304                              <1> ; You should have received a copy of the GNU General Public License
   305                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   306                              <1> ;
   307                              <1> ;=========================================================================
   308                              <1> 
   309                              <1> ;=========================================================================
   310                              <1> ; scan_xlat_table - Keyboard scan code to ASCII and
   311                              <1> ;                   BIOS scan code translation table
   312                              <1> ; Note 1: Table starts with scancode == 1
   313                              <1> ; Note 2: The high byte of the 'Normal' field indicates key flags
   314                              <1> ;	00 - no flags
   315                              <1> ;	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
   316                              <1> ;	     x in this case equals digit value
   317                              <1> ;	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
   318                              <1> ;	40 - there is an extended key, so check for 0E0h flag
   319                              <1> ;	8x - F11, F12 BIOS scan codes
   320                              <1> ;	     (observation: for all other keys BIOS scan code == kbd scan code)
   321                              <1> ;-------------------------------------------------------------------------
   322                              <1> 
   323                              <1> scan_xlat_table:
   324                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   325 0000203C 1B001B011B01F001    <1> 	dw	001Bh,	011Bh,	011Bh,	01F0h	; Esc		01h
   326 00002044 3100210200000078    <1> 	dw	0031h,	0221h,	0,	7800h	; 1	!	02h
   327 0000204C 3200400300030079    <1> 	dw	0032h,	0340h,	0300h,	7900h	; 2	@	03h
   328 00002054 330023040000007A    <1> 	dw	0033h,	0423h,	0,	7A00h	; 3	#	04h
   329 0000205C 340024050000007B    <1> 	dw	0034h,	0524h,	0,	7B00h	; 4	$	05h
   330 00002064 350025060000007C    <1> 	dw	0035h,	0625h,	0,	7C00h	; 5	%	06h
   331 0000206C 36005E071E07007D    <1> 	dw	0036h,	075Eh,	071Eh,	7D00h	; 6	^	07h
   332 00002074 370026080000007E    <1> 	dw	0037h,	0826h,	0,	7E00h	; 7	&	08h
   333 0000207C 38002A090000007F    <1> 	dw	0038h,	092Ah,	0,	7F00h	; 8	*	09h
   334 00002084 3900280A00000080    <1> 	dw	0039h,	0A28h,	0,	8000h	; 9	(	0Ah
   335 0000208C 3000290B00000081    <1> 	dw	0030h,	0B29h,	0,	8100h	; 0	)	0Bh
   336 00002094 2D005F0C1F0C0082    <1> 	dw	002Dh,	0C5Fh,	0C1Fh,	8200h	; -	_	0Ch
   337 0000209C 3D002B0D00000083    <1> 	dw	003Dh,	0D2Bh,	0,	8300h	; =	+	0Dh
   338 000020A4 0800080E7F0EF00E    <1> 	dw	0008h,	0E08h,	0E7Fh,	0EF0h	; Back Space	0Eh
   339 000020AC 0900000F009400A5    <1> 	dw	0009h,	0F00h,	9400h,	0A500h	; Tab		0Fh
   340 000020B4 7120511011100010    <1> 	dw	2071h,	1051h,	1011h,	1000h	; q	Q	10h
   341                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   342 000020BC 7720571117110011    <1> 	dw	2077h,	1157h,	1117h,	1100h	; w	W	11h
   343 000020C4 6520451205120012    <1> 	dw	2065h,	1245h,	1205h,	1200h	; e	E	12h
   344 000020CC 7220521312130013    <1> 	dw	2072h,	1352h,	1312h,	1300h	; r	R	13h
   345 000020D4 7420541414140014    <1> 	dw	2074h,	1454h,	1414h,	1400h	; t	T	14h
   346 000020DC 7920591519150015    <1> 	dw	2079h,	1559h,	1519h,	1500h	; y	Y	15h
   347 000020E4 7520551615160016    <1> 	dw	2075h,	1655h,	1615h,	1600h	; u	U	16h
   348 000020EC 6920491709170017    <1> 	dw	2069h,	1749h,	1709h,	1700h	; i	I	17h
   349 000020F4 6F204F180F180018    <1> 	dw	206Fh,	184Fh,	180Fh,	1800h	; o	O	18h
   350 000020FC 7020501910190019    <1> 	dw	2070h,	1950h,	1910h,	1900h	; p	P	19h
   351 00002104 5B007B1A1B1AF01A    <1> 	dw	005Bh,	1A7Bh,	1A1Bh,	1AF0h	; [	{	1Ah
   352 0000210C 5D007D1B1D1BF01B    <1> 	dw	005Dh,	1B7Dh,	1B1Dh,	1BF0h	; ]	}	1Bh
   353 00002114 0D400D1C0A1CF01C    <1> 	dw	400Dh,	1C0Dh,	1C0Ah,	1CF0h	; Enter		1Ch
   354 0000211C 0000000000000000    <1> 	dw	0,	0,	0,	0,	; Ctrl		1Dh
   355 00002124 6120411E011E001E    <1> 	dw	2061h,	1E41h,	1E01h,	1E00h	; a	A	1Eh
   356 0000212C 7320531F131F001F    <1> 	dw	2073h,	1F53h,	1F13h,	1F00h	; s	S	1Fh
   357 00002134 6420442004200020    <1> 	dw	2064h,	2044h,	2004h,	2000h	; d	D	20h
   358                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   359 0000213C 6620462106210021    <1> 	dw	2066h,	2146h,	2106h,	2100h	; f	F	21h
   360 00002144 6720472207220022    <1> 	dw	2067h,	2247h,	2207h,	2200h	; g	G	22h
   361 0000214C 6820482308230023    <1> 	dw	2068h,	2348h,	2308h,	2300h	; h	H	23h
   362 00002154 6A204A240A240024    <1> 	dw	206Ah,	244Ah,	240Ah,	2400h	; j	J	24h
   363 0000215C 6B204B250B250025    <1> 	dw	206Bh,	254Bh,	250Bh,	2500h	; k	K	25h
   364 00002164 6C204C260C260026    <1> 	dw	206Ch,	264Ch,	260Ch,	2600h	; l	L	26h
   365 0000216C 3B003A270000F027    <1> 	dw	003Bh,	273Ah,	0,	27F0h	; ;	:	27h
   366 00002174 270022280000F028    <1> 	dw	0027h,	2822h,	0,	28F0h	; '	"	28h
   367 0000217C 60007E290000F029    <1> 	dw	0060h,	297Eh,	0,	29F0h	; `	~	29h
   368 00002184 0000000000000000    <1> 	dw	0,	0,	0,	0	; Left Shift	2Ah
   369 0000218C 5C007C2B1C2BF02B    <1> 	dw	005Ch,	2B7Ch,	2B1Ch,	2BF0h	; \	|	2Bh
   370 00002194 7A205A2C1A2C002C    <1> 	dw	207Ah,	2C5Ah,	2C1Ah,	2C00h	; z	Z	2Ch
   371 0000219C 7820582D182D002D    <1> 	dw	2078h,	2D58h,	2D18h,	2D00h	; x	X	2Dh
   372 000021A4 6320432E032E002E    <1> 	dw	2063h,	2E43h,	2E03h,	2E00h	; c	C	2Eh
   373 000021AC 7620562F162F002F    <1> 	dw	2076h,	2F56h,	2F16h,	2F00h	; v	V	2Fh
   374 000021B4 6220423002300030    <1> 	dw	2062h,	3042h,	3002h,	3000h	; b	B	30h
   375                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   376 000021BC 6E204E310E310031    <1> 	dw	206Eh,	314Eh,	310Eh,	3100h	; n	N	31h
   377 000021C4 6D204D320D320032    <1> 	dw	206Dh,	324Dh,	320Dh,	3200h	; m	M	32h
   378 000021CC 2C003C330000F033    <1> 	dw	002Ch,	333Ch,	0,	33F0h	; ,	<	33h
   379 000021D4 2E003E340000F034    <1> 	dw	002Eh,	343Eh,	0,	34F0h	; .	>	34h
   380 000021DC 2F603F350000F035    <1> 	dw	602Fh,	353Fh,	0,	35F0h	; /	?	35h
   381 000021E4 0000000000000000    <1> 	dw	0,	0,	0,	0	; Right Shift	36h
   382 000021EC 2A6000000096F037    <1> 	dw	602Ah,	0,	9600h,	37F0h	; *	PrtSc	37h
   383 000021F4 0000000000000000    <1> 	dw	0,	0,	0,	0	; Alt		38h
   384 000021FC 2000203920392039    <1> 	dw	0020h,	3920h,	3920h,	3920h	; Space		39h
   385 00002204 0000000000000000    <1> 	dw	0,	0,	0,	0	; Caps Lock	3Ah
   386 0000220C 00000054005E0068    <1> 	dw	0000h,	5400h,	5E00h,	6800h	; F1		3Bh
   387 00002214 00000055005F0069    <1> 	dw	0000h,	5500h,	5F00h,	6900h	; F2		3Ch
   388 0000221C 000000560060006A    <1> 	dw	0000h,	5600h,	6000h,	6A00h	; F3		3Dh
   389 00002224 000000570061006B    <1> 	dw	0000h,	5700h,	6100h,	6B00h	; F4		3Eh
   390 0000222C 000000580062006C    <1> 	dw	0000h,	5800h,	6200h,	6C00h	; F5		3Fh
   391 00002234 000000590063006D    <1> 	dw	0000h,	5900h,	6300h,	6D00h	; F6		40h
   392                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   393 0000223C 0000005A0064006E    <1> 	dw	0000h,	5A00h,	6400h,	6E00h	; F7		41h
   394 00002244 0000005B0065006F    <1> 	dw	0000h,	5B00h,	6500h,	6F00h	; F8		42h
   395 0000224C 0000005C00660070    <1> 	dw	0000h,	5C00h,	6600h,	7000h	; F9		43h
   396 00002254 0000005D00670071    <1> 	dw	0000h,	5D00h,	6700h,	7100h	; F10		44h
   397 0000225C 0000000000000000    <1> 	dw	0,	0,	0,	0	; Num Lock	45h
   398 00002264 0000000000000000    <1> 	dw	0,	0,	0,	0	; Scroll Lock	46h
   399 0000226C 0077374700770097    <1> 	dw	7700h,	4737h,	7700h,	9700h	; Home	7	47h
   400 00002274 00783848008D0098    <1> 	dw	7800h,	4838h,	8D00h,	9800h	; Up 	8	48h
   401 0000227C 0079394900840099    <1> 	dw	7900h,	4939h,	8400h,	9900h	; PgUp	9	49h
   402 00002284 2D002D4A008EF04A    <1> 	dw	002Dh,	4A2Dh,	8E00h,	4AF0h	; Gray -	4Ah
   403 0000228C 0074344B0073009B    <1> 	dw	7400h,	4B34h,	7300h,	9B00h	; Left	4	4Bh
   404 00002294 F075354C008FF04C    <1> 	dw	75F0h,	4C35h,	8F00h,	4CF0h	; Center5	4Ch
   405 0000229C 0076364D0074009D    <1> 	dw	7600h,	4D36h,	7400h,	9D00h	; Right	6 	4Dh
   406 000022A4 2B002B4E0090F04E    <1> 	dw	002Bh,	4E2Bh,	9000h,	4EF0h	; Gray +	4Eh
   407 000022AC 0071314F0075009F    <1> 	dw	7100h,	4F31h,	7500h,	9F00h	; End	1	4Fh
   408 000022B4 00723250009100A0    <1> 	dw	7200h,	5032h,	9100h,	0A000h	; Down	2	50h
   409                              <1> ;		Normal	Shift	Ctrl	Alt	Key		Scan
   410 000022BC 00733351007600A1    <1> 	dw	7300h,	5133h,	7600h,	0A100h	; PgDn	3	51h
   411 000022C4 00703052009200A2    <1> 	dw	7000h,	5230h,	9200h,	0A200h	; Ins	0	52h
   412 000022CC 00602E53009300A3    <1> 	dw	6000h,	532Eh,	9300h,	0A300h	; Del	.	53h
   413 000022D4 0000000000000000    <1> 	dw	0,	0,	0,	0	; SysRq		54h
   414 000022DC 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		55h
   415 000022E4 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		56h
   416 000022EC 008500870089008B    <1> 	dw	8500h,	8700h,	8900h,	8B00h	; F11		57h
   417 000022F4 00860088008A008C    <1> 	dw	8600h,	8800h,	8A00h,	8C00h	; F12		58h
   418                              <1> .end:
   419                              <1> scan_xlat_table_size equ (.end-scan_xlat_table)/8
   420                              <1> 
   421                              <1> ;=========================================================================
   422                              <1> ; scan_xlat - Translate scan code to ASCII character / scan code pair
   423                              <1> ; Input:
   424                              <1> ;	AL - scan code
   425                              <1> ; Output:
   426                              <1> ;	AX - ASCII character / scan code pair
   427                              <1> ;-------------------------------------------------------------------------
   428                              <1> scan_xlat:
   429 000022FC 53                  <1> 	push	bx
   430 000022FD FEC8                <1> 	dec	al
   431 000022FF 3C58                <1> 	cmp	al,scan_xlat_table_size
   432 00002301 7205                <1> 	jb	.1
   433 00002303 31C0                <1> 	xor	ax,ax
   434 00002305 E9AB00              <1> 	jmp	.exit
   435                              <1> 
   436                              <1> .1:
   437 00002308 B700                <1> 	mov	bh,00h				; calculate offset of the key
   438 0000230A 88C3                <1> 	mov	bl,al				; in scan_xlat_table
   439 0000230C D1E3                <1> 	shl	bx,1				; BX = AL * 8
   440 0000230E D1E3                <1> 	shl	bx,1
   441 00002310 D1E3                <1> 	shl	bx,1
   442                              <1> 
   443 00002312 F606170008          <1> 	test	byte [kbd_flags_1],kbd_alt_bit	; is the Alt key pressed?
   444 00002317 7428                <1> 	jz	.check_ctrl			; Alt key is not pressed
   445 00002319 2E8B87[4220]        <1>     cs	mov	ax,word [scan_xlat_table+6+bx]	; Alt codes are in 4th column
   446                              <1> 	; check for numeric Keypad keys
   447 0000231E 2EF687[3D20]10      <1>     cs  test	byte [scan_xlat_table+1+bx],10h ; keypad?
   448 00002324 7474                <1> 	jz	.check_extended
   449 00002326 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
   450 0000232B 756D                <1> 	jnz	.check_extended			; ... yes, it is a 0E0h
   451                              <1> 						; and so it is not a keypad key
   452                              <1> 
   453 0000232D 2E8A87[3D20]        <1>     cs	mov	al,byte [scan_xlat_table+1+bx]
   454 00002332 240F                <1> 	and	al,0Fh				; get the numeric value
   455 00002334 8A261900            <1> 	mov	ah,byte [kbd_alt_keypad]	; load value from work area
   456 00002338 D50A                <1> 	aad	0Ah				; AL = AH * 10 + AL
   457 0000233A A21900              <1> 	mov	byte [kbd_alt_keypad],al	; store it back to the work area
   458                              <1> 
   459 0000233D 31C0                <1> 	xor	ax,ax				; return nothing
   460 0000233F EB72                <1> 	jmp	.exit
   461                              <1> 
   462                              <1> .check_ctrl:
   463 00002341 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; is the Ctrl key pressed?
   464 00002346 7407                <1> 	jz	.check_locks			; Ctrl key is not pressed
   465 00002348 2E8B87[4020]        <1>     cs	mov	ax,word [scan_xlat_table+4+bx]	; Ctrl codes are in 3rd column
   466 0000234D EB4B                <1> 	jmp	.check_extended
   467                              <1> 
   468                              <1> .check_locks:
   469 0000234F 2EF687[3D20]20      <1>     cs	test	byte [scan_xlat_table+1+bx],20h	; is this key affected by Locks?
   470 00002355 741D                <1> 	jz	.check_shift			; not affected by Locks
   471                              <1> 
   472 00002357 3C46                <1> 	cmp	al,46h				; Num Lock affects scancodes
   473 00002359 7309                <1> 	jae	.check_num_lock			; above or equal 47h
   474                              <1> 
   475 0000235B F606170040          <1> 	test	byte [kbd_flags_1],kbd_caps_bit	; is Caps Lock active?
   476 00002360 7412                <1> 	jz	.check_shift			; Caps Lock is not active
   477 00002362 EB07                <1> 	jmp	.lock_active
   478                              <1> 
   479                              <1> .check_num_lock:
   480 00002364 F606170020          <1> 	test    byte [kbd_flags_1],kbd_num_bit	; is Num Lock active?
   481 00002369 7409                <1> 	jz	.check_shift			; Num Lock is not active
   482                              <1> .lock_active:
   483                              <1> 	; are any of Shift keys active?
   484 0000236B F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
   485 00002370 7409                <1> 	jz	.shift				; Lock active, Shift inactive
   486 00002372 EB0E                <1> 	jmp	.no_shift			; Lock active, Shift active
   487                              <1> 
   488                              <1> .check_shift:
   489                              <1> 	; are any of Shift keys active?
   490 00002374 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
   491 00002379 7407                <1> 	jz	.no_shift
   492                              <1> .shift:
   493 0000237B 2E8B87[3E20]        <1>     cs	mov	ax,word [scan_xlat_table+2+bx]	; Shift codes are in 2nd column
   494 00002380 EB18                <1> 	jmp	.check_extended
   495                              <1> 
   496                              <1> .no_shift:
   497 00002382 88C4                <1> 	mov	ah,al				; Move scan code to AH
   498 00002384 FEC4                <1> 	inc	ah
   499 00002386 2E8A87[3C20]        <1>     cs	mov	al,byte [scan_xlat_table+bx]	; Normal codes are in 1st column
   500 0000238B 2EF687[3D20]80      <1>     cs	test	byte [scan_xlat_table+1+bx],80h	; F11 or F12?
   501 00002391 7407                <1> 	jz	.check_extended			; not F11 or F12
   502 00002393 2E8AA7[3D20]        <1>     cs  mov	ah,byte [scan_xlat_table+bx+1]	; Load scan code for F11 or F12
   503 00002398 EB19                <1> 	jmp	.exit
   504                              <1> 
   505                              <1> .check_extended:
   506 0000239A 2EF687[3D20]40      <1>    cs	test	byte [scan_xlat_table+1+bx],40h	; have an extended key?
   507 000023A0 7411                <1> 	jz	.exit				; no extended key
   508 000023A2 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
   509 000023A7 740A                <1> 	jz	.exit				; ... not a 0E0h
   510 000023A9 3C00                <1> 	cmp	al,00h
   511 000023AB 7504                <1> 	jnz	.ascii_code			; key has an ASCII code
   512 000023AD B0E0                <1> 	mov	al,0E0h				; indicate extended key
   513 000023AF EB02                <1> 	jmp	.exit
   514                              <1> 
   515                              <1> .ascii_code:
   516 000023B1 B4E0                <1> 	mov	ah,0E0h				; indicate extended key for a
   517                              <1> 						; key with valid ASCII code
   518                              <1> 						; (Keypad Enter, *, and /)
   519                              <1> 
   520                              <1> .exit:
   521 000023B3 5B                  <1> 	pop	bx
   522 000023B4 C3                  <1> 	ret
   523                              <1> 
   524                              <1> ;=========================================================================
   525                              <1> ; int_16_fn00 - get keystroke
   526                              <1> ; Input:
   527                              <1> ;	AH = 00h
   528                              <1> ; Output:
   529                              <1> ;	AH = BIOS scan code
   530                              <1> ;	AL = ASCII character
   531                              <1> ; Notes:
   532                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
   533                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
   534                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
   535                              <1> ;	- Use function AH=10h for extended keystrokes handling
   536                              <1> ;-------------------------------------------------------------------------
   537                              <1> int_16_fn00:
   538 000023B5 FB                  <1> 	sti
   539                              <1> .1:
   540 000023B6 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   541 000023BA 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
   542 000023BE 74F6                <1> 	jz	.1			; wait or keystroke
   543 000023C0 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
   544 000023C2 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   545                              <1> 					;   location
   546 000023C5 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   547 000023C9 7504                <1> 	jne	.2
   548 000023CB 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   549                              <1> .2:
   550 000023CF 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   551 000023D3 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
   552                              <1> 					;   extended key?
   553 000023D5 7504                <1> 	jne	.3			; not a convertible key
   554 000023D7 B000                <1> 	mov	al,00h			; convert to a standard key
   555 000023D9 EB2C                <1> 	jmp	.exit
   556                              <1> .3:
   557 000023DB 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
   558 000023DD 74D7                <1> 	je	.1			; an ignored extended key, get next key
   559 000023DF 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
   560                              <1> 					;   (scancode above 84h)
   561 000023E2 77D2                <1> 	ja	.1			; an ignored extended key, get next key
   562 000023E4 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
   563 000023E7 751E                <1> 	jne	.exit
   564 000023E9 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
   565 000023EB 7504                <1> 	jne	.4
   566 000023ED B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   567 000023EF EB16                <1> 	jmp	.exit
   568                              <1> .4:
   569 000023F1 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
   570 000023F3 7504                <1> 	jne	.5
   571 000023F5 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   572 000023F7 EB0E                <1> 	jmp	.exit
   573                              <1> .5:
   574 000023F9 3C2F                <1> 	cmp	al,2Fh			; Keypad /
   575 000023FB 7504                <1> 	jne	.6
   576 000023FD B435                <1> 	mov	ah,35h			; standard / scancode
   577 000023FF EB06                <1> 	jmp	.exit
   578                              <1> .6:
   579 00002401 3C2A                <1> 	cmp	al,2Ah			; Keypad *
   580 00002403 7502                <1> 	jne	.exit
   581 00002405 B437                <1> 	mov	ah,37h			; standard * scancode
   582                              <1> .exit:
   583 00002407 E96124              <1> 	jmp	int_16_exit
   584                              <1> 
   585                              <1> ;=========================================================================
   586                              <1> ; int_16_fn01 - check for keystroke
   587                              <1> ; Input:
   588                              <1> ;	AH = 01h
   589                              <1> ; Output:
   590                              <1> ;	ZF = 1 - no keystroke available
   591                              <1> ;	ZF = 0 = keystroke is available and put in AX
   592                              <1> ;		AH = BIOS scan code
   593                              <1> ;		AL = ASCII character
   594                              <1> ; Notes:
   595                              <1> ;	- Does not remove keystroke from keyboard buffer
   596                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
   597                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
   598                              <1> ;	- Use function AH=11h for extended keystrokes handling
   599                              <1> ;-------------------------------------------------------------------------
   600                              <1> int_16_fn01:
   601 0000240A 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   602 0000240E 8B07                <1> 	mov	ax,word [bx]
   603 00002410 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
   604 00002414 7436                <1> 	jz	.exit			; no keystroke, exit
   605 00002416 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
   606                              <1> 					;   extended key?
   607 00002418 7504                <1> 	jne	.1			; not a convertible key
   608 0000241A B000                <1> 	mov	al,00h			; convert to a standard key
   609 0000241C EB2C                <1> 	jmp	.clear_zf
   610                              <1> .1:
   611 0000241E 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
   612 00002420 742D                <1> 	je	.discard_key		; an ignored extended key, discard
   613 00002422 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
   614                              <1> 					;   (scancode above 84h)
   615 00002425 7728                <1> 	ja	.discard_key		; an ignored extended key, discard
   616 00002427 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
   617 0000242A 751E                <1> 	jne	.clear_zf
   618 0000242C 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
   619 0000242E 7504                <1> 	jne	.2
   620 00002430 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   621 00002432 EB16                <1> 	jmp	.clear_zf
   622                              <1> .2:
   623 00002434 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
   624 00002436 7504                <1> 	jne	.3
   625 00002438 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   626 0000243A EB0E                <1> 	jmp	.clear_zf
   627                              <1> .3:
   628 0000243C 3C2F                <1> 	cmp	al,2Fh			; Keypad /
   629 0000243E 7504                <1> 	jne	.4
   630 00002440 B435                <1> 	mov	ah,35h			; standard / scancode
   631 00002442 EB06                <1> 	jmp	.clear_zf
   632                              <1> .4:
   633 00002444 3C2A                <1> 	cmp	al,2Ah			; Keypad *
   634 00002446 7502                <1> 	jne	.clear_zf
   635 00002448 B437                <1> 	mov	ah,37h			; standard * scancode
   636                              <1> 
   637                              <1> .clear_zf:
   638 0000244A 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
   639                              <1> .exit:
   640 0000244C E91F24              <1> 	jmp	int_16_exitf
   641                              <1> 
   642                              <1> .discard_key:
   643 0000244F 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   644                              <1> 					;   location
   645 00002452 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   646 00002456 7504                <1> 	jne	.5
   647 00002458 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   648                              <1> .5:
   649 0000245C 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   650 00002460 EBA8                <1> 	jmp	int_16_fn01		; check for the next key
   651                              <1> 	
   652                              <1> 
   653                              <1> ;=========================================================================
   654                              <1> ; int_16_fn10 - get extended keystroke
   655                              <1> ; Input:
   656                              <1> ;	AH = 10h
   657                              <1> ; Output:
   658                              <1> ;	AH = BIOS scan code
   659                              <1> ;	AL = ASCII character
   660                              <1> ; Note:
   661                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
   662                              <1> ;-------------------------------------------------------------------------
   663                              <1> int_16_fn10:
   664 00002462 FB                  <1> 	sti
   665                              <1> .1:
   666 00002463 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   667 00002467 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
   668 0000246B 74F6                <1> 	jz	.1			; wait or keystroke
   669 0000246D 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
   670 0000246F 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   671                              <1> 					;   location
   672 00002472 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   673 00002476 7504                <1> 	jne	.2
   674 00002478 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   675                              <1> .2:
   676 0000247C 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   677 00002480 3CF0                <1> 	cmp	al,0F0h			; an extended key?
   678 00002482 7507                <1> 	jne	.exit			; not an extended key
   679 00002484 80FC00              <1> 	cmp	ah,00h			; is it Alt + 240 (F0 00)?
   680 00002487 7402                <1> 	je	.exit			; yes it is Alt + 240, return ASCII
   681 00002489 B000                <1> 	mov	al,00h			; set ASCII character to zero
   682                              <1> 
   683                              <1> .exit:
   684 0000248B E9DD23              <1> 	jmp	int_16_exit
   685                              <1> 
   686                              <1> ;=========================================================================
   687                              <1> ; int_16_fn11 - check for extended keystroke
   688                              <1> ; Input:
   689                              <1> ;	AH = 01h
   690                              <1> ; Output:
   691                              <1> ;	ZF = 1 - no keystroke available
   692                              <1> ;	ZF = 0 = keystroke is available and put in AX
   693                              <1> ;		AH = BIOS scan code
   694                              <1> ;		AL = ASCII character
   695                              <1> ; Note:
   696                              <1> ;	- Does not remove keystroke from keyboard buffer
   697                              <1> ;-------------------------------------------------------------------------
   698                              <1> int_16_fn11:
   699 0000248E 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   700 00002492 8B07                <1> 	mov	ax,word [bx]
   701 00002494 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
   702 00002498 7408                <1> 	jz	.exit			; no keystroke, exit
   703 0000249A 3CF0                <1> 	cmp	al,0F0h			; an extended key?
   704 0000249C 7502                <1> 	jne	.clear_zf		; not a extended key
   705 0000249E B000                <1> 	mov	al,00h			; set scancode to zero
   706                              <1> .clear_zf:
   707 000024A0 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
   708                              <1> .exit:
   709 000024A2 E9C923              <1> 	jmp	int_16_exitf
   279                                  %include	"serial1.inc"		; serial port services & detection
   280                              <1> ;========================================================================
   281                              <1> ; serial1.inc -  BIOS Serial Port Communication Services (part 1 of 2)
   282                              <1> ;       INT 14h, function AH=01h
   283                              <1> ;	INT 14h, function AH=02h
   284                              <1> ;	detect_serial
   285                              <1> ;	serial port related definitions and tables
   286                              <1> ;	- see serial2.inc for other INT 14h functions
   287                              <1> ;-------------------------------------------------------------------------
   288                              <1> ;
   289                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   290                              <1> ;
   291                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
   292                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   293                              <1> ;
   294                              <1> ; This program is free software: you can redistribute it and/or modify
   295                              <1> ; it under the terms of the GNU General Public License as published by
   296                              <1> ; the Free Software Foundation, either version 3 of the License, or
   297                              <1> ; (at your option) any later version.
   298                              <1> ;
   299                              <1> ; This program is distributed in the hope that it will be useful,
   300                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   301                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   302                              <1> ; GNU General Public License for more details.
   303                              <1> ;
   304                              <1> ; You should have received a copy of the GNU General Public License
   305                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   306                              <1> ;
   307                              <1> ;=========================================================================
   308                              <1> 
   309                              <1> uart_osc	equ	1843200		; 1.8432 MHz is the default UART clock
   310                              <1> one_sec_timeout equ	33135		; 30.18 us intervals in one second
   311                              <1> 
   312                              <1> uart_ier_reg	equ	1		; UART Interrupt Enable Register
   313                              <1> 
   314                              <1> uart_lcr_reg	equ	3		; UART Line Control Register
   315                              <1> uart_lcr_ldiv	equ	80h		; LCR - load divisor bit
   316                              <1> uart_lcr_wlen	equ	03h		; LCR - word length bits
   317                              <1> uart_lcr_stop	equ	04h		; LCR - number of stop bits bit
   318                              <1> uart_lcr_pen	equ	08h		; LCR - parity enable bit
   319                              <1> uart_lcr_peven	equ	10h		; LCR - parity even bit
   320                              <1> 
   321                              <1> uart_mcr_reg	equ	4		; UART Modem Control Register
   322                              <1> uart_mcr_dtr	equ	1		; MCR - data terminal ready (DTR)
   323                              <1> uart_mcr_rts	equ	2		; MCR - request to send (RTS)
   324                              <1> 
   325                              <1> uart_lsr_reg	equ	5		; UART Line Status Register
   326                              <1> uart_lsr_dr	equ	1		; LSR - data ready (DR)
   327                              <1> uart_lsr_thre	equ	20h		; LSR - THR empty (THRE)
   328                              <1> 
   329                              <1> uart_msr_reg	equ	6		; UART Modem Status Register
   330                              <1> uart_msr_cts	equ	10h		; MSR - clear to send (CTS)
   331                              <1> uart_msr_dsr	equ	20h		; MSR - data set ready (DSR)
   332                              <1> 
   333                              <1> uart_err_timeout equ	80h		; timeout error
   334                              <1> 
   335                              <1> num_serial	equ	4		; number of serial ports
   336                              <1> 
   337                              <1> ;=========================================================================
   338                              <1> ; int_14_fn01 - Send character
   339                              <1> ; Input:
   340                              <1> ;	AH = 01h - function 01h - send character
   341                              <1> ;	AL = character to send
   342                              <1> ;	DX = serial port number (0-3)
   343                              <1> ; Output:
   344                              <1> ;	AH = line status (see int_14_fn00 for complete description)
   345                              <1> ;-------------------------------------------------------------------------
   346                              <1> int_14_fn01:
   347 000024A5 50                  <1> 	push	ax
   348 000024A6 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; set DTR and RTS in MCR:
   349                              <1> 					; ready to communicate, request to send
   350 000024A8 B730                <1> 	mov	bh,(uart_msr_dsr | uart_msr_cts) ; wait for DSR and CTS in MSR:
   351                              <1> 					; ready to communicate, clear to send
   352 000024AA B320                <1> 	mov	bl,uart_lsr_thre	; and for THRE in LSR:
   353                              <1> 					; UART is ready to accept new character
   354 000024AC E82200              <1> 	call	uart_wait_status
   355 000024AF 59                  <1> 	pop	cx
   356 000024B0 7506                <1> 	jnz	int_14_timeout		; timeout, original AL is in CL
   357 000024B2 88C8                <1> 	mov	al,cl
   358 000024B4 EE                  <1> 	out	dx,al			; sent the character
   359 000024B5 E9AE22              <1> 	jmp	int_14_exit
   360                              <1> 
   361                              <1> int_14_timeout:
   362 000024B8 88C8                <1> 	mov	al,cl			; original AL saved in CL, restore it
   363 000024BA 80CC80              <1> 	or	ah,uart_err_timeout	; set timeout bit
   364 000024BD E9A622              <1> 	jmp	int_14_exit
   365                              <1> 
   366                              <1> ;=========================================================================
   367                              <1> ; int_14_fn02 - Receive character
   368                              <1> ; Input:
   369                              <1> ;	AH = 02h - function 02h - receive character
   370                              <1> ;	DX = serial port number (0-3)
   371                              <1> ; Output:
   372                              <1> ;	AL = character received
   373                              <1> ;	AH = line status (see int_14_fn00 for complete description)
   374                              <1> ;-------------------------------------------------------------------------
   375                              <1> int_14_fn02:
   376 000024C0 50                  <1> 	push	ax
   377 000024C1 B001                <1> 	mov	al,uart_mcr_dtr		; set DTR in MCR:
   378                              <1> 					; ready to communicate
   379 000024C3 B720                <1> 	mov	bh,uart_msr_dsr		; wait for DSR in MSR:
   380                              <1> 					; ready to communicate
   381 000024C5 B301                <1> 	mov	bl,uart_lsr_dr		; and for DT in LSR:
   382                              <1> 					; UART has received a character
   383 000024C7 E80700              <1> 	call	uart_wait_status
   384 000024CA 59                  <1> 	pop	cx
   385 000024CB 75EB                <1> 	jnz	int_14_timeout
   386 000024CD EC                  <1> 	in	al,dx			; receive the character
   387 000024CE E99522              <1> 	jmp	int_14_exit
   388                              <1> 
   389                              <1> ;=========================================================================
   390                              <1> ; uart_wait_status - wait for modem and line status
   391                              <1> ; Input:
   392                              <1> ;	AL = value to write to MCR (Modem Control Register)
   393                              <1> ;	BH = mask to wait for in MSR (Modem Status Register)
   394                              <1> ;	BL = mask to wait for in LSR (Line Status Register)
   395                              <1> ;	DX = UART base address
   396                              <1> ;	SI = address of the timeout value (in seconds)
   397                              <1> ; Output:
   398                              <1> ;	AH = line status
   399                              <1> ;	ZF = 0 - timeout
   400                              <1> ;	CX,BX - destroyed
   401                              <1> ;-------------------------------------------------------------------------
   402                              <1> uart_wait_status:
   403 000024D1 52                  <1> 	push	dx
   404 000024D2 83C204              <1> 	add	dx,uart_mcr_reg		; DX = UART MCR address
   405 000024D5 EE                  <1> 	out	dx,al			; output MCR value
   406 000024D6 42                  <1> 	inc	dx
   407 000024D7 42                  <1> 	inc	dx			; DX = UART MSR address
   408                              <1> 					; OPTIMIZATION:
   409                              <1> 					; uart_msr_reg = uart_mcr_reg + 2
   410 000024D8 E80A00              <1> 	call	wait_for_port		; wait for MSR status
   411 000024DB 7506                <1> 	jnz	.wait_exit
   412 000024DD 4A                  <1> 	dec	dx			; DX = UART LSR address
   413                              <1> 					; OPTIMIZATION:
   414                              <1> 					; uart_lsr_reg = uart_msr_reg - 1
   415 000024DE 88DF                <1> 	mov	bh,bl			; BH = LSR mask
   416 000024E0 E80200              <1> 	call	wait_for_port		; wait for LSR status
   417                              <1> .wait_exit:
   418 000024E3 5A                  <1> 	pop	dx
   419 000024E4 C3                  <1> 	ret
   420                              <1> 
   421                              <1> ;=========================================================================
   422                              <1> ; wait_for_port - wait for set bits in a register
   423                              <1> ;
   424                              <1> ; Input:
   425                              <1> ;	BH = mask to wait for (bits that need to be 1)
   426                              <1> ;	DX = register address
   427                              <1> ;	SI = address of the timeout value (in seconds)
   428                              <1> ; Output:
   429                              <1> ;	AH = last port reading
   430                              <1> ;	ZF clear on timeout
   431                              <1> ;	ZF set on success
   432                              <1> ;	AL - trashed
   433                              <1> ;	CX - trashed
   434                              <1> ;-------------------------------------------------------------------------
   435                              <1> wait_for_port:
   436                              <1> 
   437 000024E5 53                  <1> 	push	bx
   438 000024E6 8A1C                <1> 	mov	bl,byte [SI]		; get the timeout value in seconds
   439                              <1> 
   440                              <1> .loop_outer:
   441 000024E8 B96F81              <1> 	mov	cx,one_sec_timeout	; 30.18 us intervals in one second
   442                              <1> 
   443                              <1> .loop_inner:
   444 000024EB EC                  <1> 	in	al,dx			; read the register
   445 000024EC 88C4                <1> 	mov	ah,al			; save register in AH
   446 000024EE 20F8                <1> 	and	al,bh
   447 000024F0 38F8                <1> 	cmp	al,bh			; required bits are set?
   448 000024F2 740E                <1> 	je	.exit
   449                              <1> 
   450                              <1> %ifdef AT_DELAY
   451                              <1> 
   452                              <1> .zero_loop:
   453                              <1> 	in	al,ppi_pb_reg
   454                              <1> 	test	al,refresh_flag
   455                              <1> 	jz	.zero_loop		; wait 15.09 us
   456                              <1> 
   457                              <1> .one_loop:
   458                              <1> 	in	al,ppi_pb_reg
   459                              <1> 	test	al,refresh_flag
   460                              <1> 	jnz	.one_loop		; wait 15.09 us
   461                              <1> 
   462                              <1> %else ; AT_DELAY
   463                              <1> 
   464                              <1> 	; wait 30.17 us (Intel 8088 CPU running on 4.77 MHz)
   465 000024F4 B008                <1>         mov     al,8
   466                              <1> .delay_loop:
   467 000024F6 FEC8                <1>         dec     al
   468 000024F8 75FC                <1>         jnz     .delay_loop
   469                              <1> 
   470                              <1> %endif ; AT_DELAY
   471                              <1> 
   472 000024FA E2EF                <1> 	loop	.loop_inner
   473                              <1> 
   474 000024FC FECB                <1> 	dec	bl
   475 000024FE 75E8                <1> 	jnz	.loop_outer
   476 00002500 08FF                <1> 	or	bh,bh			; timeout set ZF = 0 (BH != 0)
   477                              <1> 
   478                              <1> .exit:
   479 00002502 5B                  <1> 	pop	bx
   480 00002503 C3                  <1> 	ret
   481                              <1> 
   482                              <1> ;=========================================================================
   483                              <1> ; detect_serial - detect and print serial ports
   484                              <1> ; Input:
   485                              <1> ;	none
   486                              <1> ; Output:
   487                              <1> ;	none (updates BIOS data area)
   488                              <1> ;-------------------------------------------------------------------------
   489                              <1> detect_serial:
   490 00002504 50                  <1> 	push	ax
   491 00002505 53                  <1> 	push	bx
   492 00002506 52                  <1> 	push	dx
   493 00002507 56                  <1> 	push	si
   494 00002508 B024                <1> 	mov	al,e_serial_scan
   495 0000250A E680                <1> 	out	post_reg,al
   496                              <1> 
   497 0000250C BE[2F03]            <1> 	mov	si,msg_serial
   498 0000250F E85E03              <1> 	call	print
   499 00002512 BB0101              <1> 	mov	bx,0101h		; the default timeout is 1 sec
   500 00002515 891E7C00            <1> 	mov	word [serial_timeout],bx   ; initialize timeout values
   501 00002519 891E7E00            <1> 	mov	word [serial_timeout+2],bx ; for all 4 ports
   502 0000251D 31DB                <1> 	xor	bx,bx			; BX = 0
   503                              <1> .detect_loop:
   504 0000251F BE[4C03]            <1> 	mov	si,msg_serial_com
   505 00002522 E84B03              <1> 	call	print
   506 00002525 88D8                <1> 	mov	al,bl
   507 00002527 D0E8                <1> 	shr	al,1
   508 00002529 FEC0                <1> 	inc	al			; AL = COM port number (1..4)
   509 0000252B E8A003              <1> 	call	print_digit
   510 0000252E BE[9300]            <1> 	mov	si,msg_colon
   511 00002531 E83C03              <1> 	call	print
   512 00002534 2E8B97[8625]        <1>     cs	mov	dx,word [uart_ier_regs+bx] ; DX = UART IER address
   513 00002539 EC                  <1> 	in	al,dx
   514 0000253A B00F                <1> 	mov	al,0Fh
   515 0000253C EE                  <1> 	out	dx,al			; enable interrupts
   516 0000253D B000                <1> 	mov	al,00h
   517 0000253F E6C0                <1> 	out	unused_reg,al		; clear ISA data bus floating signals
   518 00002541 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
   519 00002542 3C0F                <1> 	cmp	al,0Fh
   520 00002544 751C                <1> 	jne	.no_port		; no port at this address
   521 00002546 B000                <1> 	mov	al,00h
   522 00002548 EE                  <1> 	out	dx,al			; disable interrupts
   523 00002549 B0FF                <1> 	mov	al,0FFh
   524 0000254B E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
   525 0000254D EC                  <1> 	in	al,dx			; get interrupt enable register to AL
   526 0000254E 3C00                <1> 	cmp	al,00h
   527 00002550 7510                <1> 	jne	.no_port		; no port at this address
   528 00002552 4A                  <1> 	dec	dx			; DX = UART base address
   529                              <1> 					; OPTIMIZATION:
   530                              <1> 					; uart_base = uart_ier_reg - 1
   531 00002553 8917                <1> 	mov	word [equip_serial+bx],dx ; store port address to the BIOS
   532                              <1> 					; data area
   533 00002555 810610000002        <1> 	add	word [equipment_list],0200h ; increment number of serial ports
   534 0000255B 89D0                <1> 	mov	ax,dx
   535 0000255D E82B03              <1> 	call	print_hex
   536 00002560 EB0A                <1> 	jmp	.next
   537                              <1> 
   538                              <1> .no_port:
   539 00002562 C7070000            <1> 	mov	word [equip_serial+bx],0 ; no port
   540 00002566 BE[8E00]            <1> 	mov	si,msg_none
   541 00002569 E80403              <1> 	call	print
   542                              <1> 	
   543                              <1> .next:
   544 0000256C 43                  <1> 	inc	bx
   545 0000256D 43                  <1> 	inc	bx
   546 0000256E 83FB08              <1> 	cmp	bx,(num_serial << 1)	; all serial ports have been scanned?
   547 00002571 7408                <1> 	je	.done
   548 00002573 BE[9600]            <1> 	mov	si,msg_semicolon
   549 00002576 E8F702              <1> 	call	print
   550 00002579 EBA4                <1> 	jmp	.detect_loop
   551                              <1> 
   552                              <1> .done:
   553 0000257B BE[8B00]            <1> 	mov	si,msg_crlf
   554 0000257E E8EF02              <1> 	call	print
   555                              <1> 
   556 00002581 5E                  <1> 	pop	si
   557 00002582 5A                  <1> 	pop	dx
   558 00002583 5B                  <1> 	pop	bx
   559 00002584 58                  <1> 	pop	ax
   560 00002585 C3                  <1> 	ret
   561                              <1> 
   562                              <1> ;-------------------------------------------------------------------------
   563                              <1> ; serial port Interrupt Enable Register addresses - used for port detection
   564 00002586 F903F902            <1> uart_ier_regs	dw	(3F8h + uart_ier_reg), (2F8h + uart_ier_reg)
   565 0000258A E903E902            <1> 		dw	(3E8h + uart_ier_reg), (2E8h + uart_ier_reg)
   566                              <1> 
   567                              <1> ;-------------------------------------------------------------------------
   568                              <1> ; UART divisor values table
   569 0000258E 1704                <1> uart_divisors	dw	uart_osc/16/110		; 110 bps
   570 00002590 0003                <1> 		dw	uart_osc/16/150		; 150 bps
   571 00002592 8001                <1> 		dw	uart_osc/16/300		; 300 bps
   572 00002594 C000                <1> 		dw	uart_osc/16/600		; 600 bps
   573 00002596 6000                <1> 		dw	uart_osc/16/1200	; 1200 bps
   574 00002598 3000                <1> 		dw	uart_osc/16/2400	; 2400 bps
   575 0000259A 1800                <1> 		dw	uart_osc/16/4800	; 4800 bps
   576 0000259C 0C00                <1> 		dw	uart_osc/16/9600	; 9600 bps
   577 0000259E 0600                <1> 		dw	uart_osc/16/19200	; 19200 bps
   578 000025A0 0300                <1> 		dw	uart_osc/16/38400	; 38400 bps
   579 000025A2 0200                <1> 		dw	uart_osc/16/57600	; 57600 bps
   580 000025A4 0100                <1> 		dw	uart_osc/16/115200	; 115200 bps
   581                              <1> num_divisors	equ ($-uart_divisors)/2
   280                                  %include	"printer1.inc"		; parallel printer services & detection
   281                              <1> ;========================================================================
   282                              <1> ; printer2.inc - Parallel printer support (part 1 of 2)
   283                              <1> ;	INT 17h, function AH=01h 
   284                              <1> ;	detect_parallel
   285                              <1> ;	- see printer2.inc for other INT 17h functions
   286                              <1> ;-------------------------------------------------------------------------
   287                              <1> ;
   288                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   289                              <1> ;
   290                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
   291                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   292                              <1> ;
   293                              <1> ; This program is free software: you can redistribute it and/or modify
   294                              <1> ; it under the terms of the GNU General Public License as published by
   295                              <1> ; the Free Software Foundation, either version 3 of the License, or
   296                              <1> ; (at your option) any later version.
   297                              <1> ;
   298                              <1> ; This program is distributed in the hope that it will be useful,
   299                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   300                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   301                              <1> ; GNU General Public License for more details.
   302                              <1> ;
   303                              <1> ; You should have received a copy of the GNU General Public License
   304                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   305                              <1> ;
   306                              <1> ;=========================================================================
   307                              <1> 
   308                              <1> num_parallel	equ	3		; number of parallel ports
   309                              <1> 
   310                              <1> prn_data_reg	equ	0		; printer data register (out)
   311                              <1> 
   312                              <1> prn_stat_reg	equ	1		; printer status register (in)
   313                              <1> prn_stat_bits	equ	0F8h		; used bits in status register
   314                              <1> prn_stat_invert	equ	048h		; bits 6 and 3 need to be inverted
   315                              <1> prn_stat_busy	equ	80h		; 0 = printer is busy (1 = ready)
   316                              <1> prn_stat_tmout	equ	01h		; 1 = timeout (software error)
   317                              <1> 
   318                              <1> prn_ctrl_reg	equ	2		; printer control register (out)
   319                              <1> prn_ctrl_sel	equ	08h		; 1 = select printer
   320                              <1> prn_ctrl_init	equ	04h		; 0 = initialize printer (1 = normal)
   321                              <1> prn_ctrl_autolf	equ	02h		; 1 = auto linefeed
   322                              <1> prn_ctrl_strobe	equ	01h		; 1 = strobe active
   323                              <1> 
   324                              <1> prn_init_delay	equ	2485		; printer initialization delay, 75 ms
   325                              <1> 
   326                              <1> ;=========================================================================
   327                              <1> ; int_17_fn01 - Initialize printer port
   328                              <1> ; Input:
   329                              <1> ;	AH = 1 - function 01h - initialize printer port
   330                              <1> ;	DX = printer port number (0-2)
   331                              <1> ; Output:
   332                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
   333                              <1> ;-------------------------------------------------------------------------
   334                              <1> int_17_fn01:
   335 000025A6 42                  <1> 	inc	dx
   336 000025A7 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
   337                              <1> 					; OPTIMIZATION:
   338                              <1> 					; prn_ctrl_reg = prn_data_reg + 2
   339 000025A8 B008                <1> 	mov	al,prn_ctrl_sel		; init bit = 0, initialize printer
   340 000025AA EE                  <1> 	out	dx,al
   341 000025AB 51                  <1> 	push	cx
   342 000025AC B9B509              <1> 	mov	cx,prn_init_delay
   343 000025AF E8E6F0              <1> 	call	delay_15us
   344 000025B2 59                  <1> 	pop	cx
   345 000025B3 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
   346 000025B5 EE                  <1> 	out	dx,al			; deactivate init bit
   347 000025B6 4A                  <1> 	dec	dx			; OPTIMIZATION:
   348                              <1> 					; prn_stat_reg = prn_ctrl_reg - 1
   349 000025B7 E97F2A              <1> 	jmp	int_17_status		; exit returning status
   350                              <1> 
   351                              <1> ;=========================================================================
   352                              <1> ; detect_parallel - detect and print parallel ports
   353                              <1> ; Input:
   354                              <1> ;	none
   355                              <1> ; Output:
   356                              <1> ;	none (updates BIOS data area)
   357                              <1> ; Notes:
   358                              <1> ; 	- If parallel port is found at 3BCh the following parallel port
   359                              <1> ;	  enumeration is used:
   360                              <1> ;	  LPT1 - 3BCh, LPT2 - 378h, LPT3 - 278h
   361                              <1> ;	- If parallel port is not found at 3BCh, the enumeration is:
   362                              <1> ;	  LPT1 - 378h, LPT2 - 278h, LPT3 - none
   363                              <1> ;-------------------------------------------------------------------------
   364                              <1> detect_parallel:
   365 000025BA 50                  <1> 	push	ax
   366 000025BB 53                  <1> 	push	bx
   367 000025BC 52                  <1> 	push	dx
   368 000025BD 56                  <1> 	push	si
   369 000025BE B025                <1> 	mov	al,e_parallel_scan
   370 000025C0 E680                <1> 	out	post_reg,al
   371                              <1> 
   372 000025C2 BB1414              <1> 	mov	bx,1414h		; default timeout is 20 seconds
   373 000025C5 891E7800            <1> 	mov	word [printer_timeout],bx   ; initialize timeout values
   374 000025C9 891E7A00            <1> 	mov	word [printer_timeout+2],bx ; for all 4 ports
   375 000025CD 31DB                <1> 	xor	bx,bx			; BX = 0
   376 000025CF 31FF                <1> 	xor	di,di			; DI = 0
   377                              <1> .detect_loop:
   378 000025D1 2E8B95[4A26]        <1>     cs	mov	dx,word [parallel_base+di] ; DX = parallel port address
   379 000025D6 B05A                <1> 	mov	al,05Ah			; just some test value
   380 000025D8 EE                  <1> 	out	dx,al			; write it to the printer data register
   381 000025D9 B0FF                <1> 	mov	al,0FFh
   382 000025DB E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
   383 000025DD EC                  <1> 	in	al,dx
   384 000025DE 3C5A                <1> 	cmp	al,05Ah			; compare with the test value
   385 000025E0 750B                <1> 	jne	.no_port		; no port at this address
   386 000025E2 895708              <1> 	mov	word [equip_parallel+bx],dx ; store port address to the BIOS
   387                              <1> 					; data area
   388 000025E5 810610000040        <1> 	add	word [equipment_list],4000h ; increment number of printer ports
   389 000025EB EB09                <1> 	jmp	.next
   390                              <1> 
   391                              <1> .no_port:
   392 000025ED C747080000          <1> 	mov	word [equip_parallel+bx],0 ; no port
   393 000025F2 09FF                <1> 	or	di,di			; no printer port at 3BCh?
   394 000025F4 7402                <1> 	jz	.next_skip_3BC		; don't increment LPTx number
   395                              <1> .next:
   396 000025F6 43                  <1> 	inc	bx
   397 000025F7 43                  <1> 	inc	bx
   398                              <1> 
   399                              <1> .next_skip_3BC:
   400 000025F8 47                  <1> 	inc	di
   401 000025F9 47                  <1> 	inc	di
   402 000025FA 83FF06              <1> 	cmp	di,(num_parallel << 1)	; all parallel ports have been scanned?
   403 000025FD 7402                <1> 	je	.print			; done with detection, print findings
   404 000025FF EBD0                <1> 	jmp	.detect_loop
   405                              <1> 
   406                              <1> .print:
   407 00002601 BE[5003]            <1> 	mov	si,msg_parallel
   408 00002604 E86902              <1> 	call	print
   409 00002607 31DB                <1> 	xor	bx,bx
   410                              <1> 
   411                              <1> .print_loop:
   412 00002609 BE[6D03]            <1> 	mov	si,msg_parallel_lpt
   413 0000260C E86102              <1> 	call	print
   414 0000260F 88D8                <1> 	mov	al,bl
   415 00002611 D0E8                <1> 	shr	al,1
   416 00002613 FEC0                <1> 	inc	al			; AL = LPT port number (1..3)
   417 00002615 E8B602              <1> 	call	print_digit
   418 00002618 BE[9300]            <1> 	mov	si,msg_colon
   419 0000261B E85202              <1> 	call	print
   420 0000261E 8B4708              <1> 	mov	ax,word [equip_parallel+bx] ; get parallel port address
   421 00002621 09C0                <1> 	or	ax,ax			; parallel interface installed?
   422 00002623 7405                <1> 	jz	.print_no_port
   423 00002625 E86302              <1> 	call	print_hex
   424 00002628 EB06                <1> 	jmp	.print_next
   425                              <1> 
   426                              <1> .print_no_port:
   427 0000262A BE[8E00]            <1> 	mov	si,msg_none
   428 0000262D E84002              <1> 	call	print
   429                              <1> 
   430                              <1> .print_next:
   431 00002630 43                  <1> 	inc	bx
   432 00002631 43                  <1> 	inc	bx
   433 00002632 83FB06              <1> 	cmp	bx,(num_parallel << 1)	; all parallel ports have been printed?
   434 00002635 7408                <1> 	je	.done
   435 00002637 BE[9600]            <1> 	mov	si,msg_semicolon
   436 0000263A E83302              <1> 	call	print
   437 0000263D EBCA                <1> 	jmp	.print_loop
   438                              <1> 
   439                              <1> .done:
   440 0000263F BE[8B00]            <1> 	mov	si,msg_crlf
   441 00002642 E82B02              <1> 	call	print
   442                              <1> 
   443 00002645 5E                  <1> 	pop	si
   444 00002646 5A                  <1> 	pop	dx
   445 00002647 5B                  <1> 	pop	bx
   446 00002648 58                  <1> 	pop	ax
   447 00002649 C3                  <1> 	ret
   448                              <1> 
   449                              <1> ;-------------------------------------------------------------------------
   450                              <1> ; parallel port base addresses - used for port detection
   451 0000264A BC0378037802        <1> parallel_base	dw	3BCh, 378h, 278h
   281                                  %ifdef PS2_MOUSE
   282                                  %ifndef SECOND_PIC
   283                                  %error "PS2_MOUSE depends on SECOND_PIC. Please fix config.inc."
   284                                  %endif ; SECOND_PIC
   285                                  %include	"ps2aux.inc"
   286                                  %endif
   287                                  %include	"sound.inc"		; sound test
   288                              <1> ;=========================================================================
   289                              <1> ; sound.inc - Play power-on sound. This also tests PIT and PORT B functionality
   290                              <1> ;-------------------------------------------------------------------------
   291                              <1> ;
   292                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   293                              <1> ;
   294                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
   295                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   296                              <1> ;
   297                              <1> ; This program is free software: you can redistribute it and/or modify
   298                              <1> ; it under the terms of the GNU General Public License as published by
   299                              <1> ; the Free Software Foundation, either version 3 of the License, or
   300                              <1> ; (at your option) any later version.
   301                              <1> ;
   302                              <1> ; This program is distributed in the hope that it will be useful,
   303                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   304                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   305                              <1> ; GNU General Public License for more details.
   306                              <1> ;
   307                              <1> ; You should have received a copy of the GNU General Public License
   308                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   309                              <1> ;
   310                              <1> ;=========================================================================
   311                              <1> 
   312 00002650 6908                <1> notes	dw	pic_freq/554		; D flat
   313 00002652 FFFF                <1> 	dw	-1			; silent
   314 00002654 D310                <1> 	dw	pic_freq/277		; D flat
   315 00002656 980C                <1> 	dw	pic_freq/370		; G flat
   316 00002658 D310                <1> 	dw	pic_freq/277		; D flat
   317 0000265A 3B0B                <1> 	dw	pic_freq/415		; A flat
   318 0000265C 0000                <1> 	dw	0
   319                              <1> 
   320                              <1> ;=========================================================================
   321                              <1> ; sound - Play power-on sound.
   322                              <1> ; Input:
   323                              <1> ;	none
   324                              <1> ; Output:
   325                              <1> ;	none, destroys some registers
   326                              <1> ;-------------------------------------------------------------------------
   327                              <1> sound:
   328 0000265E FC                  <1> 	cld
   329 0000265F BE[5026]            <1> 	mov	si,notes		; set SI to notes table
   330                              <1> 
   331 00002662 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
   332 00002664 E643                <1> 	out	pit_ctl_reg,al
   333                              <1> 
   334                              <1> .loop:
   335 00002666 2EAD                <1>     cs	lodsw				; load next note to AX
   336 00002668 83F800              <1> 	cmp	ax,0
   337 0000266B 7422                <1> 	jz	.exit
   338 0000266D 7C0C                <1> 	jl	.silent			; don't turn on speaker if silent note
   339 0000266F E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
   340 00002671 88E0                <1> 	mov	al,ah
   341 00002673 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
   342                              <1> 
   343 00002675 E461                <1> 	in	al,ppi_pb_reg		; read current value of PORT B
   344 00002677 0C03                <1>         or      al,03h			; turn on the speaker
   345 00002679 E661                <1>         out     ppi_pb_reg,al		; write the new value
   346                              <1> 
   347                              <1> .silent:
   348 0000267B B90030              <1> 	mov	cx,3000h
   349 0000267E E817F0              <1> 	call	delay_15us		; delay while note is playing
   350                              <1> 
   351 00002681 E461                <1> 	in	al,ppi_pb_reg		; read current value of PORT B
   352 00002683 24FC                <1> 	and	al,0FCh			; turn off the speaker
   353 00002685 E661                <1>         out     ppi_pb_reg,al		; write the new value
   354                              <1> 
   355 00002687 B90001              <1>         mov     cx,0100h
   356 0000268A E80BF0              <1> 	call	delay_15us		; delay after the note
   357                              <1>         
   358 0000268D EBD7                <1>         jmp     .loop			; play the next note
   359                              <1> .exit:
   360 0000268F C3                  <1> 	ret
   361                              <1> 
   362                              <1> ;=========================================================================
   363                              <1> ; beep - Play a beep sound
   364                              <1> ; Input:
   365                              <1> ;	BL - duration in 0.1 second
   366                              <1> ; Output:
   367                              <1> ;	BL = 0
   368                              <1> ;-------------------------------------------------------------------------
   369                              <1> beep:
   370 00002690 50                  <1> 	push	ax
   371 00002691 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
   372 00002693 E643                <1> 	out	pit_ctl_reg,al
   373 00002695 B8A904              <1> 	mov	ax,1193			; approximately 1000 Hz
   374 00002698 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
   375 0000269A 88E0                <1> 	mov	al,ah
   376 0000269C E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
   377 0000269E E461                <1> 	in	al,ppi_pb_reg		; read current value of PORT B
   378 000026A0 0C03                <1> 	or	al,03h			; turn on the speaker
   379 000026A2 E661                <1> 	out	ppi_pb_reg,al		; write the new value
   380                              <1> .loop:
   381 000026A4 B90A1A              <1> 	mov	cx,6666			; 0.1 second delay
   382 000026A7 E8EEEF              <1> 	call	delay_15us
   383 000026AA FECB                <1> 	dec	bl
   384 000026AC 75F6                <1> 	jnz	.loop
   385 000026AE 3403                <1> 	xor	al,03h			; turn off the speaker
   386 000026B0 E661                <1> 	out	ppi_pb_reg,al		; write the new value
   387 000026B2 58                  <1> 	pop	ax
   388 000026B3 C3                  <1> 	ret
   288                                  %include	"cpu.inc"		; CPU and FPU detection
   289                              <1> ;=========================================================================
   290                              <1> ; cpu.inc - Detect and print CPU type and FPU presence
   291                              <1> ;-------------------------------------------------------------------------
   292                              <1> ;
   293                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   294                              <1> ;
   295                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
   296                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   297                              <1> ;
   298                              <1> ; This program is free software: you can redistribute it and/or modify
   299                              <1> ; it under the terms of the GNU General Public License as published by
   300                              <1> ; the Free Software Foundation, either version 3 of the License, or
   301                              <1> ; (at your option) any later version.
   302                              <1> ;
   303                              <1> ; This program is distributed in the hope that it will be useful,
   304                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   305                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   306                              <1> ; GNU General Public License for more details.
   307                              <1> ;
   308                              <1> ; You should have received a copy of the GNU General Public License
   309                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   310                              <1> ;
   311                              <1> ;=========================================================================
   312                              <1> 
   313                              <1> flags_tf	equ	0100h		; TF flag - enables single-step
   314                              <1> 
   315                              <1> ;=========================================================================
   316                              <1> ; detect_cpu - detect and print CPU type
   317                              <1> ; Note:
   318                              <1> ;	- Designed to detect 8088, 80C88, and V20 CPU. Likely will return
   319                              <1> ;	  incorrect results if used on other CPU types.
   320                              <1> ;-------------------------------------------------------------------------
   321                              <1> detect_cpu:
   322 000026B4 50                  <1> 	push	ax
   323 000026B5 56                  <1> 	push	si
   324 000026B6 B021                <1> 	mov	al,e_cpu_detect
   325 000026B8 E680                <1> 	out	post_reg,al
   326                              <1> 
   327 000026BA BE[D800]            <1> 	mov	si,msg_cpu
   328 000026BD E8B001              <1> 	call	print
   329                              <1> 
   330                              <1> ; test for NEC V20
   331 000026C0 B80101              <1> 	mov	ax,0101h
   332 000026C3 D510                <1> 	aad	10h			; NEC V20 ignores the argument
   333 000026C5 3C0B                <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
   334 000026C7 7452                <1> 	je	.nec_v20
   335                              <1> 
   336                              <1> ; not NEC V20, test for various 8088 versions
   337                              <1> .i8088:					; 8088 - NMOS version of 8088
   338 000026C9 FA                  <1> 	cli				; disable interrupts
   339 000026CA 1E                  <1> 	push	ds
   340 000026CB 31C0                <1> 	xor	ax,ax
   341 000026CD 8ED8                <1> 	mov	ds,ax			; interrupt table segment
   342 000026CF B8[4327]            <1> 	mov	ax,.int_01		; new int 01h offset
   343 000026D2 87060400            <1> 	xchg	ax,word [4]		; switch with original int 1 offset
   344 000026D6 50                  <1> 	push	ax			; save to stack
   345 000026D7 8CC8                <1> 	mov	ax,cs			; new int 01h segment
   346 000026D9 87060600            <1> 	xchg	ax,word [6]		; switch with original int 1 segment
   347 000026DD 50                  <1> 	push	ax			; save to stack
   348 000026DE 9C                  <1> 	pushf				; push flags to stack (save)
   349 000026DF 9C                  <1> 	pushf				; push flags to stack (modify)
   350 000026E0 58                  <1> 	pop	ax			; and move them to AX
   351 000026E1 0D0001              <1> 	or	ax,flags_tf		; set TF
   352 000026E4 50                  <1> 	push	ax
   353 000026E5 31C0                <1> 	xor	ax,ax			; AX = 0
   354 000026E7 9D                  <1> 	popf				; load modified value to FLAGS register
   355                              <1> 					; enable single-step
   356 000026E8 90                  <1> 	nop
   357 000026E9 1E                  <1> 	push	ds			; Harris 80C88 disables interrupts
   358                              <1> 					; after PUSH SREG instructions
   359                              <1> .push_sreg:				; and will not single-step to here
   360 000026EA 1F                  <1> 	pop	ds			; 1981 and newer 8088 disable interrupts
   361                              <1> 					; after modifying segment registers
   362                              <1> .pop_sreg:				; and will not single-step to here
   363 000026EB 90                  <1> 	nop
   364 000026EC 9D                  <1> 	popf				; restore original FLAGS, disable
   365                              <1> 					; single-step
   366                              <1> 
   367 000026ED 5E                  <1> 	pop	si			; get original int 01h segment
   368 000026EE 89360600            <1> 	mov	word [6],si		; save it to interrupt table
   369 000026F2 5E                  <1> 	pop	si			; get original int 01h offset
   370 000026F3 89360400            <1> 	mov	word [4],si		; save it to interrupt table
   371 000026F7 1F                  <1> 	pop	ds
   372 000026F8 FB                  <1> 	sti				; enable interrupts
   373 000026F9 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
   374 000026FC 740D                <1> 	jz	.i8088_78
   375                              <1> 
   376 000026FE 83F802              <1> 	cmp	ax,0002h
   377 00002701 7410                <1> 	jz	.i8088_81
   378                              <1> 
   379                              <1> .harris:				; Harris / Intersil 80C88
   380 00002703 BE[A101]            <1> 	mov	si,msg_cpu_harris
   381 00002706 E86701              <1> 	call	print
   382 00002709 EB16                <1> 	jmp	.cpu_freq
   383                              <1> 
   384                              <1> .i8088_78:
   385 0000270B BE[1201]            <1> 	mov	si,msg_cpu_8088_78
   386 0000270E E85F01              <1> 	call	print
   387 00002711 EB0E                <1> 	jmp	.cpu_freq
   388                              <1> 
   389                              <1> .i8088_81:
   390 00002713 BE[7201]            <1> 	mov	si,msg_cpu_8088_81
   391 00002716 E85701              <1> 	call	print
   392 00002719 EB06                <1> 	jmp	.cpu_freq
   393                              <1> 
   394                              <1> .nec_v20:
   395                              <1> %ifdef MACHINE_HOMEBREW8088
   396                              <1> ; Test for NEC V40
   397                              <1> ; NEC V40 has on-chip configuration registers at 0FFE0h-0FFFFh I/0 addresses.
   398                              <1> ; The code below tries to modify the value of 0FFFE0 register and read it back.
   399                              <1> ; If the value is stored, it is assumed to be a NEC V40 CPU
   400                              <1> 	push	dx
   401                              <1> 	mov	dx,0FFE0h	; Use 0FFFE0h register for V40 tests
   402                              <1> 	in	al,dx		; read the original value
   403                              <1> 	mov	ah,al		; store the orginal value in AH
   404                              <1> 	xor	al,0FFh		; invert all the bits
   405                              <1> 	out	dx,al		; write the inverted value
   406                              <1> 	in	al,dx		; read it back
   407                              <1> 	xor	al,0FFh		; invert all the bits again
   408                              <1> 	cmp	al,ah		; compare with the original value
   409                              <1> 	jne	.not_v40
   410                              <1> 	out	dx,al		; write the original value
   411                              <1> 	in	al,dx		; read it back again
   412                              <1> 	cmp	al,ah		; compare with the original value
   413                              <1> 	jne	.not_v40
   414                              <1> 	pop	dx
   415                              <1> 	mov	si,msg_cpu_nec_v40
   416                              <1> 	call	print
   417                              <1> 	jmp	.cpu_freq
   418                              <1> 
   419                              <1> .not_v40:
   420                              <1> 	pop	dx
   421                              <1> %endif ; MACHINE_HOMEBREW8088
   422 0000271B BE[B701]            <1> 	mov	si,msg_cpu_nec_v20
   423 0000271E E84F01              <1> 	call	print
   424                              <1> 
   425                              <1> .cpu_freq:
   426                              <1> 
   427                              <1> %ifdef TURBO_MODE
   428                              <1> %ifdef BIOS_SETUP
   429                              <1> ; print CPU clock frequency
   430                              <1> 
   431 00002721 BE[B600]            <1> 	mov	si,msg_at
   432 00002724 E84901              <1> 	call	print
   433                              <1> 
   434 00002727 50                  <1> 	push	ax
   435 00002728 E8ABE8              <1> 	call	get_config_a		; read BIOS configuration byte A
   436 0000272B E8AA00              <1> 	call	print_cpu_clk
   437 0000272E 58                  <1> 	pop	ax
   438                              <1> 
   439                              <1> %endif ; BIOS_SETUP
   440                              <1> %endif ; TURBO_MODE
   441                              <1> 
   442 0000272F BE[8B00]            <1> 	mov	si,msg_crlf
   443 00002732 E83B01              <1> 	call	print
   444                              <1> 
   445 00002735 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
   446 00002738 7506                <1> 	jnz	.exit
   447 0000273A BE[2101]            <1> 	mov	si,msg_cpu_bug
   448 0000273D E83001              <1> 	call	print
   449                              <1> 
   450                              <1> 
   451                              <1> 
   452                              <1> .exit:
   453                              <1> %ifdef MACHINE_HOMEBREW8088
   454                              <1> 	call	.estimate_clock
   455                              <1> %endif ; MACHINE_HOMEBREW8088
   456 00002740 5E                  <1> 	pop	si
   457 00002741 58                  <1> 	pop	ax
   458 00002742 C3                  <1> 	ret
   459                              <1> 
   460                              <1> %ifdef MACHINE_HOMEBREW8088
   461                              <1> ; Estimate CPU clock frequency
   462                              <1> ; Algorithm:
   463                              <1> ; Run a cycle that's setup + a loop of 100 "AAA".
   464                              <1> ; That takes N ticks of the timer, and it includes N1 of actual operations + N2 wait-states from loading the instructions.
   465                              <1> ; Then run similar setup + a loop of 100 "AAM".  That takes M ticks, which is M1 actual operations + N2 wait states.
   466                              <1> ; So M - N will remove the "wait state" factor and be how many ticks it took to do "the difference in work between 100 AAAs and 100 AAMs"
   467                              <1> ; Since that's a fixed number of CPU cycles, the M-N value is an inverse of the CPU clock and we can divide by a constant (determined experimentally) to get a reasonable MHz figure
   468                              <1> ; independent of wait-states.  Note this does not compensate for external variations (i. e. DRAM refresh or a device that seizes the bus)
   469                              <1> ; It's not hyper-accurate-- it's often off by a few hundred KHz, and it can vary from run to run due to timer noise, but it should be enough to differentiate the major speed grades
   470                              <1> ; A further possible cleanup would be to "bin" the results-- anything below 5MHz as 4.77, anything 7.5-8.5 as 8, etc.
   471                              <1> .estimate_clock:
   472                              <1> 	push	dx
   473                              <1> 	push	ax
   474                              <1> 	push	cx
   475                              <1> 	push	bx
   476                              <1> 	push	si
   477                              <1> 	mov	si,msg_est
   478                              <1> 	cli				; Disable interrupts for better accuracy
   479                              <1> 	call	print
   480                              <1> 
   481                              <1> 	call	io_wait_latch
   482                              <1> 	push	ax
   483                              <1> 	xor	ax,ax
   484                              <1> ; Must be unrolled or it behaves inconsistently on different waitstates IME
   485                              <1> 	%rep 100
   486                              <1> 	aam
   487                              <1> 	%endrep
   488                              <1> 	call	io_wait_latch
   489                              <1> 	sti
   490                              <1> 	pop	bx
   491                              <1> 	cmp	ax,bx
   492                              <1> 	jae	.second_scan_is_bigger_simple
   493                              <1> 	sub	bx,ax
   494                              <1> 	jmp	.sub_done_simple
   495                              <1> 
   496                              <1> .second_scan_is_bigger_simple:
   497                              <1> 	mov	cx,0FFFFh
   498                              <1> 	sub	cx,ax
   499                              <1> 	add	bx,cx
   500                              <1> 
   501                              <1> .sub_done_simple:
   502                              <1> 	push	bx	; Save the runtime for the faster instruction
   503                              <1> 	cli
   504                              <1> 	call	io_wait_latch
   505                              <1> 	push	ax
   506                              <1> 	xor	ax,ax
   507                              <1> 	%rep 100
   508                              <1> 	mul	cl
   509                              <1> 	%endrep
   510                              <1> 	call	io_wait_latch
   511                              <1> 	sti
   512                              <1> 	pop	bx
   513                              <1> 	cmp	ax,bx
   514                              <1> 	jae	.second_scan_is_bigger
   515                              <1> 	sub	bx,ax
   516                              <1> 	jmp	.sub_done
   517                              <1> 
   518                              <1> .second_scan_is_bigger:
   519                              <1> 	mov	cx,0FFFFh
   520                              <1> 	sub	cx,ax
   521                              <1> 	add	bx,cx
   522                              <1> 
   523                              <1> .sub_done:
   524                              <1> 	pop	ax	; pull the count from the simple run
   525                              <1> 	sub	bx,ax
   526                              <1> 	; We'd expect BX to be the amount of clock ticks corresponding to (some large number) more cycles
   527                              <1> 
   528                              <1> 
   529                              <1> ;	mov ax,bx			; Refinement tool:  Display the number of clock ticks the loop generated.
   530                              <1> ;	call	print_dec		; Uncomment this code and run it on your machine and it will say things like "244 ticks ~ 8.00MHz"
   531                              <1> ;	mov	si,msg_ticks   ; Calculate (number of ticks) * 100 * (CPU actual MHz)
   532                              <1> ;	call	print			; and place it in DX:AX as the "clock divider" for the CPU type you're using in the code below
   533                              <1> ;	mov	ax,0E20h
   534                              <1> ;	int	10h
   535                              <1> 
   536                              <1> 	mov	ax,0101h		; Repeat the NEC CPU test
   537                              <1> 	aad	10h			; NEC V20 ignores the argument
   538                              <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
   539                              <1> 	jne	.clock_divider_8088
   540                              <1> 	mov	dx,03h			; "Clock Divider" for NEC CPUs.  Value was based on an 10MHz V40: ~214 ticks, so the expected value is 1000*214 = 214000 = 343F0H
   541                              <1> 	mov	ax,43F0h		; On the V-series, AAM is faster than MUL (by quite a bit), so a large difference for the clock speed is expected.
   542                              <1> 	jmp	.clock_divider_set
   543                              <1> 
   544                              <1> .clock_divider_8088:
   545                              <1> 	neg	bx			; "Clock Divider" for 8088 CPUs.  Value was based on a 4.77MHz 8088: It shows as 65186 ticks, but on an 8088, MUL is faster than AAM
   546                              <1> 	mov	dx,0002h		; This means that BX is negative here, so flip the sign and we get 349 ticks... 349 ticks * 477  = 166473 = 28A49H.
   547                              <1> 	mov	ax,8A49h
   548                              <1> 
   549                              <1> .clock_divider_set:
   550                              <1> 	div	bx
   551                              <1> 	mov	bx,100			; Split to integer and fractional parts
   552                              <1> 	div	bl
   553                              <1> 
   554                              <1> 	mov	bx,ax
   555                              <1> 	xor	ah,ah
   556                              <1> 	call	print_dec		; Integer part
   557                              <1> 	mov 	ax,0E2Eh		; decimal point
   558                              <1> 	int	10h
   559                              <1> 	xor	ah,ah
   560                              <1> 	mov	al,bh
   561                              <1> 	cmp	al,10
   562                              <1> 	jae	.two_digits
   563                              <1> 	push	ax
   564                              <1> 	mov	ax,0E30h		; leading zero
   565                              <1> 	int	10h
   566                              <1> 	pop	ax
   567                              <1> 
   568                              <1> .two_digits:
   569                              <1> 	call	print_dec
   570                              <1> 	mov	si,msg_mhz
   571                              <1> 	call	print
   572                              <1> 	mov	si,msg_crlf
   573                              <1> 	call	print
   574                              <1> 	pop	dx
   575                              <1> 	pop	si
   576                              <1> 	pop	bx
   577                              <1> 	pop	cx
   578                              <1> 	pop	ax
   579                              <1> 	ret
   580                              <1> %endif
   581                              <1> 
   582                              <1> ; stack frame after "push bp"
   583                              <1> ; BP - word [BP]
   584                              <1> ; IP - word [BP+2]
   585                              <1> ; CS - word [BP+4]
   586                              <1> ; FLAGS - word [BP+6]
   587                              <1> .int_01:
   588 00002743 55                  <1> 	push	bp
   589 00002744 89E5                <1> 	mov	bp,sp
   590 00002746 817E02[EB26]        <1> 	cmp	word [bp+2],.pop_sreg	; if IP = .pop_sreg we have '78 CPU
   591 0000274B 7504                <1> 	jne	.1
   592 0000274D B001                <1> 	mov	al,01h			; (C) INTEL '79
   593 0000274F EB09                <1> 	jmp	.int_01_exit
   594                              <1> .1:
   595 00002751 817E02[EA26]        <1> 	cmp	word [bp+2],.push_sreg	; if IP = .push_sreg it is not Harris
   596 00002756 7502                <1> 	jne	.int_01_exit
   597 00002758 B002                <1> 	mov	al,02h			; not Harris / Intersil 80C88
   598                              <1> .int_01_exit:
   599 0000275A 5D                  <1> 	pop	bp
   600 0000275B CF                  <1> 	iret
   601                              <1> 
   602                              <1> ;=========================================================================
   603                              <1> ; detect_fpu - detect and print FPU (mathematics coprocessor) presence
   604                              <1> ;-------------------------------------------------------------------------
   605                              <1> test_word	equ	03FEh		; right at the end of interrupt table
   606                              <1> detect_fpu:
   607 0000275C 50                  <1> 	push	ax
   608 0000275D 51                  <1> 	push	cx
   609 0000275E 56                  <1> 	push	si
   610 0000275F B022                <1> 	mov	al,e_fpu_detect
   611 00002761 E680                <1> 	out	post_reg,al
   612                              <1> 
   613 00002763 BE[F500]            <1> 	mov	si,msg_fpu
   614 00002766 E80701              <1> 	call	print
   615 00002769 DBE3                <1> 	fninit				; initialize coprocessor
   616 0000276B B90300              <1> 	mov	cx,3
   617                              <1> .wait:
   618 0000276E E2FE                <1> 	loop	.wait			; wait for coprocessor to initialize
   619                              <1> 					;   (can't use fwait, since it could
   620                              <1> 					;   be no coprocessor at all)
   621 00002770 8B0EFE03            <1> 	mov	cx,word [test_word]	; save test_word to CX
   622 00002774 C706FE030000        <1> 	mov	word [test_word],0000h	; clear space for control word
   623 0000277A D93EFE03            <1> 	fnstcw	word [test_word]	; store control word
   624 0000277E 813EFE03FF03        <1> 	cmp	word [test_word],03FFh	; 8087 sets control word to 03FFh
   625 00002784 750D                <1> 	jne	.no_fpu			;   after finit
   626                              <1> 
   627                              <1> .fpu:
   628 00002786 BE[BF01]            <1> 	mov	si,msg_fpu_present
   629 00002789 E8E400              <1> 	call	print
   630 0000278C 830E100002          <1> 	or	word [equipment_list],equip_fpu ; update equipment word
   631 00002791 EB06                <1> 	jmp	.exit
   632                              <1> 
   633                              <1> .no_fpu:
   634                              <1> 
   635 00002793 BE[2603]            <1> 	mov	si,msg_absent
   636 00002796 E8D700              <1> 	call	print
   637                              <1> 
   638                              <1> .exit:
   639 00002799 890EFE03            <1> 	mov	word [test_word],cx	; restore initial value of test_word
   640                              <1> 
   641 0000279D 5E                  <1> 	pop	si
   642 0000279E 59                  <1> 	pop	cx
   643 0000279F 58                  <1> 	pop	ax
   644 000027A0 C3                  <1> 	ret
   645                              <1> 
   646                              <1> %ifdef MACHINE_FE2010A
   647                              <1> ;=========================================================================
   648                              <1> ; detect_chipset - detect and print chipset type
   649                              <1> ; Input:
   650                              <1> ;	none
   651                              <1> ; Output:
   652                              <1> ;	none
   653                              <1> ; Note: This subroutine also disables DRAM refresh on both FE2010A and PT8010AF
   654                              <1> ;-------------------------------------------------------------------------
   655                              <1> detect_chipset:
   656 000027A1 50                  <1> 	push	ax
   657 000027A2 56                  <1> 	push	si
   658 000027A3 BE[CC01]            <1> 	mov	si,msg_chipset
   659 000027A6 E8C700              <1> 	call	print
   660 000027A9 BE[E901]            <1> 	mov	si,msg_fe2010		; FE2010 chipset does not fully decode
   661 000027AC E462                <1> 	in	al,ppi_pc_reg		; I/O addresses, and PPI ports 60h-63h
   662 000027AE 88C4                <1> 	mov	ah,al			; are aliased to 70h-73h.
   663 000027B0 E472                <1> 	in	al,72h			; Therefore port 62h (ppi_pc_reg) reads
   664 000027B2 38E0                <1> 	cmp	al,ah			; reads the same as port 72h.
   665 000027B4 7418                <1> 	je	.print_chipset
   666 000027B6 BE[FA01]            <1> 	mov	si,msg_fe2010a
   667 000027B9 B054                <1> 	mov	al,54h			; channel 1, LSB only, mode 2, binary
   668 000027BB E643                <1> 	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
   669 000027BD B012                <1> 	mov	al,12h			; or for delays (using port_b, bit 4)
   670 000027BF E641                <1>         out     pit_ch1_reg,al		; pulse every 15ms
   671 000027C1 B040                <1> 	mov	al,40h			; this disables refresh on FE2010A
   672 000027C3 E643                <1> 	out	pit_ctl_reg,al		; but not on PT8010AF
   673 000027C5 E441                <1> 	in	al,pit_ch1_reg
   674 000027C7 3C12                <1> 	cmp	al,12h			; should be 12h on FE2010A
   675 000027C9 7403                <1> 	je	.print_chipset
   676 000027CB BE[0C02]            <1> 	mov	si,msg_pt8010af
   677                              <1> 
   678                              <1> .print_chipset:
   679 000027CE E89F00              <1> 	call	print
   680 000027D1 B054                <1> 	mov	al,54h			; channel 1, LSB only, mode 2, binary
   681 000027D3 E643                <1> 	out	pit_ctl_reg,al		; this disables memory refresh
   682 000027D5 58                  <1> 	pop	ax
   683 000027D6 5E                  <1> 	pop	si
   684 000027D7 C3                  <1> 	ret
   685                              <1> 
   686                              <1> %endif ; MACHINE_FE2010A
   687                              <1> 
   688                              <1> %ifdef TURBO_MODE
   689                              <1> %ifdef BIOS_SETUP
   690                              <1> ;=========================================================================
   691                              <1> ; print_cpu_clk - Print CPU clock frequency
   692                              <1> ; Input:
   693                              <1> ;	AL - NVRAM CPU clock frequency configuration (bits 1:0)
   694                              <1> ;		0 - 4.77 MHz / Normal
   695                              <1> ;		1 - 7.16 MHz / Turbo
   696                              <1> ;		2 - 9.55 MHz (FE2010A)
   697                              <1> ; Output:
   698                              <1> ;	none
   699                              <1> ;-------------------------------------------------------------------------
   700                              <1> print_cpu_clk:
   701 000027D8 50                  <1> 	push	ax
   702 000027D9 56                  <1> 	push	si
   703 000027DA 2403                <1> 	and	al,nvram_trbo_mask	; get turbo bits
   704                              <1> %ifdef MACHINE_FE2010A
   705 000027DC BE[C400]            <1> 	mov	si,msg_clk_7_16mhz
   706 000027DF 3C01                <1> 	cmp	al,1
   707 000027E1 740A                <1> 	je	.print
   708 000027E3 BE[CE00]            <1> 	mov	si,msg_clk_9_55mhz
   709 000027E6 3C02                <1> 	cmp	al,2
   710 000027E8 7403                <1> 	je	.print
   711                              <1> %endif ; MACHINE_FE2010A
   712                              <1> %ifdef MACHINE_XI8088
   713                              <1> 	mov	si,msg_clk_turbo
   714                              <1> 	cmp	al,1
   715                              <1> 	je	.print
   716                              <1> %endif ; MACHINE_XI8088
   717 000027EA BE[BA00]            <1> 	mov	si,msg_clk_4_77mhz
   718                              <1> 
   719                              <1> .print:
   720 000027ED E88000              <1> 	call    print
   721 000027F0 5E                  <1> 	pop	si
   722 000027F1 58                  <1> 	pop	ax
   723 000027F2 C3                  <1> 	ret
   724                              <1> %endif ; BIOS_SETUP
   725                              <1> 
   726                              <1> ;=========================================================================
   727                              <1> ; set_cpu_clk - Set CPU clock frequency
   728                              <1> ; Input:
   729                              <1> ;	AL - NVRAM CPU clock frequency configuration
   730                              <1> ;		0 - 4.77 MHz / Normal
   731                              <1> ;		1 - 7.16 MHz / Turbo
   732                              <1> ;		2 - 9.55 MHz (FE2010A)
   733                              <1> ; Output:
   734                              <1> ;	none
   735                              <1> ;-------------------------------------------------------------------------
   736                              <1> set_cpu_clk:
   737                              <1> %ifdef MACHINE_FE2010A
   738 000027F3 3C01                <1> 	cmp	al, 1 
   739 000027F5 7413                <1> 	je	set_cpu_clk_7_16mhz
   740 000027F7 3C02                <1> 	cmp	al, 2
   741 000027F9 7429                <1> 	je	set_cpu_clk_9_55mhz
   742 000027FB EB01                <1> 	jmp	set_cpu_clk_4_77mhz   
   743                              <1> %endif ; MACHINE_FE2010A
   744                              <1> %ifdef MACHINE_XI8088
   745                              <1> 	cmp	al,1
   746                              <1> 	je	set_cpu_clk_turbo
   747                              <1> 	jmp	set_cpu_clk_4_77mhz   
   748                              <1> %endif ; MACHINE_XI8088
   749 000027FD C3                  <1> 	ret
   750                              <1> 
   751                              <1> ;=========================================================================
   752                              <1> ; set_cpu_clk_4_77mhz - Set CPU clock at 4.77 MHz
   753                              <1> ; set_cpu_clk_7_16mhz - Set CPU clock at 7.16 MHz
   754                              <1> ; set_cpu_clk_9_55mhz - Set CPU clock at 9.55 MHz
   755                              <1> ; set_cpu_clk_turbo - Set CPU clock at turbo frequency (system dependent)
   756                              <1> ; Input:
   757                              <1> ;	none
   758                              <1> ; Output:
   759                              <1> ;	none
   760                              <1> ;-------------------------------------------------------------------------
   761                              <1> %ifdef MACHINE_FE2010A
   762                              <1> set_cpu_clk_4_77mhz:
   763 000027FE 50                  <1> 	push ax
   764 000027FF A01000              <1> 	mov	al,byte [equipment_list] ; get lower byte of the equipment list
   765 00002802 2402                <1> 	and	al,equip_fpu		; isolate FPU installed bit
   766 00002804 0C01                <1> 	or	al,fe_par_disable	; disable memory parity checking
   767 00002806 E663                <1> 	out	fe_config_reg,al	; clear bits 7-5 - 4.77 MHz CPU clock
   768 00002808 58                  <1> 	pop ax
   769 00002809 C3                  <1> 	ret
   770                              <1> 
   771                              <1> set_cpu_clk_7_16mhz:
   772 0000280A 50                  <1> 	push ax
   773 0000280B E8C8E7              <1> 	call	get_config_a
   774 0000280E 88C4                <1> 	mov	ah,al
   775 00002810 A01000              <1> 	mov	al,byte [equipment_list] ; get lower byte of the equipment list
   776 00002813 2402                <1> 	and	al,equip_fpu		; isolate FPU installed bit
   777 00002815 0C01                <1> 	or	al,fe_par_disable	; disable memory parity checking
   778 00002817 0C40                <1> 	or	al,fe_clk_7_norm	; set bit 6 - 7.15 MHz CPU clock
   779 00002819 F6C410              <1> 	test	ah,nvram_fast_ws	; nvram_fast_ws = 1 - Normal wait states
   780 0000281C 7502                <1> 	jnz	.set_config
   781 0000281E 0C60                <1> 	or	al,fe_clk_7_fast
   782                              <1> 
   783                              <1> .set_config:
   784 00002820 E663                <1> 	out	fe_config_reg,al
   785 00002822 58                  <1> 	pop ax
   786 00002823 C3                  <1> 	ret
   787                              <1> 
   788                              <1> set_cpu_clk_9_55mhz:
   789 00002824 50                  <1> 	push ax
   790 00002825 E8AEE7              <1> 	call	get_config_a
   791 00002828 88C4                <1> 	mov	ah,al
   792 0000282A A01000              <1> 	mov	al,byte [equipment_list] ; get lower byte of the equipment list
   793 0000282D 2402                <1> 	and	al,equip_fpu		; isolate FPU installed bit
   794 0000282F 0C01                <1> 	or	al,fe_par_disable	; disable memory parity checking
   795 00002831 0C80                <1> 	or	al,fe_clk_9_norm	; set bit 7 - 9.54 MHz CPU clock
   796 00002833 F6C410              <1> 	test	ah,nvram_fast_ws
   797 00002836 7502                <1> 	jnz	.set_config		; nvram_fast_ws = 1 - Normal wait states
   798 00002838 0CC0                <1> 	or	al,fe_clk_9_fast
   799                              <1> 
   800                              <1> .set_config:
   801 0000283A E663                <1> 	out	fe_config_reg,al
   802 0000283C 58                  <1> 	pop ax
   803 0000283D C3                  <1> 	ret
   804                              <1> %endif ; MACHINE_FE2010A
   805                              <1> %ifdef MACHINE_XI8088
   806                              <1> set_cpu_clk_4_77mhz:
   807                              <1> 	push	ax
   808                              <1> 	in	al,ppi_pb_reg
   809                              <1> 	and	al,0FBh			; clear bit 2 (turbo enable bit)
   810                              <1> 	out	ppi_pb_reg,al
   811                              <1> 	pop	ax
   812                              <1> 	ret
   813                              <1> 
   814                              <1> set_cpu_clk_turbo:
   815                              <1> 	push	ax
   816                              <1> 	in	al,ppi_pb_reg
   817                              <1> 	or	al,04h			; set bit 2 (turbo enable bit)
   818                              <1> 	out	ppi_pb_reg,al
   819                              <1> 	pop	ax
   820                              <1> 	ret
   821                              <1> %endif ; MACHINE_XI8088
   822                              <1> %endif ; TURBO_MODE
   289                                  
   290                                  %ifdef SECOND_PIC
   291                                  
   292                                  ;=========================================================================
   293                                  ; int_ignore2 - signal end of interrupt to PIC if hardware interrupt, return
   294                                  ;-------------------------------------------------------------------------
   295                                  int_ignore2:
   296                                  	push	ax
   297                                  	mov	al,20h
   298                                  	out	pic2_reg0,al	; signal EOI to the slave PIC
   299                                  	out	pic1_reg0,al	; signal EOI to the master PIC
   300                                  	pop	ax
   301                                  	iret
   302                                  
   303                                  ;=========================================================================
   304                                  ; int_71 - IRQ9 ISR, emulate IRQ2
   305                                  ;-------------------------------------------------------------------------
   306                                  int_71:
   307                                  	push	ax
   308                                  	mov	al,20h
   309                                  	out	pic2_reg0,al	; signal EOI to the slave PIC
   310                                  	pop	ax
   311                                  	int	0Ah		; call IRQ2 ISR
   312                                  	iret
   313                                  
   314                                  ;=========================================================================
   315                                  ; int_75 - IRQ13 ISR, emulate NMI by FPU
   316                                  ;-------------------------------------------------------------------------
   317                                  int_75:
   318                                  	push	ax
   319                                  	mov	al,20h
   320                                  	out	pic2_reg0,al	; signal EOI to the slave PIC
   321                                  	out	pic1_reg0,al	; signal EOI to the master PIC
   322                                  	pop	ax
   323                                  	int	02h		; call NMI ISR
   324                                  	iret
   325                                  
   326                                  %endif ; SECOND_PIC
   327                                  
   328                                  ;=========================================================================
   329                                  ; boot_os -Boot the OS
   330                                  ;-------------------------------------------------------------------------
   331                                  boot_os:
   332                                  
   333                                  ;-------------------------------------------------------------------------
   334                                  ; Check for F1 (setup key), run setup utility if pressed
   335                                  
   336 0000283E B401                    	mov	ah,01h
   337 00002840 CD16                    	int	16h
   338 00002842 740E                    	jz	.no_key
   339 00002844 B400                    	mov	ah,00h
   340 00002846 CD16                    	int	16h			; read the keystroke
   341 00002848 3D003B                  	cmp	ax,3B00h		; F1?
   342 0000284B 7505                    	jne	.no_key
   343 0000284D 800E120001              	or	byte [post_flags],post_setup
   344                                  .no_key:
   345                                  
   346 00002852 F606120001              	test	byte [post_flags],post_setup
   347 00002857 7403                    	jz	.no_setup
   348                                  
   349                                  %ifdef BIOS_SETUP
   350 00002859 E84AE9                  	call	nvram_setup
   351                                  %endif ; BIOS_SETUP
   352                                  
   353                                  .no_setup:
   354                                  
   355                                  %ifdef TURBO_MODE
   356                                  %ifdef BIOS_SETUP
   357 0000285C E877E7                  	call	get_config_a		; read BIOS configuration byte A
   358 0000285F 2403                    	and	al,nvram_trbo_mask
   359 00002861 E88FFF                  	call	set_cpu_clk		; set CPU clock
   360                                  %endif ; BIOS_SETUP
   361                                  %endif ; TURBO_MODE
   362                                  
   363 00002864 B000                    	mov	al,e_boot		; boot the OS POST code
   364 00002866 E680                    	out	post_reg,al
   365                                  
   366 00002868 BE[4504]                	mov	si,msg_boot
   367 0000286B E80200                  	call	print
   368 0000286E CD19                    	int	19h			; boot the OS
   369                                  
   370                                  ;=========================================================================
   371                                  ; print - print ASCIIZ string to the console
   372                                  ; Input:
   373                                  ;	CS:SI - pointer to string to print
   374                                  ; Output:
   375                                  ;	none
   376                                  ;-------------------------------------------------------------------------
   377                                  print:
   378 00002870 9C                      	pushf
   379 00002871 50                      	push	ax
   380 00002872 53                      	push	bx
   381 00002873 56                      	push	si
   382 00002874 1E                      	push	ds
   383 00002875 0E                      	push	cs
   384 00002876 1F                      	pop	ds
   385 00002877 FC                      	cld
   386                                  .1:
   387 00002878 AC                      	lodsb
   388 00002879 08C0                    	or	al,al
   389 0000287B 7408                    	jz	.exit
   390 0000287D B40E                    	mov	ah,0Eh
   391 0000287F B30F                    	mov	bl,0Fh
   392 00002881 CD10                    	int	10h
   393 00002883 EBF3                    	jmp	.1
   394                                  .exit:
   395 00002885 1F                      	pop	ds
   396 00002886 5E                      	pop	si
   397 00002887 5B                      	pop	bx
   398 00002888 58                      	pop	ax
   399 00002889 9D                      	popf
   400 0000288A C3                      	ret
   401                                  
   402                                  ;=========================================================================
   403                                  ; print_hex - print 16-bit number in hexadecimal
   404                                  ; Input:
   405                                  ;	AX - number to print
   406                                  ; Output:
   407                                  ;	none
   408                                  ;-------------------------------------------------------------------------
   409                                  print_hex:
   410 0000288B 86C4                    	xchg	al,ah
   411 0000288D E80600                  	call	print_byte		; print the upper byte
   412 00002890 86C4                    	xchg	al,ah
   413 00002892 E80100                  	call	print_byte		; print the lower byte
   414 00002895 C3                      	ret
   415                                  
   416                                  ;=========================================================================
   417                                  ; print_byte - print a byte in hexadecimal
   418                                  ; Input:
   419                                  ;	AL - byte to print
   420                                  ; Output:
   421                                  ;	none
   422                                  ;-------------------------------------------------------------------------
   423                                  print_byte:
   424 00002896 D0C0                    	rol	al,1
   425 00002898 D0C0                    	rol	al,1
   426 0000289A D0C0                    	rol	al,1
   427 0000289C D0C0                    	rol	al,1
   428 0000289E E82D00                  	call	print_digit
   429 000028A1 D0C0                    	rol	al,1
   430 000028A3 D0C0                    	rol	al,1
   431 000028A5 D0C0                    	rol	al,1
   432 000028A7 D0C0                    	rol	al,1
   433 000028A9 E82200                  	call	print_digit
   434 000028AC C3                      	ret
   435                                  
   436                                  ;=========================================================================
   437                                  ; print_dec - print 16-bit number in decimal
   438                                  ; Input:
   439                                  ;	AX - number to print
   440                                  ; Output:
   441                                  ;	none
   442                                  ;-------------------------------------------------------------------------
   443                                  print_dec:
   444 000028AD 50                      	push	ax
   445 000028AE 51                      	push	cx
   446 000028AF 52                      	push	dx
   447 000028B0 B90A00                  	mov	cx,10		; base = 10
   448 000028B3 E80400                  	call	.print_rec
   449 000028B6 5A                      	pop	dx
   450 000028B7 59                      	pop	cx
   451 000028B8 58                      	pop	ax
   452 000028B9 C3                      	ret
   453                                  
   454                                  .print_rec:			; print all digits recursively
   455 000028BA 52                      	push	dx
   456 000028BB 31D2                    	xor	dx,dx		; DX = 0
   457 000028BD F7F1                    	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
   458 000028BF 83F800                  	cmp	ax,0
   459 000028C2 7403                    	je	.below10
   460 000028C4 E8F3FF                  	call	.print_rec	; print number / 10 recursively
   461                                  .below10:
   462 000028C7 89D0                    	mov	ax,dx		; reminder is in DX
   463 000028C9 E80200                  	call	print_digit	; print reminder
   464 000028CC 5A                      	pop	dx
   465 000028CD C3                      	ret
   466                                  
   467                                  ;=========================================================================
   468                                  ; print_digit - print hexadecimal digit
   469                                  ; Input:
   470                                  ;	AL - bits 3...0 - digit to print (0...F)
   471                                  ; Output:
   472                                  ;	none
   473                                  ;-------------------------------------------------------------------------
   474                                  print_digit:
   475 000028CE 50                      	push	ax
   476 000028CF 53                      	push	bx
   477 000028D0 240F                    	and	al,0Fh
   478 000028D2 0430                    	add	al,'0'			; convert to ASCII
   479 000028D4 3C39                    	cmp	al,'9'			; less or equal 9?
   480 000028D6 7602                    	jna	.1
   481 000028D8 0407                    	add	al,'A'-'9'-1		; a hex digit
   482                                  .1:
   483 000028DA B40E                    	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
   484 000028DC B307                    	mov	bl,07h			; just in case we're in graphic mode
   485 000028DE CD10                    	int	10h
   486 000028E0 5B                      	pop	bx
   487 000028E1 58                      	pop	ax
   488 000028E2 C3                      	ret
   489                                  
   490                                  %ifdef EBDA_SIZE
   491                                  ;=========================================================================
   492                                  ; reserve_ebda - reserve EBDA (Extended BIOS Data Area) if using PS2_MOUSE
   493                                  ; Input:
   494                                  ;	AX = memory size in KiB
   495                                  ; Notes:
   496                                  ;	- Assumes that EBDA memory was cleaned
   497                                  ;	- Does not reserve EBDA if PS/2 auxiliary device is not detected
   498                                  ;-------------------------------------------------------------------------
   499                                  reserve_ebda:
   500                                  	push	ax
   501                                  	push	cx
   502                                  	test	word [equipment_list],equip_mouse
   503                                  	jz	.no_mouse
   504                                  	mov	ax,word [memory_size]	; get conventional memory size
   505                                  	sub	ax,EBDA_SIZE		; substract EBDA size
   506                                  	mov	word [memory_size],ax	; store new conventional memory size
   507                                  	mov	cl,6
   508                                  	shl	ax,cl			; convert to segment
   509                                  	mov	word [ebda_segment],ax	; store EBDA segment to BIOS variable
   510                                  	push	ds
   511                                  	mov	ds,ax
   512                                  	mov	ax,EBDA_SIZE
   513                                      	mov	byte [ebda_size],al	; store EBDA size to EBDA
   514                                  	pop	ds
   515                                  	push	si
   516                                  	mov	si,msg_ebda
   517                                  	call	print
   518                                  	call	print_dec
   519                                  	mov	si,msg_kib
   520                                  	call	print
   521                                  	pop	si
   522                                  .no_mouse:
   523                                  	pop	cx
   524                                  	pop	ax
   525                                  	ret
   526                                  %endif ; EBDA_SIZE
   527                                  
   528                                  ;=========================================================================
   529                                  ; print display type
   530                                  ;-------------------------------------------------------------------------
   531                                  print_display:
   532 000028E3 BE[1E02]                	mov	si,msg_disp
   533 000028E6 E887FF                  	call	print
   534 000028E9 BE[3B02]                	mov	si,msg_disp_ega		; assume EGA or later
   535 000028EC 833EA80000              	cmp	word [vga_table_ptr],0	; check if BIOS Video Save/Override
   536                                  					; Pointer Table address is initialized
   537 000028F1 751D                    	jnz	.print_disp
   538 000028F3 833EAA0000              	cmp	word [vga_table_ptr+2],0
   539 000028F8 7516                    	jnz	.print_disp
   540                                  					; Not an EGA/VGA - check equipment word
   541 000028FA A01000                  	mov	al,byte [equipment_list] ; get equipment - low byte
   542 000028FD 2430                    	and	al,equip_video		; get video adapter type
   543 000028FF BE[7602]                	mov	si,msg_disp_mda
   544 00002902 3C30                    	cmp	al,equip_mono		; monochrome?
   545 00002904 740A                    	jz	.print_disp
   546 00002906 BE[5A02]                	mov	si,msg_disp_cga_80
   547 00002909 3C20                    	cmp	al,equip_color_80	; CGA 80x25?
   548 0000290B 7403                    	jz	.print_disp
   549 0000290D BE[6802]                	mov	si,msg_disp_cga_40	; Must be CGA 40x25
   550                                  .print_disp:
   551 00002910 E85DFF                  	call	print
   552 00002913 C3                      	ret
   553                                  
   554                                  %ifdef PS2_MOUSE
   555                                  
   556                                  ;=========================================================================
   557                                  ; print PS/2 mouse presence
   558                                  ;-------------------------------------------------------------------------
   559                                  
   560                                  print_mouse:
   561                                  	mov	si,msg_mouse
   562                                  	call	print
   563                                  	mov	si,msg_absent
   564                                  	test	byte [equipment_list],equip_mouse
   565                                  	jz	.print_mouse
   566                                  	mov	si,msg_present
   567                                  .print_mouse:
   568                                  	call	print
   569                                  	ret
   570                                  
   571                                  %endif ; PS2_MOUSE
   572                                  
   573                                  ;=========================================================================	
   574                                  ; interrupt_table - offsets only (BIOS segment is always 0F000h)
   575                                  ;-------------------------------------------------------------------------
   576                                  interrupt_table:
   577 00002914 [535F]                  	dw	int_dummy		; INT 00 - Divide by zero
   578 00002916 [535F]                  	dw	int_dummy		; INT 01 - Single step
   579 00002918 [C342]                  	dw	int_02			; INT 02 - Non-maskable interrupt
   580 0000291A [535F]                  	dw	int_dummy		; INT 03 - Debugger breakpoint
   581 0000291C [535F]                  	dw	int_dummy		; INT 04 - Integer overlow (into)
   582 0000291E [545F]                  	dw	int_05			; INT 05 - BIOS Print Screen
   583 00002920 [535F]                  	dw	int_dummy		; INT 06
   584 00002922 [535F]                  	dw	int_dummy		; INT 07
   585 00002924 [A55E]                  	dw	int_08			; INT 08 - IRQ0 - Timer Channel 0
   586 00002926 [8749]                  	dw	int_09			; INT 09 - IRQ1 - Keyboard
   587 00002928 [235F]                  	dw	int_ignore		; INT 0A - IRQ2
   588 0000292A [235F]                  	dw	int_ignore		; INT 0B - IRQ3
   589 0000292C [235F]                  	dw	int_ignore		; INT 0C - IRQ4
   590 0000292E [235F]                  	dw	int_ignore		; INT 0D - IRQ5
   591 00002930 [574F]                  	dw	int_0E			; INT 0E - IRQ6 - Floppy
   592 00002932 [235F]                  	dw	int_ignore		; INT 0F - IRQ7
   593 00002934 [6550]                  	dw	int_10			; INT 10 - BIOS Video Services
   594 00002936 [4D58]                  	dw	int_11			; INT 11 - BIOS Get Equipment List
   595 00002938 [4158]                  	dw	int_12			; INT 12 - BIOS Get Memory Size
   596 0000293A [594C]                  	dw	int_13			; INT 13 - BIOS Floppy Disk Services
   597 0000293C [2947]                  	dw	int_14			; INT 14 - BIOS Serial Communications
   598 0000293E [5958]                  	dw	int_15			; INT 15 - BIOS Misc. System Services
   599 00002940 [2E48]                  	dw	int_16			; INT 16 - BIOS Keyboard Services
   600 00002942 [D24F]                  	dw	int_17			; INT 17 - BIOS Parallel Printer svc.
   601 00002944 [5043]                  	dw	int_18			; INT 18 - BIOS Start ROM BASIC
   602 00002946 [F246]                  	dw	int_19			; INT 19 - BIOS Boot the OS
   603 00002948 [6E5E]                  	dw	int_1A			; INT 1A - BIOS Time Services
   604 0000294A [535F]                  	dw	int_dummy		; INT 1B - DOS Keyboard Break
   605 0000294C [535F]                  	dw	int_dummy		; INT 1C - User Timer Tick
   606 0000294E [A450]                  	dw	int_1D			; INT 1D - Video Parameters Table
   607 00002950 [C74F]                  	dw	int_1E			; INT 1E - Floppy Parameters Table
   608                                  %ifndef MACHINE_XT
   609 00002952 [4A0A]                  	dw	int_1F			; INT 1F - Font For Graphics Mode
   610                                  %else ; MACHINE_XT
   611                                  	dw	int_ignore
   612                                  %endif ; MACHINE_XT
   613                                  
   614                                  %ifdef SECOND_PIC
   615                                  interrupt_table2:
   616                                  	dw	int_70			; INT 70 - IRQ8 - RTC
   617                                  	dw	int_71			; INT 71 - IRQ9 - redirection
   618                                  	dw	int_ignore2		; INT 72 - IRQ10
   619                                  	dw	int_ignore2		; INT 73 - IRQ11
   620                                  %ifndef PS2_MOUSE
   621                                  	dw	int_ignore2		; INT 74 - IRQ12 - PS/2 mouse
   622                                  %else ; PS2_MOUSE
   623                                  	dw	int_74			; INT 74 - IRQ12 - PS/2 mouse
   624                                  %endif ; PS2_MOUSE
   625                                  	dw	int_75			; INT 75 - IRQ13 - FPU
   626                                  	dw	int_ignore2		; INT 76 - IRQ14
   627                                  	dw	int_ignore2		; INT 77 - IRQ15
   628                                  %endif ; SECOND_PIC
   629                                  
   630                                  ;=========================================================================
   631                                  ; init_v40 - Initialize NEC V40 built-in peripheral registers
   632                                  ;-------------------------------------------------------------------------	
   633                                  %ifdef MACHINE_HOMEBREW8088
   634                                  init_v40:
   635                                  	mov	dx,0FFFEh		; 0FFFEh: OPCN - INT Select
   636                                  	xor	al,al
   637                                  	out	dx,al
   638                                  
   639                                  	dec	dx			; 0FFFDh: OPSEL - Enable Peripheral
   640                                  	mov	al,06h			; Only enable the interrupt controller and timer
   641                                  	out	dx,al
   642                                  
   643                                  	dec	dx			; 0FFFCh: OPHA - On chip peripheral high address register 
   644                                  	mov	al,00h			; Any 256K block except overlap with resgisters 
   645                                  	out	dx,al
   646                                  
   647                                  	dec	dx			; 0FFFBh: DULA - DMA lower address register
   648                                  	xor	al,al			; Not initialized as not used
   649                                  	out	dx,al			; to save space
   650                                  
   651                                  	dec	dx			; 0FFFAh: IULA  - 8259 lower address register
   652                                  	mov	al,20h									
   653                                  	out	dx,al
   654                                  
   655                                  	dec	dx			; 0FFF9h: TULA - 8254 lower address register
   656                                  	mov	al,40h
   657                                  	out	dx,al
   658                                  
   659                                  	dec	dx			; 0FFF8h: SULA - Serial port lower address register
   660                                  	mov	al,0D0h			; Not initialized since not used
   661                                  	out	dx,al
   662                                  
   663                                  	dec	dx			; 0FFF7h: RES
   664                                  
   665                                  	dec	dx			; 0FFF6h: WCY2 - WAIT 
   666                                  	mov	al,01h			; Sets the number of wait cycles for DMA and refresh cycles
   667                                  	out	dx,al
   668                                  
   669                                  	dec	dx			; 0FFF5h: WCY1 - WAIT
   670                                  	mov	al,0FFh			; Bits 7-6: I/O, 5-4: upper mem, 3-2: middle mem, 1-0: lower mem
   671                                  					; 00 = no wait, 11 = longest wait
   672                                  	out	dx,al
   673                                  
   674                                  	dec	dx			; 0FFF4h: WMB - Memory boundaries
   675                                  	mov	al,06h			; Bits 6-4: lowest memory, BITS 2-0 highest memory, middle is everything else 0 
   676                                  	out	dx,al
   677                                  
   678                                  	dec	dx 			; 0FFF3h: RES
   679                                  
   680                                  	dec	dx			; 0FFF2h: RFC - Refresh control
   681                                  	xor	al,al			; NO 82
   682                                  	out	dx,al
   683                                  
   684                                  	dec	dx			; 0FFF1h: RES
   685                                  
   686                                  	dec	dx			; 0FFF0h: TCKS - Timer pin selection 
   687                                  	mov	al,14h			; 1 = pin, 0 = internal, bits 1-0: prescale div for internal
   688                                  	out	dx,al
   689                                  
   690                                  	; We formerly set up the interrupt controller and timer here, but the
   691                                  	; mainline BIOS does this itself.  Removing this and the beep as soon as power on occurs
   692                                  	; frees critical ROM space if we want to do something else clever here but keep IBM BIOS alignment.
   693                                  	; Silence the static on the beeper ASAP (with 8088 card)
   694                                  	xor	al,al
   695                                  	out	ppi_pb_reg,al
   696                                  
   697                                  	jmp	post_init_v40
   698                                  %endif
   699                                  
   700                                  ;=========================================================================
   701                                  ; cold_start, warm_start - BIOS POST (Power on Self Test) starts here
   702                                  ;-------------------------------------------------------------------------	
   703 00002954 FF<rep 1707h>           	setloc	0E05Bh		; POST Entry Point
   703          ******************       warning: Inserting 5895 bytes [-w+user]
   704                                  cold_start:
   705 0000405B B84000                  	mov	ax,biosdseg
   706 0000405E 8ED8                    	mov	ds,ax
   707 00004060 C70672000000            	mov	word [warm_boot],0	; indicate cold boot
   708                                  
   709                                  warm_start:
   710                                  	%ifdef MACHINE_HOMEBREW8088
   711                                  	jmp init_v40
   712                                  	post_init_v40:
   713                                  	%endif; MACHINE_HOMEBREW8088
   714 00004066 FA                      	cli				; disable interrupts
   715 00004067 FC                      	cld				; clear direction flag
   716 00004068 B001                    	mov	al,e_cpu_test
   717 0000406A E680                    	out	post_reg,al		; POST start code
   718                                  
   719                                  ;-------------------------------------------------------------------------
   720                                  ; test CPU's FLAG register
   721                                  
   722 0000406C 31C0                    	xor	ax,ax			; AX = 0
   723 0000406E 724A                    	jb	cpu_fail
   724 00004070 7048                    	jo	cpu_fail
   725 00004072 7846                    	js	cpu_fail
   726 00004074 7544                    	jnz	cpu_fail
   727 00004076 7B42                    	jpo	cpu_fail
   728 00004078 83C001                  	add	ax,1			; AX = 1
   729 0000407B 743D                    	jz	cpu_fail
   730 0000407D 7A3B                    	jpe	cpu_fail
   731 0000407F 2D0280                  	sub	ax,8002h
   732 00004082 7836                    	js	cpu_fail
   733 00004084 40                      	inc	ax
   734 00004085 7133                    	jno	cpu_fail
   735 00004087 D1E0                    	shl	ax,1
   736 00004089 732F                    	jnb	cpu_fail
   737 0000408B 752D                    	jnz	cpu_fail
   738 0000408D D1E0                    	shl	ax,1
   739 0000408F 7229                    	jb	cpu_fail
   740                                  
   741                                  ;-------------------------------------------------------------------------
   742                                  ; Test CPU registers
   743                                  
   744 00004091 B8AAAA                  	mov	ax,0AAAAh
   745                                  .1:
   746 00004094 8ED8                    	mov	ds,ax
   747 00004096 8CDB                    	mov	bx,ds
   748 00004098 8EC3                    	mov	es,bx
   749 0000409A 8CC1                    	mov	cx,es
   750 0000409C 8ED1                    	mov	ss,cx
   751 0000409E 8CD2                    	mov	dx,ss
   752 000040A0 89D5                    	mov	bp,dx
   753 000040A2 89EC                    	mov	sp,bp
   754 000040A4 89E6                    	mov	si,sp
   755 000040A6 89F7                    	mov	di,si
   756 000040A8 81FFAAAA                	cmp	di,0AAAAh
   757 000040AC 7506                    	jnz	.2
   758 000040AE 89F8                    	mov	ax,di
   759 000040B0 F7D0                    	not	ax
   760 000040B2 EBE0                    	jmp	.1
   761                                  .2:
   762 000040B4 81FF5555                	cmp	di,5555h
   763 000040B8 741A                    	jz	cpu_ok
   764                                  
   765                                  cpu_fail:
   766 000040BA B052                    	mov	al,e_cpu_fail
   767 000040BC E680                    	out	post_reg,al
   768                                  
   769                                  ;-------------------------------------------------------------------------
   770                                  ; CPU error: continious beep - 400 Hz
   771                                  
   772 000040BE B0B6                    	mov	al,0B6h
   773 000040C0 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
   774 000040C2 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
   775 000040C5 E642                    	out	pit_ch2_reg,al
   776 000040C7 88E0                    	mov	al,ah
   777 000040C9 E642                    	out	pit_ch2_reg,al
   778 000040CB E461                    	in	al,ppi_pb_reg
   779 000040CD 0C03                    	or	al,3			; turn speaker on and enable
   780 000040CF E661                    	out	ppi_pb_reg,al		; PIT channel 2 to speaker
   781                                  
   782                                  .1:
   783 000040D1 F4                      	hlt
   784 000040D2 EBFD                    	jmp	.1
   785                                  
   786                                  ;-------------------------------------------------------------------------
   787                                  ; CPU test passed
   788                                  
   789                                  cpu_ok:
   790                                  
   791                                  ;-------------------------------------------------------------------------
   792                                  ; disable NMI, turbo mode, and video output on CGA and MDA
   793                                  
   794 000040D4 B002                    	mov	al,e_init_cfg
   795 000040D6 E680                    	out	post_reg,al
   796                                  
   797                                  %ifdef AT_NMI
   798                                  	mov	al,0Dh & nmi_disa_mask
   799                                  	out	nmi_mask_reg,al		; disable NMI
   800                                  	jmp	$+2
   801                                  	in	al,(nmi_mask_reg+1)	; dummy read to keep RTC happy
   802                                  %else ; AT_NMI
   803 000040D8 B000                    	mov	al,nmi_disable
   804 000040DA E6A0                    	out	nmi_mask_reg,al		; disable NMI
   805                                  %endif ; AT_NMI
   806                                  
   807                                  %ifdef MACHINE_XI8088
   808                                  	mov	al,iochk_disable	; clear and disable ~IOCHK
   809                                  	out	ppi_pb_reg,al
   810                                  	mov	al,00h			; clear turbo bit
   811                                  	out	ppi_pb_reg,al		; and also turn off the speaker
   812                                  %endif ; MACHINE_XI8088
   813                                  
   814                                  %ifdef MACHINE_FE2010A
   815 000040DC B001                    	mov	al,fe_par_disable	; Disable parity checking
   816 000040DE E663                    	out	fe_config_reg,al	; FE2010A chipset configuration register
   817 000040E0 B0B0                    	mov	al,10110000b		; Clear keyboard, disable keyboard clock
   818                                  					; disable IOCHCK NMI, disable MB DRAM NMI
   819 000040E2 E661                    	out	ppi_pb_reg,al		; Disable parity and IOCHK
   820                                  %endif ; MACHINE_FE2010A
   821                                  
   822                                  %ifdef MACHINE_BOOK8088
   823                                  	mov	al,00h			; clear turbo bit
   824                                  	out	ppi_pb_reg,al		; and also turn off the speaker
   825                                  %endif ; MACHINE_BOOK8088
   826                                  
   827                                  %ifdef MACHINE_XT
   828                                  	mov	al,ppi_cwd_value	; PPI port A and port C inputs
   829                                  	out	ppi_cwd_reg,al		; PPI control word register
   830                                  	mov	al,10100101b		; Clear keyboard, disable keyboard clock
   831                                  					; disable IOCHCK NMI, enable MB DRAM NMI
   832                                  	out	ppi_pb_reg,al
   833                                  %endif ; MACHINE_XT
   834                                  
   835 000040E4 B000                    	mov	al,00h
   836 000040E6 BAD803                  	mov	dx,cga_mode_reg
   837 000040E9 EE                      	out	dx,al			; disable video output on CGA
   838 000040EA FEC0                    	inc	al
   839 000040EC BAB803                  	mov	dx,mda_mode_reg		; disable video output on MDA
   840 000040EF EE                      	out	dx,al			; and set MDA high-resolution mode bit
   841                                  
   842                                  ;-------------------------------------------------------------------------
   843                                  ; Initialize DMAC (8237)
   844                                   
   845 000040F0 B003                    	mov	al,e_init_dmac
   846 000040F2 E680                    	out	post_reg,al
   847 000040F4 E60D                     	out	0Dh,al			; DMA Master Clear register - reset DMA
   848                                  %ifdef MACHINE_XT
   849                                  					; set up DRAM refresh on DMA channel 0
   850                                  	mov	al,0ffh			; 16-bit memory refresh counter = 0FFFFh
   851                                  	out	dmac_ch0_count_reg,al	; write low byte
   852                                  	nop
   853                                  	out	dmac_ch0_count_reg,al	; write high byte
   854                                  	inc	ax			; al = 0
   855                                  	out	dmac_mask_reg,al	; enable DMA channel 0
   856                                  	mov	al,58h			; single mode, auto-init, read, channel 0
   857                                  %else ; MACHINE_XT
   858 000040F6 B040                     	mov	al,40h			; single mode, verify, channel 0
   859                                  %endif ; MACHINE_XT
   860 000040F8 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   861 000040FA B041                     	mov	al,41h			; single mode, verify, channel 1
   862 000040FC E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   863 000040FE B042                     	mov	al,42h			; single mode, verify, channel 2
   864 00004100 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   865 00004102 B043                     	mov	al,43h			; single mode, verify, channel 3
   866 00004104 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   867 00004106 B000                     	mov	al,0			; DMA Command register bits:
   868                                   					; DACK active low, DREQ active high,
   869                                   					; late write, fixed priority,
   870                                   					; normal timing, controller enable
   871                                   					; channel 0 addr hold disable
   872                                   					; memory to memory disable
   873 00004108 E608                     	out	08h,al			; DMA Command register
   874 0000410A E681                     	out	81h,al			; DMA Page, channel 2
   875 0000410C E682                     	out	82h,al			; DMA Page, channel 3
   876 0000410E E683                     	out	83h,al			; DMA Page, channels 0,1
   877                                  
   878                                  ;-------------------------------------------------------------------------
   879                                  ; Test first 32 KiB (MIN_RAM_SIZE) of RAM
   880                                  
   881 00004110 B004                    	mov	al,e_low_ram_test
   882 00004112 E680                    	out	post_reg,al
   883 00004114 31F6                    	xor	si,si
   884 00004116 31FF                    	xor	di,di
   885 00004118 8EDF                    	mov	ds,di
   886 0000411A 8EC7                    	mov	es,di
   887 0000411C 8B167204                	mov	dx,word [warm_boot+biosdseg*16] ; save soft reset flag to DX
   888 00004120 B8AA55                  	mov	ax,55AAh		; first test pattern
   889 00004123 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   890 00004126 F3AB                        rep	stosw				; store test pattern
   891 00004128 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   892                                  .1:
   893 0000412B AD                      	lodsw
   894 0000412C 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
   895 0000412F 7524                    	jne	low_ram_fail
   896 00004131 E2F8                    	loop	.1
   897 00004133 31F6                    	xor	si,si
   898 00004135 31FF                    	xor	di,di
   899 00004137 B855AA                  	mov	ax,0AA55h		; second test pattern
   900 0000413A B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   901 0000413D F3AB                        rep stosw				; store test pattern
   902 0000413F B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   903                                  .2:
   904 00004142 AD                      	lodsw
   905 00004143 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
   906 00004146 750D                    	jne	low_ram_fail
   907 00004148 E2F8                    	loop	.2
   908 0000414A 31FF                    	xor	di,di
   909 0000414C 31C0                    	xor	ax,ax			; zero
   910 0000414E B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   911 00004151 F3AB                        rep stosw				; zero the memory
   912 00004153 EB29                    	jmp	low_ram_ok		; test passed
   913                                  
   914                                  low_ram_fail:
   915 00004155 B054                    	mov	al,e_low_ram_fail	; test failed
   916 00004157 E680                    	out	post_reg,al
   917                                  
   918                                  ;-------------------------------------------------------------------------
   919                                  ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
   920                                  
   921 00004159 B0B6                    	mov	al,0B6h
   922 0000415B E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
   923 0000415D B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
   924 00004160 E642                    	out	pit_ch2_reg,al
   925 00004162 88E0                    	mov	al,ah
   926 00004164 E642                    	out	pit_ch2_reg,al
   927 00004166 E461                    	in	al,ppi_pb_reg
   928                                  .1:
   929 00004168 0C03                    	or	al,3			; turn speaker on and enable
   930 0000416A E661                    	out	ppi_pb_reg,al		; PIT channel 2 to speaker
   931 0000416C B90000                  	mov	cx,0
   932                                  .2:
   933 0000416F 90                      	nop
   934 00004170 E2FD                    	loop	.2
   935 00004172 24FC                    	and	al,0FCh			; turn of speaker
   936 00004174 E661                    	out	ppi_pb_reg,al
   937 00004176 B90000                  	mov	cx,0
   938                                  .3:
   939 00004179 90                      	nop
   940 0000417A E2FD                    	loop	.3
   941 0000417C EBEA                    	jmp	.1
   942                                  
   943                                  ;-------------------------------------------------------------------------
   944                                  ; Low memory test passed
   945                                  
   946                                  low_ram_ok:
   947 0000417E 89167204                	mov	word [warm_boot+biosdseg*16],dx ; restore soft reset flag
   948                                  
   949                                  ;-------------------------------------------------------------------------
   950                                  ; Set up stack - using upper 256 bytes of interrupt table
   951                                  
   952 00004182 B83000                  	mov	ax,0030h
   953 00004185 8ED0                    	mov	ss,ax
   954 00004187 BC0001                  	mov	sp,0100h
   955                                  
   956                                  ;-------------------------------------------------------------------------
   957                                  ; Initialize interrupt table
   958                                  
   959 0000418A B005                    	mov     al,e_int_table
   960 0000418C E680                    	out	post_reg,al
   961 0000418E 0E                      	push	cs
   962 0000418F 1F                      	pop	ds
   963 00004190 31FF                    	xor	di,di
   964 00004192 8EC7                    	mov	es,di
   965 00004194 BE[1429]                	mov	si,interrupt_table
   966 00004197 B92000                  	mov	cx,0020h		; 32 Interrupt vectors
   967 0000419A B800F0                  	mov	ax,bioscseg
   968                                  .1:
   969 0000419D A5                      	movsw				; copy ISR address (offset part)
   970 0000419E AB                      	stosw				; store segment part
   971 0000419F E2FC                    	loop	.1
   972                                  %ifdef SECOND_PIC
   973                                  	mov	di,70h*4		; starting from IRQ 70
   974                                  	mov	si,interrupt_table2
   975                                  	mov	cx,8			; 8 Interrupt vectors
   976                                  .2:
   977                                  	movsw				; copy ISR address (offset part)
   978                                  	stosw				; store segment part
   979                                  	loop	.2
   980                                  %endif ; SECOND_PIC
   981                                  
   982                                  ;-------------------------------------------------------------------------
   983                                  ; set DS to BIOS data area
   984                                  
   985 000041A1 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
   986 000041A4 8ED8                    	mov	ds,ax
   987                                  
   988                                  ;-------------------------------------------------------------------------
   989                                  ; Initialize PIT (8254 timer)
   990                                  
   991 000041A6 B036                    	mov	al,36h			; channel 0, LSB & MSB, mode 3, binary
   992 000041A8 E643                    	out	pit_ctl_reg,al
   993 000041AA B000                    	mov	al,0
   994 000041AC E640                    	out	pit_ch0_reg,al
   995 000041AE E640                    	out	pit_ch0_reg,al
   996 000041B0 B054                    	mov	al,54h			; channel 1, LSB only, mode 2, binary
   997 000041B2 E643                    	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
   998 000041B4 B012                    	mov	al,12h			; or for delays (using port_b, bit 4)
   999 000041B6 E641                    	out	pit_ch1_reg,al		; pulse every 15ms
  1000                                  
  1001                                  ;-------------------------------------------------------------------------
  1002                                  ; Play "power on" sound - also tests PIT functionality
  1003                                  
  1004 000041B8 B006                    	mov     al,e_pit_init
  1005 000041BA E680                    	out	post_reg,al
  1006 000041BC E89FE4                  	call	sound
  1007                                  
  1008                                  ;-------------------------------------------------------------------------
  1009                                  ; Initialize PIC (8259)
  1010                                  
  1011 000041BF B007                    	mov	al,e_pic_init
  1012 000041C1 E680                    	out	post_reg,al
  1013                                  %ifdef SECOND_PIC
  1014                                  	mov	al,11h			; ICW1 - edge triggered, cascade, ICW4
  1015                                  	out	pic1_reg0,al
  1016                                  	out	pic2_reg0,al
  1017                                  	mov	al,8			; ICW2 - interrupt vector offset = 8
  1018                                  	out	pic1_reg1,al
  1019                                  	mov	al,70h			; ICW2 - interrupt vector offset = 70h
  1020                                  	out	pic2_reg1,al
  1021                                  	mov	al,4			; ICW3 - slave is connected to IR2
  1022                                  	out	pic1_reg1,al
  1023                                  	mov	al,2			; ICW3 - slave ID = 2 (IR2)
  1024                                  	out	pic2_reg1,al
  1025                                  	mov	al,1			; ICW4 - 8086/8088
  1026                                  	out	pic1_reg1,al
  1027                                  	out	pic2_reg1,al
  1028                                  %else
  1029 000041C3 B013                    	mov	al,13h			; ICW1 - edge triggered, single, ICW4
  1030 000041C5 E620                    	out	pic1_reg0,al
  1031 000041C7 B008                    	mov	al,8			; ICW2 - interrupt vector offset = 8
  1032 000041C9 E621                    	out	pic1_reg1,al
  1033 000041CB B009                    	mov	al,9			; ICW4 - buffered mode, 8086/8088
  1034 000041CD E621                    	out	pic1_reg1,al
  1035                                  %endif ; SECOND_PIC
  1036                                  
  1037                                  ;-------------------------------------------------------------------------
  1038                                  ; initialize keyboard controller (8242), keyboard and PS/2 auxiliary device
  1039                                  
  1040 000041CF B008                    	mov	al,e_kbd_init
  1041 000041D1 E680                    	out	post_reg,al
  1042                                  %ifdef AT_KEYBOARD
  1043                                  	call	kbc_init
  1044                                  %else ; AT_KEYBOARD
  1045                                  %ifndef MACHINE_BOOK8088
  1046 000041D3 E461                    	in	al,ppi_pb_reg
  1047 000041D5 243F                    	and	al,00111111b		; set keyboard clock low
  1048 000041D7 E661                    	out	ppi_pb_reg,al
  1049 000041D9 B95629                  	mov	cx,10582		; hold clock low for 20 ms
  1050                                  .kbd_reset_wait:
  1051 000041DC E2FE                    	loop	.kbd_reset_wait
  1052 000041DE 0CC0                    	or	al,11000000b		; set keyboard clear bit, enable clock
  1053 000041E0 E661                    	out	ppi_pb_reg,al
  1054 000041E2 247F                    	and	al,01111111b		; unset keyboard clear bit
  1055 000041E4 E661                    	out	ppi_pb_reg,al
  1056                                  %endif ; MACHINE_BOOK8088
  1057 000041E6 B9E803                  	mov	cx,1000
  1058                                  .kbd_flush:
  1059 000041E9 B401                    	mov 	ah,01h
  1060 000041EB CD16                    	int	16h
  1061 000041ED 7404                    	jz	.kbd_no_key
  1062 000041EF B400                    	mov	ah,00h
  1063 000041F1 CD16                    	int	16h
  1064                                  .kbd_no_key:
  1065 000041F3 E2F4                    	loop	.kbd_flush
  1066                                  
  1067                                  %endif ; AT_KEYBOARD
  1068                                  
  1069 000041F5 E8C309                  	call	kbd_buffer_init		; setup keyboard buffer
  1070                                  
  1071                                  ;-------------------------------------------------------------------------
  1072                                  ; enable interrupts
  1073                                  
  1074 000041F8 B009                    	mov	al,e_int_ena
  1075 000041FA E680                    	out	post_reg,al
  1076                                  %ifdef SECOND_PIC
  1077                                  	mov	al,0B8h		; OSW1: unmask timer, keyboard, IRQ2 and FDC
  1078                                  	out	pic1_reg1,al
  1079                                  %ifndef PS2_MOUSE
  1080                                  	mov	al,0FDh		; OSW1: unmask IRQ9
  1081                                  %else
  1082                                  	mov	al,0EDh		; OSW1: unmask IRQ9 and IRQ12
  1083                                  %endif ; PS2_MOUSE
  1084                                  	out	pic2_reg1,al
  1085                                  %else
  1086 000041FC B0BC                    	mov	al,0BCh		; OSW1: unmask timer, keyboard and FDC
  1087 000041FE E621                    	out	pic1_reg1,al
  1088                                  %endif ; SECOND_PIC
  1089 00004200 FB                      	sti
  1090                                  
  1091                                  %ifdef AT_NMI
  1092                                  	mov	al,0Dh | nmi_enable
  1093                                  	out	nmi_mask_reg,al		; enable NMI
  1094                                  	jmp	$+2
  1095                                  	in	al,(nmi_mask_reg+1)	; dummy read to keep RTC happy
  1096                                  %else ; AT_NMI
  1097 00004201 B080                    	mov	al,nmi_enable
  1098 00004203 E6A0                    	out	nmi_mask_reg,al		; enable NMI
  1099                                  %endif ; AT_NMI
  1100                                  
  1101                                  %ifdef MACHINE_FE2010A or MACHINE_XT
  1102                                  ;-------------------------------------------------------------------------
  1103                                  ; Read video mode switches into equipment_list
  1104 00004205 E461                    	in	al,ppi_pb_reg
  1105                                  %ifdef MACHINE_FE2010A
  1106 00004207 24FD                    	and	al,0FDh		; clear switch select bit - select SW5-SW8
  1107                                  %endif ; MACHINE_FE2010A
  1108                                  %ifdef MACHINE_XT
  1109                                  	or	al,08h		; set switch select bit - select SW5-SW8
  1110                                  %endif ; MACHINE_XT
  1111 00004209 E661                    	out	ppi_pb_reg,al
  1112 0000420B E462                    	in	al,ppi_pc_reg	; read switches SW5-SW8
  1113 0000420D 2403                    	and	al,03h		; video mode is in SW5 and SW6
  1114 0000420F B104                    	mov	cl,4
  1115 00004211 D2E0                    	shl	al,cl		; move video mode to bits 5-4
  1116 00004213 08061000                	or	[equipment_list],al
  1117                                  %endif ; MACHINE_FE2010A or MACHINE_XT
  1118                                  %ifdef MACHINE_BOOK8088
  1119                                  	or	byte [equipment_list],equip_color_80 ; built-in CGA
  1120                                  %endif ; MACHINE_BOOK8088
  1121                                  ; 
  1122                                  ;-------------------------------------------------------------------------
  1123                                  ; look for video BIOS, initialize it if present
  1124                                  
  1125 00004217 B010                    	mov	al,e_vid_bios_scan
  1126 00004219 E680                    	out	post_reg,al
  1127 0000421B BA00C0                  	mov	dx,0C000h
  1128 0000421E BB00C8                  	mov	bx,0C800h
  1129 00004221 E87216                  	call	extension_scan
  1130 00004224 833E670000              	cmp	word [67h],0
  1131 00004229 740F                    	jz	.no_video_bios
  1132 0000422B B011                    	mov	al,e_vid_bios_init
  1133 0000422D E680                    	out	post_reg,al
  1134 0000422F FF1E6700                	call	far [67h]
  1135 00004233 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  1136 00004236 8ED8                    	mov	ds,ax
  1137                                  ; set video bits to 00 - EGA or later (Video adapter with BIOS)		
  1138                                  ;	and	word [equipment_list],~equip_video
  1139 00004238 EB1F                    	jmp	.video_initialized
  1140                                  
  1141                                  .no_video_bios:
  1142 0000423A B012                    	mov	al,e_vid_no_bios
  1143 0000423C E680                    	out	post_reg,al
  1144 0000423E 8A261000                	mov	ah,byte [equipment_list] ; get equipment - low byte
  1145 00004242 80E430                  	and	ah,equip_video		; get video adapter type
  1146 00004245 B007                    	mov	al,07h			; monochrome 80x25 mode
  1147 00004247 80FC30                  	cmp	ah,equip_mono		; monochrome?
  1148 0000424A 7409                    	jz	.set_mode
  1149 0000424C B003                    	mov	al,03h			; color 80x25 mode
  1150 0000424E 80FC20                  	cmp	ah,equip_color_80	; 80x25 color?
  1151 00004251 7402                    	jz	.set_mode
  1152 00004253 B001                    	mov	al,01h			; color 40x24 mode
  1153                                  
  1154                                  .set_mode:
  1155 00004255 B400                    	mov	ah,00h			; INT 10, AH=00 - Set video mode
  1156 00004257 CD10                    	int	10h
  1157                                  
  1158                                  .video_initialized:
  1159                                  
  1160                                  ;-------------------------------------------------------------------------
  1161                                  ; print the copyright message
  1162                                  
  1163 00004259 BE[0000]                	mov	si,msg_copyright
  1164 0000425C E811E6                  	call	print
  1165                                  
  1166                                  %ifdef AT_RTC
  1167                                  
  1168                                  ;-------------------------------------------------------------------------
  1169                                  ; Initialize RTC / NVRAM
  1170                                  ; Read equipment byte from CMOS and set it in BIOS data area
  1171 0000425F E871CC                  	call	rtc_init
  1172                                  
  1173                                  %endif ; AT_RTC
  1174                                  
  1175                                  %ifdef BIOS_SETUP
  1176 00004262 BE[7104]                	mov	si,msg_setup		; print setup prompt
  1177 00004265 E808E6                  	call	print
  1178                                  %endif ; BIOS_SETUP
  1179                                  
  1180                                  
  1181                                  ;-------------------------------------------------------------------------
  1182                                  ; detect and print availability of various equipment
  1183                                  
  1184 00004268 E849E4                  	call	detect_cpu		; detect and print CPU type
  1185 0000426B E8EEE4                  	call	detect_fpu		; detect and print FPU presence
  1186                                  %ifdef MACHINE_FE2010A
  1187 0000426E E830E5                  	call	detect_chipset		; detect and print chipset type
  1188                                  %endif ; MACHINE_FE2010A
  1189                                  %ifdef AT_RTC
  1190 00004271 E8D3CC                  	call	print_rtc		; print current RTC time
  1191                                  %endif ; AT_RTC
  1192 00004274 E86CE6                  	call	print_display		; print display type
  1193                                  %ifdef PS2_MOUSE
  1194                                  	call	print_mouse		; print mouse presence
  1195                                  %endif ; PS2_MOUSE
  1196 00004277 E88AE2                  	call	detect_serial		; detect serial ports and print findings
  1197 0000427A E83DE3                  	call	detect_parallel		; detect parallel ports and print
  1198                                  					; findings
  1199 0000427D E840DD                  	call	detect_floppy		; detect floppy drive types
  1200 00004280 E874DD                  	call	print_floppy		; print floppy drive types
  1201                                  
  1202 00004283 E86B15                  	call	detect_ram		; detect RAM, get RAM size in AX
  1203 00004286 E8C816                  	call	test_ram		; test RAM, get tested RAM size in AX
  1204                                  
  1205 00004289 BE[B203]                	mov	si,msg_ram_total
  1206 0000428C E8E1E5                  	call	print
  1207 0000428F E81BE6                  	call	print_dec		; print RAM size
  1208 00004292 BE[D003]                	mov	si,msg_kib
  1209 00004295 E8D8E5                  	call	print
  1210                                  
  1211                                  ; FE2010A - Configure chipset according to detected equipment
  1212                                  %ifdef MACHINE_FE2010A
  1213                                  ; Write settings for emulated DIP switches
  1214 00004298 A01000                  	mov	al,byte [equipment_list] ; switches are in low byte of equipment
  1215 0000429B 24CE                    	and	al,0CEh			; keep floppy, memory size, and FPU bits
  1216 0000429D E662                    	out	fe_control_reg,al
  1217                                  ; Enable FPU NMI if needed, and lock chipset configuration
  1218 0000429F 2402                    	and	al,equip_fpu		; enable NMI if the FPU is installed
  1219 000042A1 0C08                    	or	al,fe_config_lock	; set lock chipset configuration bit
  1220 000042A3 E663                    	out	fe_config_reg,al
  1221                                  %endif ; MACHINE_FE2010A
  1222                                  
  1223                                  %ifdef EBDA_SIZE
  1224                                  	call	reserve_ebda		; reserve EBDA if needed
  1225                                  
  1226                                  	mov	si,msg_ram_avail
  1227                                  	call	print
  1228                                  	mov	ax,word [memory_size]
  1229                                  	call	print_dec		; print remaining RAM size
  1230                                  	mov	si,msg_kib
  1231                                  	call	print
  1232                                  %endif ; EBDA_SIZE
  1233                                  
  1234 000042A5 E8F714                  	call	detect_rom_ext		; detect and initialize extension ROMs
  1235                                  
  1236 000042A8 E993E5                  	jmp boot_os
  1237                                  
  1238                                  ;=========================================================================
  1239                                  ; int_02 - NMI
  1240                                  ; Note: Xi 8088 only implements IOCHK NMI, system board parity is not
  1241                                  ;	implemented
  1242                                  ;-------------------------------------------------------------------------
  1243 000042AB FF<rep 18h>             	setloc	0E2C3h			; NMI Entry Point
  1243          ******************       warning: Inserting 24 bytes [-w+user]
  1244                                  int_02:
  1245 000042C3 50                      	push	ax
  1246                                  %ifdef AT_NMI
  1247                                  	mov	al,0Dh & nmi_disa_mask
  1248                                  	out	nmi_mask_reg,al		; disable NMI
  1249                                  	jmp	$+2
  1250                                  	in	al,nmi_mask_reg		; read the RTC to keep it happy
  1251                                  %else
  1252 000042C4 B000                    	mov	al,nmi_disable
  1253 000042C6 E6A0                    	out	nmi_mask_reg,al
  1254                                  %endif ; AT_NMI
  1255 000042C8 E461                    	in	al,ppi_pb_reg		; read Port B
  1256 000042CA 88C4                    	mov	ah,al
  1257 000042CC 0C08                    	or	al,iochk_disable	; clear and disable ~IOCHK
  1258 000042CE E661                    	out	ppi_pb_reg,al
  1259 000042D0 A840                    	test	al,iochk_status
  1260 000042D2 7506                    	jnz	.iochk_nmi
  1261 000042D4 88E0                    	mov	al,ah
  1262 000042D6 E661                    	out	ppi_pb_reg,al		; restore original bits
  1263 000042D8 EB23                    	jmp	.exit
  1264                                  
  1265                                  .iochk_nmi:
  1266 000042DA 56                      	push	si
  1267 000042DB BE[FF42]                	mov	si,msg_iochk_nmi
  1268 000042DE E88FE5                  	call	print
  1269 000042E1 5E                      	pop	si
  1270                                  .1:
  1271 000042E2 B400                    	mov	ah,0h
  1272 000042E4 CD16                    	int	16h
  1273 000042E6 0C20                    	or	al,20h			; convert to lower case
  1274 000042E8 3C64                    	cmp	al,'d'
  1275 000042EA 7411                    	je	.exit			; leave NMIs disabled and exit
  1276 000042EC 3C69                    	cmp	al,'i'
  1277 000042EE 7409                    	je	.ignore			; enable NMIs and exit
  1278 000042F0 3C72                    	cmp	al,'r'
  1279 000042F2 7503E964FD              	je	cold_start
  1280 000042F7 EBE9                    	jmp	.1
  1281                                  .ignore:
  1282                                  %ifdef AT_NMI
  1283                                  	mov	al,0Dh | nmi_enable
  1284                                  	call	rtc_read		; enable NMI
  1285                                  %else
  1286 000042F9 B080                    	mov	al,nmi_enable
  1287 000042FB E6A0                    	out	nmi_mask_reg,al
  1288                                  %endif ; AT_NMI
  1289                                  .exit:
  1290 000042FD 58                      	pop	ax
  1291 000042FE CF                      	iret
  1292                                  
  1293                                  msg_iochk_nmi:
  1294 000042FF 494F43484B204E4D49-     	db	"IOCHK NMI detected. Type 'i' to ignore, 'd' to disable NMIs, or 'r' to reboot."
  1294 00004308 206465746563746564-
  1294 00004311 2E2054797065202769-
  1294 0000431A 2720746F2069676E6F-
  1294 00004323 72652C202764272074-
  1294 0000432C 6F2064697361626C65-
  1294 00004335 204E4D49732C206F72-
  1294 0000433E 2027722720746F2072-
  1294 00004347 65626F6F742E       
  1295 0000434D 0D0A00                  	db	0Dh, 0Ah, 00h
  1296                                  
  1297                                  ;=========================================================================
  1298                                  ; int_18 - execute ROM BASIC
  1299                                  ; Note:
  1300                                  ;	Prints an error message since we don't have ROM BASIC
  1301                                  ;-------------------------------------------------------------------------
  1302                                  int_18:
  1303 00004350 BE[0404]                	mov	si,msg_no_basic
  1304 00004353 E81AE5                  	call	print
  1305                                  .1:
  1306 00004356 F4                      	hlt
  1307 00004357 EBFD                    	jmp	.1
  1308                                  
  1309                                  ;=========================================================================
  1310                                  ; int_19 - load and execute the boot sector
  1311                                  ;-------------------------------------------------------------------------
  1312 00004359 FF<rep 399h>            	setloc	0E6F2h			; INT 19 Entry Point
  1312          ******************       warning: Inserting 921 bytes [-w+user]
  1313                                  int_19:
  1314 000046F2 E9F311                  	jmp	ipl
  1315                                  
  1316                                  ;=========================================================================
  1317                                  ; configuration data table
  1318                                  ;-------------------------------------------------------------------------
  1319                                  	setloc	0E6F5h
  1320                                  config_table:
  1321 000046F5 0800                    	dw	.size			; bytes 0 and 1: size of the table
  1322                                  .bytes:
  1323 000046F7 FE                      	db	MODEL_BYTE		; byte 2: model
  1324 000046F8 00                      	db	00h			; byte 3: submodel = 0
  1325 000046F9 00                      	db	00h			; byte 4: release = 0
  1326                                  %ifdef SECOND_PIC
  1327                                  %ifdef AT_RTC
  1328                                  	db	01110000b		; byte 5: feature byte 1
  1329                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1330                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1331                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1332                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1333                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1334                                  ;		||`-- real time clock installed
  1335                                  ;		|`-- 2nd interrupt controller installed
  1336                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1337                                  %else ; AT_RTC
  1338                                  	db	01010000b		; byte 5: feature byte 1
  1339                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1340                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1341                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1342                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1343                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1344                                  ;		||`-- real time clock installed
  1345                                  ;		|`-- 2nd interrupt controller installed
  1346                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1347                                  %endif ; AT_RTC
  1348                                  %else ; SECOND_PIC
  1349                                  %ifdef AT_RTC
  1350 000046FA 20                      	db	00100000b		; byte 5: feature byte 1
  1351                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1352                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1353                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1354                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1355                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1356                                  ;		||`-- real time clock installed
  1357                                  ;		|`-- 2nd interrupt controller installed
  1358                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1359                                  %else ; AT_RTC
  1360                                  	db	00000000b		; byte 5: feature byte 1
  1361                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1362                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1363                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1364                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1365                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1366                                  ;		||`-- real time clock installed
  1367                                  ;		|`-- 2nd interrupt controller installed
  1368                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1369                                  %endif ; AT_RTC
  1370                                  %endif ; SECOND_PIC
  1371 000046FB 00                      	db	00h			; byte 6: feature byte 2
  1372 000046FC 00                      	db	00h			; byte 7: feature byte 3
  1373 000046FD 00                      	db	00h			; byte 8: feature byte 4
  1374 000046FE 00                      	db	00h			; byte 9: feature byte 5
  1375                                  .size	equ	$-.bytes
  1376                                  
  1377                                  ;=========================================================================
  1378                                  ; Includes with fixed entry points (for IBM compatibility)
  1379                                  ;-------------------------------------------------------------------------
  1380                                  
  1381                                  %include	"serial2.inc"		; INT 14 - BIOS Serial Communications
  1382                              <1> ;========================================================================
  1383                              <1> ; serial2.inc -  BIOS Serial Port Communication Services (part 2 of 2)
  1384                              <1> ;       INT 14h, function AH=00h
  1385                              <1> ;       INT 14h, function AH=03h
  1386                              <1> ;       INT 14h, function AH=04h
  1387                              <1> ;       INT 14h, function AH=05h
  1388                              <1> ;	- see serial1.inc for other INT 14h functions
  1389                              <1> ;-------------------------------------------------------------------------
  1390                              <1> ;
  1391                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1392                              <1> ;
  1393                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
  1394                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1395                              <1> ;
  1396                              <1> ; This program is free software: you can redistribute it and/or modify
  1397                              <1> ; it under the terms of the GNU General Public License as published by
  1398                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1399                              <1> ; (at your option) any later version.
  1400                              <1> ;
  1401                              <1> ; This program is distributed in the hope that it will be useful,
  1402                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1403                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1404                              <1> ; GNU General Public License for more details.
  1405                              <1> ;
  1406                              <1> ; You should have received a copy of the GNU General Public License
  1407                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1408                              <1> ;
  1409                              <1> ;=========================================================================
  1410                              <1> 
  1411                              <1> ;=========================================================================
  1412                              <1> ; int_14 - BIOS Serial Port Communication Services
  1413                              <1> ;-------------------------------------------------------------------------
  1414 000046FF FF<rep 2Ah>         <1> 	setloc	0E729h			; INT 14 Entry Point
  1414          ******************  <1>  warning: Inserting 42 bytes [-w+user]
  1415                              <1> int_14:
  1416 00004729 FB                  <1> 	sti
  1417 0000472A 51                  <1> 	push	cx
  1418 0000472B 52                  <1> 	push	dx
  1419 0000472C 56                  <1> 	push	si
  1420 0000472D 1E                  <1> 	push	ds
  1421 0000472E 53                  <1> 	push	bx
  1422 0000472F BB4000              <1> 	mov	bx,biosdseg
  1423 00004732 8EDB                <1> 	mov	ds,bx
  1424 00004734 80FC06              <1> 	cmp	ah,.max/2
  1425 00004737 732B                <1> 	jae	int_14_error		; invalid function number specified
  1426 00004739 83FA04              <1> 	cmp	dx,num_serial
  1427 0000473C 7326                <1> 	jae	int_14_error		; invalid port number specified
  1428 0000473E BE7C00              <1> 	mov	si,serial_timeout	; serial port timeout setting in BDA
  1429 00004741 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  1430 00004743 89D3                <1> 	mov	bx,dx
  1431 00004745 D1E3                <1> 	shl	bx,1
  1432 00004747 8B17                <1> 	mov	dx,word [equip_serial+bx] ; DX = serial port address
  1433 00004749 09D2                <1> 	or	dx,dx
  1434 0000474B 7417                <1> 	jz	int_14_error		; specified port is not installed
  1435 0000474D B700                <1> 	mov	bh,0
  1436 0000474F 88E3                <1> 	mov	bl,ah
  1437 00004751 D1E3                <1> 	shl	bx,1
  1438 00004753 2EFFA7[5847]        <1>     cs	jmp	near [.dispatch+bx]
  1439                              <1> .dispatch:
  1440 00004758 [6C47]              <1> 	dw	int_14_fn00
  1441 0000475A [A524]              <1> 	dw	int_14_fn01
  1442 0000475C [C024]              <1> 	dw	int_14_fn02
  1443 0000475E [A147]              <1> 	dw	int_14_fn03
  1444 00004760 [AB47]              <1> 	dw	int_14_fn04
  1445 00004762 [0548]              <1> 	dw	int_14_fn05
  1446                              <1> .max	equ	$-.dispatch
  1447                              <1> 
  1448                              <1> int_14_error:
  1449 00004764 31C0                <1> 	xor	ax,ax
  1450                              <1> 
  1451                              <1> int_14_exit:
  1452 00004766 5B                  <1> 	pop	bx
  1453 00004767 1F                  <1> 	pop	ds
  1454 00004768 5E                  <1> 	pop	si
  1455 00004769 5A                  <1> 	pop	dx
  1456 0000476A 59                  <1> 	pop	cx
  1457 0000476B CF                  <1> 	iret
  1458                              <1> 
  1459                              <1> ;=========================================================================
  1460                              <1> ; int_14_fn00 - Initialize serial port
  1461                              <1> ; Input:
  1462                              <1> ;	AH = 0 - function 00h - initialize serial port
  1463                              <1> ;	AL - initialization parameters
  1464                              <1> ;		bit 1,0	= 10	- 7 data bits
  1465                              <1> ;			= 11	- 8 data bits
  1466                              <1> ;		bit 2	= 0	- 1 stop bit
  1467                              <1> ;			= 1	- 2 stop bits
  1468                              <1> ;		bit 3	= 0	- parity disable
  1469                              <1> ;			= 1	- parity enable
  1470                              <1> ;		bit 4	= 0	- odd parity (if parity enabled)
  1471                              <1> ;			= 1	- even parity (if parity enabled)
  1472                              <1> ;		bit 7-5 = 000	- 110 bps
  1473                              <1> ;			= 001	- 150 bps
  1474                              <1> ;			= 010	- 300 bps
  1475                              <1> ;			= 011	- 600 bps
  1476                              <1> ;			= 100	- 1200 bps
  1477                              <1> ;			= 101	- 2400 bps
  1478                              <1> ;			= 110	- 4800 bps
  1479                              <1> ;			= 111	- 9600 bps
  1480                              <1> ;	DX = serial port number (0-3)
  1481                              <1> ; Output:
  1482                              <1> ;	AL = modem status
  1483                              <1> ;		bit 0	= 1	- delta clear to send
  1484                              <1> ;		bit 1	= 1	- delta data set ready
  1485                              <1> ;		bit 2	= 1	- trailing edge ring indicator
  1486                              <1> ;		bit 3	= 1	- delta data carrier detect
  1487                              <1> ;		bit 4	= 1	- clear to send
  1488                              <1> ;		bit 5	= 1	- data set ready
  1489                              <1> ;		bit 6	= 1	- ring indicator
  1490                              <1> ;		bit 7	= 1	- data carrier detect
  1491                              <1> ;	AH = line status
  1492                              <1> ;		bit 0	= 1	- data ready
  1493                              <1> ;		bit 1	= 1	- overrun error
  1494                              <1> ;		bit 2	= 1	- parity error
  1495                              <1> ;		bit 3	= 1	- framing error
  1496                              <1> ;		bit 4	= 1	- break interrupt
  1497                              <1> ;		bit 5	= 1	- transmitter holding register
  1498                              <1> ;		bit 6	= 1	- transmitter empty
  1499                              <1> ;		bit 7	= 1	- error in RCVR FIFO
  1500                              <1> ;-------------------------------------------------------------------------
  1501                              <1> int_14_fn00:
  1502 0000476C 88C4                <1> 	mov	ah,al			; save AL to AH
  1503 0000476E 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  1504 00004771 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  1505 00004773 EE                  <1> 	out	dx,al
  1506 00004774 31DB                <1> 	xor	bx,bx
  1507 00004776 88E3                <1> 	mov	bl,ah
  1508 00004778 80E3E0              <1> 	and	bl,0E0h			; get divisor bits from init params
  1509 0000477B D0EB                <1> 	shr	bl,1
  1510 0000477D D0EB                <1> 	shr	bl,1
  1511 0000477F D0EB                <1> 	shr	bl,1
  1512 00004781 D0EB                <1> 	shr	bl,1
  1513 00004783 2E8B9F[8E25]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  1514 00004788 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1515 0000478B 88D8                <1> 	mov	al,bl
  1516 0000478D EE                  <1> 	out	dx,al			; output divisor - low byte
  1517 0000478E 42                  <1> 	inc	dx			; DX = UART base address + 1
  1518 0000478F 88F8                <1> 	mov	al,bh
  1519 00004791 EE                  <1> 	out	dx,al			; output divisor - high byte
  1520 00004792 42                  <1> 	inc	dx
  1521 00004793 42                  <1> 	inc	dx			; DX = UART LCR address
  1522 00004794 88E0                <1> 	mov	al,ah			; AL = initialization parameters
  1523 00004796 241F                <1> 	and	al,(uart_lcr_wlen | uart_lcr_stop | uart_lcr_pen | uart_lcr_peven)
  1524                              <1> 					; get control bits
  1525 00004798 EE                  <1> 	out	dx,al			; set LCR
  1526 00004799 4A                  <1> 	dec	dx
  1527 0000479A 4A                  <1> 	dec	dx			; DX = UART IER address
  1528                              <1> 					; OPTIMIZATION:
  1529                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  1530 0000479B B000                <1> 	mov	al,0
  1531 0000479D EE                  <1> 	out	dx,al			; disable interrupts
  1532 0000479E 4A                  <1> 	dec	dx			; DX = UART base address
  1533                              <1> 					; OPTIMIZATION:
  1534                              <1> 					; uart_base = uart_ier_reg - 1
  1535 0000479F EB00                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1536                              <1> 
  1537                              <1> ;=========================================================================
  1538                              <1> ; int_14_fn03 - Return serial port status
  1539                              <1> ; Input:
  1540                              <1> ;	AH = 03h - function 03h - return serial port status
  1541                              <1> ;	DX = serial port number (0-3)
  1542                              <1> ; Output:
  1543                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  1544                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  1545                              <1> ;-------------------------------------------------------------------------
  1546                              <1> int_14_fn03:
  1547 000047A1 83C205              <1> 	add	dx,uart_lsr_reg		; DX = UART LSR address
  1548 000047A4 EC                  <1> 	in	al,dx
  1549 000047A5 88C4                <1> 	mov	ah,al
  1550 000047A7 42                  <1> 	inc	dx			; DX = UART MSR address
  1551 000047A8 EC                  <1> 	in	al,dx
  1552 000047A9 EBBB                <1> 	jmp	int_14_exit
  1553                              <1> 
  1554                              <1> ;=========================================================================
  1555                              <1> ; int_14_fn04 - Extended initialize serial port
  1556                              <1> ; Input:
  1557                              <1> ;	AH = 04h - function 04h - extended initialize serial port
  1558                              <1> ;	AL - break status:
  1559                              <1> ;		00h = no break
  1560                              <1> ;		01h = break
  1561                              <1> ;	BH - parity:
  1562                              <1> ;		00h = no parity
  1563                              <1> ;		01h = odd parity
  1564                              <1> ;		02h = even parity
  1565                              <1> ;		03h = stick parity odd
  1566                              <1> ;		04h = stick parity even
  1567                              <1> ;	BL - stop bits:
  1568                              <1> ;		00h = 1 stop bit
  1569                              <1> ;		01h = 2 stop bits (or 1.5 stop bits for 5 bit word length)
  1570                              <1> ;	CH - word length:
  1571                              <1> ;		00h = 5 bits
  1572                              <1> ;		01h = 6 bits
  1573                              <1> ;		02h = 7 bits
  1574                              <1> ;		03h = 8 bits
  1575                              <1> ;	CL - bps rate:
  1576                              <1> ;		00h = 110 bps
  1577                              <1> ;		01h = 150 bps
  1578                              <1> ;		02h = 300 bps
  1579                              <1> ;		03h = 600 bps
  1580                              <1> ;		04h = 1200 bps
  1581                              <1> ;		05h = 2400 bps
  1582                              <1> ;		06h = 6000 bps
  1583                              <1> ;		07h = 9600 bps
  1584                              <1> ;		08h = 19200 bps
  1585                              <1> ;		09h = 38400 bps
  1586                              <1> ;		0Ah = 57600 bps
  1587                              <1> ;		0Bh = 115200 bps
  1588                              <1> ;	DX = serial port number (0-3)
  1589                              <1> ; Output:
  1590                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  1591                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  1592                              <1> ;-------------------------------------------------------------------------
  1593                              <1> int_14_fn04:
  1594 000047AB 88C4                <1> 	mov	ah,al			; save AL to AH
  1595 000047AD 80F90C              <1> 	cmp	cl,num_divisors
  1596 000047B0 73EF                <1> 	jae	int_14_fn03		; invalid divisor value
  1597                              <1> 					; exit returning modem and line status
  1598 000047B2 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  1599 000047B5 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  1600 000047B7 EE                  <1> 	out	dx,al
  1601 000047B8 31DB                <1> 	xor	bx,bx
  1602 000047BA 88CB                <1> 	mov	bl,cl			; get divisor number from parameters
  1603 000047BC D0E3                <1> 	shl	bl,1			; index to the word table
  1604 000047BE 2E8B9F[8E25]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  1605 000047C3 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1606 000047C6 88D8                <1> 	mov	al,bl
  1607 000047C8 EE                  <1> 	out	dx,al			; output divisor - low byte
  1608 000047C9 42                  <1> 	inc	dx			; DX = UART base address + 1
  1609 000047CA 88F8                <1> 	mov	al,bh
  1610 000047CC EE                  <1> 	out	dx,al			; output divisor - high byte
  1611 000047CD 42                  <1> 	inc	dx
  1612 000047CE 42                  <1> 	inc	dx			; DX = UART LCR address
  1613                              <1> 
  1614 000047CF 80E401              <1> 	and	ah,01h			; break setting (mask defined bits)
  1615 000047D2 88E0                <1> 	mov	al,ah			; add it to AL (LCR setting)
  1616                              <1> 
  1617 000047D4 D0E0                <1> 	shl	al,1
  1618 000047D6 D0E0                <1> 	shl	al,1
  1619 000047D8 D0E0                <1> 	shl	al,1			; make place for parity settings
  1620                              <1> 	
  1621 000047DA 5B                  <1> 	pop	bx			; get original BX value from the stack
  1622 000047DB 53                  <1> 	push	bx			; push it back to the stack
  1623                              <1> 
  1624 000047DC 80FF01              <1> 	cmp	bh,1			; parity setting
  1625 000047DF 7609                <1> 	jbe	.set_parity		; no parity or odd parity
  1626 000047E1 FECF                <1> 	dec	bh
  1627 000047E3 80E703              <1> 	and	bh,03h			; get the valid bits only
  1628 000047E6 D0E7                <1> 	shl	bh,1
  1629 000047E8 FEC7                <1> 	inc	bh			; 010 -> 011, 011 -> 101, 100 -> 111
  1630                              <1> 
  1631                              <1> .set_parity:
  1632 000047EA 08F8                <1> 	or	al,bh			; add it to AL (LCR setting)
  1633                              <1> 
  1634 000047EC D0E0                <1> 	shl	al,1			; make place for stop bit setting
  1635                              <1> 	
  1636 000047EE 80E301              <1> 	and	bl,01h			; get stop bits (defined bit only)
  1637 000047F1 08D8                <1> 	or	al,bl			; add it to AL (LCR setting)
  1638                              <1> 
  1639 000047F3 D0E0                <1> 	shl	al,1
  1640 000047F5 D0E0                <1> 	shl	al,1			; make place for word length setting
  1641                              <1> 
  1642 000047F7 80E503              <1> 	and	ch,03h			; get word length (mask defined bits)
  1643 000047FA 08E8                <1> 	or	al,ch			; add it to AL (LCR setting)
  1644                              <1> 
  1645 000047FC EE                  <1> 	out	dx,al			; set LCR
  1646 000047FD 4A                  <1> 	dec	dx
  1647 000047FE 4A                  <1> 	dec	dx			; DX = UART IER address
  1648                              <1> 					; OPTIMIZATION:
  1649                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  1650 000047FF B000                <1> 	mov	al,0
  1651 00004801 EE                  <1> 	out	dx,al			; disable interrupts
  1652 00004802 4A                  <1> 	dec	dx			; DX = UART base address
  1653                              <1> 					; OPTIMIZATION:
  1654                              <1> 					; uart_base = uart_ier_reg - 1
  1655 00004803 EB9C                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1656                              <1> 
  1657                              <1> ;=========================================================================
  1658                              <1> ; int_14_fn05 - Extended serial port control
  1659                              <1> ; Input:
  1660                              <1> ;	AH = 05h - function 05h - extended serial port control
  1661                              <1> ;	AL - sub-function:
  1662                              <1> ;		00h = read modem control register
  1663                              <1> ;		01h = write modem control register
  1664                              <1> ;			BL = modem control register
  1665                              <1> ;	DX = serial port number (0-3)
  1666                              <1> ; Output:
  1667                              <1> ;	AX = status	
  1668                              <1> ;	sub-function AL = 00h:
  1669                              <1> ;		BL = modem control register
  1670                              <1> ;-------------------------------------------------------------------------
  1671                              <1> int_14_fn05:
  1672 00004805 2401                <1> 	and	al,01h			; sub-function (get the valid bit)
  1673 00004807 750D                <1> 	jnz	int_14_fn05_01
  1674                              <1> 
  1675                              <1> ;-------------------------------------------------------------------------
  1676                              <1> ; sub-function 00h - read modem control register
  1677                              <1> ; int_14_fn05_00:
  1678 00004809 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  1679 0000480C EC                  <1> 	in	al,dx
  1680 0000480D 5B                  <1> 	pop	bx			; get BX from the stack
  1681 0000480E 88C3                <1> 	mov	bl,al			; BL = MCR content
  1682 00004810 53                  <1> 	push	bx			; put BX back to the stack
  1683 00004811 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1684 00004814 EB8B                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1685                              <1> 
  1686                              <1> ;-------------------------------------------------------------------------
  1687                              <1> ; sub-function 01h - write modem control register
  1688                              <1> int_14_fn05_01:
  1689 00004816 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  1690 00004819 5B                  <1> 	pop	bx			; get BX from the stack
  1691 0000481A 53                  <1> 	push	bx			; put BX back to the stack
  1692 0000481B 88D8                <1> 	mov	al,bl			; BL = new MCR content
  1693 0000481D EE                  <1> 	out	dx,al
  1694 0000481E 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1695 00004821 E97DFF              <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1382                                  %include	"keyboard.inc"		; INT 16, INT 09
  1383                              <1> ;=========================================================================
  1384                              <1> ; keyboard.inc - Keyboard support
  1385                              <1> ;       INT 16h - BIOS Keyboard Services
  1386                              <1> ;		- function AH=02h
  1387                              <1> ;		- function AH=03h
  1388                              <1> ;		- function AH=05h
  1389                              <1> ;		- function AH=12h
  1390                              <1> ;		- see scancode.inc for other (scancode related)
  1391                              <1> ;                 INT 16h functions
  1392                              <1> ;       INT 09h - IRQ1 interrupt handler
  1393                              <1> ;-------------------------------------------------------------------------
  1394                              <1> ;
  1395                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1396                              <1> ;
  1397                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
  1398                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1399                              <1> ;
  1400                              <1> ; This program is free software: you can redistribute it and/or modify
  1401                              <1> ; it under the terms of the GNU General Public License as published by
  1402                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1403                              <1> ; (at your option) any later version.
  1404                              <1> ;
  1405                              <1> ; This program is distributed in the hope that it will be useful,
  1406                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1407                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1408                              <1> ; GNU General Public License for more details.
  1409                              <1> ;
  1410                              <1> ; You should have received a copy of the GNU General Public License
  1411                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1412                              <1> ;
  1413                              <1> ;=========================================================================
  1414                              <1> 
  1415                              <1> ;=========================================================================
  1416                              <1> ; Scan codes and keyboard flags
  1417                              <1> ;-------------------------------------------------------------------------
  1418                              <1> 
  1419                              <1> ; scancodes for special keys
  1420                              <1> 
  1421                              <1> kbd_num_code	equ	45h
  1422                              <1> kbd_scroll_code	equ	46h
  1423                              <1> kbd_caps_code	equ	3ah
  1424                              <1> kbd_ctrl_code	equ	1dh
  1425                              <1> kbd_alt_code	equ	38h
  1426                              <1> kbd_rshift_code	equ	36h
  1427                              <1> kbd_prtsc_code	equ	37h
  1428                              <1> kbd_lshift_code	equ	2ah
  1429                              <1> kbd_ins_code	equ	52h
  1430                              <1> kbd_del_code	equ	53h
  1431                              <1> 
  1432                              <1> ; Bits for the various modifier keys
  1433                              <1> 
  1434                              <1> kbd_rshft_bit	equ	1
  1435                              <1> kbd_lshft_bit	equ	2
  1436                              <1> kbd_ctrl_bit	equ	4
  1437                              <1> kbd_alt_bit	equ	8
  1438                              <1> kbd_scroll_bit	equ	10h
  1439                              <1> kbd_num_bit	equ	20h
  1440                              <1> kbd_caps_bit	equ	40h
  1441                              <1> kbd_ins_bit	equ	80h
  1442                              <1> 
  1443                              <1> ;=========================================================================
  1444                              <1> ; int_16 - BIOS keyboard functions
  1445                              <1> ;-------------------------------------------------------------------------
  1446 00004824 FF<rep Ah>          <1> 	setloc	0E82Eh
  1446          ******************  <1>  warning: Inserting 10 bytes [-w+user]
  1447                              <1> int_16:
  1448                              <1> ;	call	int_trace		; DEBUG
  1449 0000482E 53                  <1> 	push	bx
  1450 0000482F 1E                  <1> 	push	ds
  1451 00004830 BB4000              <1> 	mov	bx,biosdseg
  1452 00004833 8EDB                <1> 	mov	ds,bx
  1453 00004835 80FC13              <1> 	cmp	ah,.num_func
  1454 00004838 7331                <1> 	jae	int_16_exit
  1455 0000483A B700                <1> 	mov	bh,0
  1456 0000483C 88E3                <1> 	mov	bl,ah
  1457 0000483E D1E3                <1> 	shl	bx,1
  1458 00004840 2EFFA7[4548]        <1>     cs	jmp	near [.dispatch+bx]
  1459                              <1> 
  1460                              <1> .dispatch:
  1461 00004845 [B523]              <1> 	dw	int_16_fn00		; read char from buffer, wait if empty
  1462 00004847 [0A24]              <1> 	dw	int_16_fn01		; check buffer, do not clear
  1463 00004849 [7448]              <1> 	dw	int_16_fn02		; get shift status
  1464                              <1> %ifdef AT_KEYBOARD
  1465                              <1> 	dw	int_16_fn03		; set delays
  1466                              <1> %else ; AT_KEYBOARD
  1467 0000484B [6B48]              <1> 	dw	int_16_exit		; not implemented on XT
  1468                              <1> %endif ; AT_KEYBOARD
  1469 0000484D [6B48]              <1> 	dw	int_16_exit		; keyclick
  1470 0000484F [7948]              <1> 	dw	int_16_fn05		; write to keyboard buffer
  1471 00004851 [6B48]              <1> 	dw	int_16_exit		; 06
  1472 00004853 [6B48]              <1> 	dw	int_16_exit		; 07
  1473 00004855 [6B48]              <1> 	dw	int_16_exit		; 08
  1474 00004857 [6B48]              <1> 	dw	int_16_exit		; 09
  1475 00004859 [6B48]              <1> 	dw	int_16_exit		; 0A
  1476 0000485B [6B48]              <1> 	dw	int_16_exit		; 0B
  1477 0000485D [6B48]              <1> 	dw	int_16_exit		; 0C
  1478 0000485F [6B48]              <1> 	dw	int_16_exit		; 0D
  1479 00004861 [6B48]              <1> 	dw	int_16_exit		; 0E
  1480 00004863 [6B48]              <1> 	dw	int_16_exit		; 0F
  1481 00004865 [6224]              <1> 	dw	int_16_fn10		; get enhanced keystroke
  1482 00004867 [8E24]              <1> 	dw	int_16_fn11		; check enhanced keystroke
  1483 00004869 [A248]              <1> 	dw	int_16_fn12		; get enhanced shift flags
  1484                              <1> .num_func	equ	($-.dispatch)/2
  1485                              <1> 
  1486                              <1> int_16_exit:
  1487 0000486B 1F                  <1> 	pop	ds
  1488 0000486C 5B                  <1> 	pop	bx
  1489 0000486D CF                  <1> 	iret
  1490                              <1> 
  1491                              <1> int_16_exitf:
  1492 0000486E 1F                  <1> 	pop	ds
  1493 0000486F 5B                  <1> 	pop	bx
  1494 00004870 FB                  <1> 	sti
  1495 00004871 CA0200              <1> 	retf	2
  1496                              <1> 
  1497                              <1> ;=========================================================================
  1498                              <1> ; int_16_fn02 - get shift flags
  1499                              <1> ; Input:
  1500                              <1> ;	AH = 02h
  1501                              <1> ; Output:
  1502                              <1> ;	AL - shift flags
  1503                              <1> ;            AL bits:
  1504                              <1> ;		7 - Insert active
  1505                              <1> ;		6 - Caps Lock active
  1506                              <1> ;		5 - Num Lock active
  1507                              <1> ;		4 - Scroll Lock active
  1508                              <1> ;		3 - Alt key pressed (either Alt on 101/102-key keyboards)
  1509                              <1> ;		2 - Ctrl key pressed (either Ctrl on 101/102-key keyboards)
  1510                              <1> ;		1 - left shift key pressed
  1511                              <1> ;		0 - right shift key pressed
  1512                              <1> ;-------------------------------------------------------------------------
  1513                              <1> int_16_fn02:
  1514 00004874 A01700              <1> 	mov	al,byte [kbd_flags_1]
  1515 00004877 EBF2                <1> 	jmp	int_16_exit
  1516                              <1> 
  1517                              <1> %ifdef AT_KEYBOARD
  1518                              <1> 
  1519                              <1> ;=========================================================================
  1520                              <1> ; int_16_fn03 - set keyboard typematic rate
  1521                              <1> ; Input:
  1522                              <1> ;	AH = 03
  1523                              <1> ;	AL - subfunction
  1524                              <1> ;	     00 - set typematic rate to default
  1525                              <1> ;	     01 - increase initial delay
  1526                              <1> ;	     02 - slow typematic rate by 1/2
  1527                              <1> ;	     04 - turn off typematic chars
  1528                              <1> ;	     05 - set typematic rate/delay
  1529                              <1> ;	BH - repeat delay (AL=5)
  1530                              <1> ;		0 - 250ms	2 - 750ms
  1531                              <1> ;		1 - 500ms	3 - 1000ms
  1532                              <1> ;	BL - typematic rate, one of the following  (AL=5)
  1533                              <1> ;		00 - 30.0	01 - 26.7	02 - 24.0	03 - 21.8
  1534                              <1> ;		04 - 20.0	05 - 18.5	06 - 17.1	07 - 16.0
  1535                              <1> ;		08 - 15.0	09 - 13.3	0A - 12.0	0B - 10.9
  1536                              <1> ;		0C - 10.0	0D - 9.2	0E - 8.6	0F - 8.0
  1537                              <1> ;		10 - 7.5	11 - 6.7	12 - 6.0	13 - 5.5
  1538                              <1> ;		14 - 5.0	15 - 4.6	16 - 4.3	17 - 4.0
  1539                              <1> ;		18 - 3.7	19 - 3.3	1A - 3.0	1B - 2.7
  1540                              <1> ;		1C - 2.5	1D - 2.3	1E - 2.1	1F - 2.0
  1541                              <1> ; Output:
  1542                              <1> ;	none
  1543                              <1> ;-------------------------------------------------------------------------
  1544                              <1> int_16_fn03:
  1545                              <1> 	cmp	al,05
  1546                              <1> 	jne	.exit			; only AL = 5 implemented
  1547                              <1> 	push	bx
  1548                              <1> 	push	cx
  1549                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  1550                              <1> 	call	kbc_write_command
  1551                              <1> 	and	bh,3			; legal BH values from 0 to 3
  1552                              <1> 	mov	cl,5
  1553                              <1> 	shl	bh,cl
  1554                              <1> 	and	bl,1Fh			; legal BL values from 0 to 1F
  1555                              <1> 	mov	al,dev_cmd_rate
  1556                              <1> 	call	kbc_kb_send
  1557                              <1> 	mov	al,bh
  1558                              <1> 	call	kbc_kb_send
  1559                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  1560                              <1> 	call	kbc_write_command
  1561                              <1> 	mov	al,04h			; FIXME: Use dev_cmd_enable instead?
  1562                              <1> 	call	kbc_kb_send
  1563                              <1> 	pop	cx
  1564                              <1> 	pop	bx
  1565                              <1> .exit:
  1566                              <1> 	jmp	int_16_exit
  1567                              <1> 
  1568                              <1> %endif ; AT_KEYBOARD
  1569                              <1> 
  1570                              <1> ;=========================================================================
  1571                              <1> ; int_16_fn05 - store keystroke in keyboard buffer
  1572                              <1> ; Input:
  1573                              <1> ;	AH = 05h
  1574                              <1> ;	CH = BIOS scan code
  1575                              <1> ;	CL = ACII character
  1576                              <1> ; Output:
  1577                              <1> ;	AL - status
  1578                              <1> ;	     00h - success
  1579                              <1> ;	     01h - keyboard buffer full
  1580                              <1> ;-------------------------------------------------------------------------
  1581                              <1> int_16_fn05:
  1582 00004879 56                  <1> 	push	si
  1583 0000487A B001                <1> 	mov	al,1			; assume no space
  1584 0000487C FA                  <1> 	cli				; critical section
  1585 0000487D 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  1586 00004881 89DE                <1> 	mov	si,bx
  1587 00004883 83C302              <1> 	add	bx,2
  1588 00004886 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  1589 0000488A 7504                <1> 	jne	.1
  1590 0000488C 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  1591                              <1> .1:
  1592 00004890 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  1593 00004894 7408                <1> 	je	.no_space		; no space in buffer
  1594 00004896 890C                <1> 	mov	word [si],cx
  1595 00004898 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  1596 0000489C B000                <1> 	mov	al,0			; stored successfully
  1597                              <1> .no_space:
  1598 0000489E FB                  <1> 	sti
  1599 0000489F 5E                  <1> 	pop	si
  1600 000048A0 EBC9                <1> 	jmp	int_16_exit
  1601                              <1> 
  1602                              <1> ;=========================================================================
  1603                              <1> ; int_16_fn12 - get extended shift flags
  1604                              <1> ; Input:
  1605                              <1> ;	AH = 12h
  1606                              <1> ; Output:
  1607                              <1> ;	AL - shift flags 1 (same as returned by function AH=02)
  1608                              <1> ;	AH - shift flags 2
  1609                              <1> ;            AH bits:
  1610                              <1> ;		7 - SysRq key pressed
  1611                              <1> ;		6 - Caps Lock pressed
  1612                              <1> ;		5 - Num Lock pressed
  1613                              <1> ;		4 - Scroll Lock pressed
  1614                              <1> ;		3 - right Alt key pressed
  1615                              <1> ;		2 - right Ctrl key pressed
  1616                              <1> ;		1 - left Alt key pressed
  1617                              <1> ;		0 - left Ctrl key pressed
  1618                              <1> ;-------------------------------------------------------------------------
  1619                              <1> int_16_fn12:
  1620 000048A2 8A261800            <1> 	mov	ah,byte [kbd_flags_2]
  1621 000048A6 80E47F              <1> 	and	ah,7Fh			; clear final SysRq bit
  1622 000048A9 F6C404              <1> 	test	ah,00000100b		; test current SysRq bit
  1623 000048AC 7403                <1> 	je	.1
  1624 000048AE 80CC80              <1> 	or	ah,80h			; set final SysRq bit
  1625                              <1> .1:
  1626 000048B1 80E4F3              <1> 	and	ah,11110011b		; clear right Alt/Ctrl bits
  1627 000048B4 A09600              <1> 	mov	al,byte [kbd_flags_3]
  1628 000048B7 240C                <1> 	and	al,00001100b		; get right Alt/Ctrl bits
  1629 000048B9 08C4                <1> 	or	ah,al			; copy to AH
  1630 000048BB A01700              <1> 	mov	al,byte [kbd_flags_1]
  1631 000048BE EBAB                <1> 	jmp	int_16_exit
  1632                              <1> 
  1633                              <1> ;=========================================================================
  1634                              <1> ; int_09 - Keyboard hardware interrupt (IRQ1) handler
  1635                              <1> ;-------------------------------------------------------------------------
  1636 000048C0 FF<rep C7h>         <1> 	setloc	0E987h			; INT 09 Entry Point
  1636          ******************  <1>  warning: Inserting 199 bytes [-w+user]
  1637                              <1> int_09:
  1638 00004987 50                  <1> 	push	ax
  1639 00004988 53                  <1> 	push	bx
  1640 00004989 1E                  <1> 	push	ds
  1641                              <1> 
  1642 0000498A B84000              <1> 	mov	ax,biosdseg
  1643 0000498D 8ED8                <1> 	mov	ds,ax
  1644                              <1> 
  1645                              <1> %ifdef AT_KEYBOARD
  1646                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  1647                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  1648                              <1> 	call    kbc_write_command
  1649                              <1> %endif
  1650                              <1> %endif ; AT_KEYBOARD
  1651 0000498F E460                <1> 	in	al,ppi_pa_reg		; get keyboard data / scancode
  1652                              <1> %ifndef MACHINE_BOOK8088
  1653 00004991 88C4                <1> 	mov	ah,al			; save it in AH
  1654 00004993 E461                <1> 	in	al,ppi_pb_reg		; read PPI port B, control
  1655 00004995 0C80                <1> 	or	al,10000000b		; set keyboard clear bit
  1656 00004997 E661                <1> 	out	ppi_pb_reg,al		; write it back to PPI port B
  1657 00004999 247F                <1> 	and	al,01111111b		; unset keyboard clear bit
  1658 0000499B E661                <1> 	out	ppi_pb_reg,al		; write it back to PPI port B
  1659 0000499D 88E0                <1> 	mov	al,ah			; restore AL / scancode
  1660                              <1> %endif ; MACHINE_BOOK8088
  1661 0000499F FB                  <1> 	sti
  1662                              <1> %ifdef AT_KEYBOARD
  1663                              <1> 	mov	ah,4Fh
  1664                              <1> 	stc
  1665                              <1> 	int	15h			; keyboard intercept
  1666                              <1> 	jnc	keyboard_int_exit	; CF = 0, ignore scan code
  1667                              <1> %else ; AT_KEYBOARD
  1668 000049A0 3CFF                <1> 	cmp	al,0FFh			; check for overrun
  1669 000049A2 7503E9CF01          <1> 	jz	keyboard_int_exit
  1670                              <1> %endif ; AT_KEYBOARD
  1671                              <1> ; check for KBC response codes
  1672                              <1> 
  1673 000049A7 3CEE                <1> 	cmp	al,0EEh			; echo response?
  1674 000049A9 7503E9C801          <1> 	je      keyboard_int_exit
  1675 000049AE 3CFA                <1> 	cmp	al,0FAh			; acknowledge?
  1676 000049B0 7508                <1> 	jne     .2
  1677 000049B2 800E970010          <1> 	or	byte [kbd_flags_4],10h	; set ack bit
  1678 000049B7 E9BC01              <1> 	jmp	keyboard_int_exit
  1679                              <1> .2:
  1680 000049BA 3CFE                <1> 	cmp	al,0FEh			; resend command?
  1681 000049BC 7508                <1> 	jne	.3
  1682 000049BE 800E970020          <1> 	or	byte [kbd_flags_4],20h	; set resend bit
  1683 000049C3 E9B001              <1> 	jmp	keyboard_int_exit
  1684                              <1> 
  1685                              <1> ; Note: other KBC response codes have their MSB bit set and will be ignored
  1686                              <1> 
  1687                              <1> .3:
  1688                              <1> 
  1689                              <1> ; check for 0E0h and 0E1h scancodes, set flags in kbd_flags_3
  1690                              <1> 
  1691 000049C6 3CE0                <1> 	cmp	al,0E0h
  1692 000049C8 750D                <1> 	jne	.4
  1693 000049CA 800E960002          <1> 	or	byte [kbd_flags_3],10b	; set E0 flag
  1694 000049CF 80269600FE          <1> 	and	byte [kbd_flags_3],0FEh	; clear E1 flag
  1695 000049D4 E99F01              <1> 	jmp	keyboard_int_exit
  1696                              <1> .4:
  1697 000049D7 3CE1                <1> 	cmp	al,0E1h
  1698 000049D9 750D                <1> 	jne	.5
  1699 000049DB 800E960001          <1> 	or	byte [kbd_flags_3],1	; set E1 flag
  1700 000049E0 80269600FD          <1> 	and	byte [kbd_flags_3],0FDh	; clear E0 Flag
  1701 000049E5 E98E01              <1> 	jmp	keyboard_int_exit
  1702                              <1> 
  1703                              <1> ; check for various <Ctrl>+<Alt>+<Key> combinations:
  1704                              <1> 
  1705                              <1> .5:
  1706 000049E8 8A1E1700            <1> 	mov	bl,byte [kbd_flags_1]
  1707 000049EC 80E30C              <1> 	and	bl,kbd_alt_bit|kbd_ctrl_bit
  1708 000049EF 80FB0C              <1> 	cmp	bl,kbd_alt_bit|kbd_ctrl_bit
  1709 000049F2 752D                <1> 	jne	.6
  1710 000049F4 3C53                <1> 	cmp	al,kbd_del_code		; <Ctrl>+<Alt>+<Del>?
  1711 000049F6 750B                <1> 	jne	.check_turbo_off
  1712 000049F8 C70672003412        <1> 	mov	word [warm_boot],1234h ; warm boot flag
  1713 000049FE EA[6640]00F0        <1> 	jmp	0F000h:warm_start	; reboot
  1714                              <1> 
  1715                              <1> ; handle turbo mode switch combinations
  1716                              <1> .check_turbo_off:
  1717                              <1> 
  1718                              <1> %ifdef TURBO_MODE
  1719 00004A03 3C4A                <1> 	cmp	al,4Ah			; gray - scancode
  1720 00004A05 7506                <1> 	jne	.check_turbo_mid
  1721                              <1> 
  1722 00004A07 E8F4DD              <1> 	call	set_cpu_clk_4_77mhz
  1723 00004A0A E96901              <1> 	jmp	keyboard_int_exit
  1724                              <1> 
  1725                              <1> .check_turbo_mid:
  1726                              <1> %ifdef MACHINE_FE2010A
  1727 00004A0D 3C37                <1> 	cmp	al,37h			; * scancode
  1728 00004A0F 7506                <1> 	jne	.check_turbo_hi
  1729                              <1> 
  1730 00004A11 E8F6DD              <1> 	call	set_cpu_clk_7_16mhz
  1731 00004A14 E95F01              <1> 	jmp	keyboard_int_exit
  1732                              <1> %endif ; MACHINE_FE2010A
  1733                              <1> 
  1734                              <1> .check_turbo_hi:
  1735 00004A17 3C4E                <1> 	cmp	al,4Eh			; gray + scancode
  1736 00004A19 7506                <1> 	jne	.6
  1737                              <1> 
  1738                              <1> %ifdef MACHINE_FE2010A
  1739 00004A1B E806DE              <1> 	call	set_cpu_clk_9_55mhz
  1740                              <1> %else ; MACHINE_FE2010A
  1741                              <1> 	call	set_cpu_clk_turbo
  1742                              <1> %endif ; MACHINE_FE2010A
  1743 00004A1E E95501              <1> 	jmp	keyboard_int_exit
  1744                              <1> 
  1745                              <1> %endif ; TURBO_MODE
  1746                              <1> 
  1747                              <1> ; Check for the INS key here. This one needs to toggle the ins bit
  1748                              <1> ; in the keyboard flags variables.
  1749                              <1> 
  1750                              <1> .6:
  1751 00004A21 3C52                <1> 	cmp	al,kbd_ins_code
  1752 00004A23 7508                <1> 	jne	.7
  1753 00004A25 800E180080          <1> 	or	byte [kbd_flags_2],kbd_ins_bit ; set INS bit
  1754 00004A2A E90A01              <1> 	jmp	.translate	   	; pass on INS key
  1755                              <1> 
  1756                              <1> .7:
  1757 00004A2D 3CD2                <1> 	cmp	al,kbd_ins_code+80h	; INS "break" scan code
  1758 00004A2F 750D                <1> 	jne     .8
  1759 00004A31 802618007F          <1> 	and	byte [kbd_flags_2],~kbd_ins_bit ; clear INS bit
  1760 00004A36 8036170080          <1> 	xor     byte [kbd_flags_1],kbd_ins_bit ; toggle INS bit
  1761 00004A3B E93301              <1> 	jmp     .no_buffer
  1762                              <1> 
  1763                              <1> ; handle the left and right Shift keys
  1764                              <1> 
  1765                              <1> .8:
  1766 00004A3E 3C2A                <1> 	cmp	al,kbd_lshift_code
  1767 00004A40 7508                <1> 	jne	.9
  1768 00004A42 800E170002          <1> 	or	byte [kbd_flags_1],kbd_lshft_bit ; set left Shift bit
  1769 00004A47 E92701              <1> 	jmp	.no_buffer
  1770                              <1> .9:
  1771 00004A4A 3CAA                <1> 	cmp	al,kbd_lshift_code+80h
  1772 00004A4C 7508                <1> 	jne     .10
  1773 00004A4E 80261700FD          <1> 	and     byte [kbd_flags_1],~kbd_lshft_bit ; clear left Shift bit
  1774 00004A53 E91B01              <1> 	jmp     .no_buffer
  1775                              <1> .10:
  1776 00004A56 3C36                <1> 	cmp	al,kbd_rshift_code
  1777 00004A58 7508                <1> 	jne	.11
  1778 00004A5A 800E170001          <1> 	or	byte [kbd_flags_1],kbd_rshft_bit ; set right Shift bit
  1779 00004A5F E90F01              <1> 	jmp	.no_buffer
  1780                              <1> .11:
  1781 00004A62 3CB6                <1> 	cmp	al,kbd_rshift_code+80h
  1782 00004A64 7508                <1> 	jne     .12
  1783 00004A66 80261700FE          <1> 	and	byte [kbd_flags_1],~kbd_rshft_bit ; clear right Shift bit
  1784 00004A6B E90301              <1> 	jmp	.no_buffer
  1785                              <1> 
  1786                              <1> ; handle the Alt key
  1787                              <1> 
  1788                              <1> .12:
  1789 00004A6E 3C38                <1> 	cmp	al,kbd_alt_code
  1790 00004A70 7508                <1> 	jne	.13
  1791 00004A72 800E170008          <1> 	or	byte [kbd_flags_1],kbd_alt_bit ; set Alt bit
  1792 00004A77 E9F700              <1> 	jmp	.no_buffer
  1793                              <1> .13:
  1794 00004A7A 3CB8                <1> 	cmp	al,kbd_alt_code+80h
  1795 00004A7C 751C                <1> 	jne	.14
  1796 00004A7E 80261700F7          <1> 	and	byte [kbd_flags_1],~kbd_alt_bit ; clear Alt bit
  1797 00004A83 803E190000          <1> 	cmp	byte [kbd_alt_keypad],0		; anything in Alt + Keypad area
  1798 00004A88 7503E9E400          <1> 	je	.no_buffer				; nothing there - exit
  1799 00004A8D A01900              <1> 	mov	al,byte [kbd_alt_keypad]	; put it in the buffer
  1800 00004A90 C606190000          <1> 	mov	byte [kbd_alt_keypad],0		; zero the buffer
  1801 00004A95 B400                <1> 	mov	ah,0
  1802 00004A97 E9B600              <1> 	jmp	.put_in_buffer
  1803                              <1> 
  1804                              <1> ; handle the Ctrl key
  1805                              <1> 
  1806                              <1> .14:
  1807 00004A9A 3C1D                <1> 	cmp	al,kbd_ctrl_code
  1808 00004A9C 7508                <1> 	jne	.15
  1809 00004A9E 800E170004          <1> 	or	byte [kbd_flags_1],kbd_ctrl_bit ; set Ctrl bit
  1810 00004AA3 E9CB00              <1> 	jmp	.no_buffer
  1811                              <1> .15:
  1812 00004AA6 3C9D                <1> 	cmp	al,kbd_ctrl_code+80h
  1813 00004AA8 7508                <1> 	jne	.16
  1814 00004AAA 80261700FB          <1> 	and	byte [kbd_flags_1],~kbd_ctrl_bit ; clear Ctrl bit
  1815 00004AAF E9BF00              <1> 	jmp	.no_buffer
  1816                              <1> 
  1817                              <1> ; handle the Caps Lock key
  1818                              <1> 
  1819                              <1> .16:
  1820 00004AB2 3C3A                <1> 	cmp	al,kbd_caps_code
  1821 00004AB4 750D                <1> 	jne	.17
  1822 00004AB6 800E180040          <1> 	or	byte [kbd_flags_2],kbd_caps_bit ; set Caps Lock bit
  1823 00004ABB 8036170040          <1> 	xor	byte [kbd_flags_1],kbd_caps_bit ; toggle Caps Lock bit
  1824 00004AC0 E9AE00              <1> 	jmp	.no_buffer
  1825                              <1> .17:
  1826 00004AC3 3CBA                <1> 	cmp	al,kbd_caps_code+80h
  1827 00004AC5 7508                <1> 	jne	.18
  1828 00004AC7 80261800BF          <1> 	and	byte [kbd_flags_2],~kbd_caps_bit ; clear Caps Lock bit
  1829 00004ACC E9D000              <1> 	jmp	set_LEDs
  1830                              <1> 
  1831                              <1> ; check if print screen key was pressed
  1832                              <1> 
  1833                              <1> .18:
  1834 00004ACF 3C37                <1> 	cmp	al,kbd_prtsc_code
  1835 00004AD1 750A                <1> 	jne	.test_scroll_loc
  1836 00004AD3 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  1837 00004AD8 7403                <1> 	jz	.test_scroll_loc	; jump if no 0E0h flag (Keypad *)
  1838 00004ADA E9B500              <1> 	jmp	print_screen
  1839                              <1> 
  1840                              <1> ; handle the Scroll Lock (046h) key and Ctrl-Break combination (0E0h, 046h)
  1841                              <1> 
  1842                              <1> .test_scroll_loc:
  1843 00004ADD 3C46                <1> 	cmp	al,kbd_scroll_code
  1844 00004ADF 7528                <1> 	jne	.19
  1845 00004AE1 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  1846 00004AE6 7415                <1> 	jz	.scroll_lock		; jump if no 0E0h flag (Scroll Lock)
  1847                              <1> 
  1848                              <1> ; handle Ctrl-Break
  1849                              <1> 
  1850 00004AE8 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start] ; empty keyboard buffer
  1851 00004AEC 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  1852 00004AF0 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  1853 00004AF4 800E710080          <1> 	or	byte [break_flag],80h	; set Ctrl-Break flag
  1854 00004AF9 CD1B                <1> 	int	1Bh			; call INT 1Bh - Ctrl-Break handler
  1855 00004AFB EB74                <1> 	jmp	.no_buffer
  1856                              <1> 
  1857                              <1> ; handle Scroll Lock
  1858                              <1> 
  1859                              <1> .scroll_lock:
  1860 00004AFD 800E180010          <1> 	or	byte [kbd_flags_2],kbd_scroll_bit ; set Scroll Lock bit
  1861 00004B02 8036170010          <1> 	xor	byte [kbd_flags_1],kbd_scroll_bit ; toggle Scroll Lock bit
  1862 00004B07 EB68                <1> 	jmp	.no_buffer
  1863                              <1> .19:
  1864 00004B09 3CC6                <1> 	cmp	al,kbd_scroll_code+80h
  1865 00004B0B 7508                <1> 	jne	.20
  1866 00004B0D 80261800EF          <1> 	and	byte [kbd_flags_2],~kbd_scroll_bit ; clear Scroll Lock bit
  1867 00004B12 E98A00              <1> 	jmp	set_LEDs
  1868                              <1> 
  1869                              <1> ; handle the Num Lock
  1870                              <1> 
  1871                              <1> .20:
  1872 00004B15 3C45                <1> 	cmp	al,kbd_num_code
  1873 00004B17 7513                <1> 	jne	.21
  1874 00004B19 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; Ctrl+Num Lock (Pause)?
  1875 00004B1E 755E                <1> 	jnz	pause			; jump if pause
  1876 00004B20 800E180020          <1> 	or	byte [kbd_flags_2],kbd_num_bit ; set Num Lock bit
  1877 00004B25 8036170020          <1> 	xor	byte [kbd_flags_1],kbd_num_bit ; toggle Num Lock bit
  1878 00004B2A EB45                <1> 	jmp	.no_buffer
  1879                              <1> .21:
  1880 00004B2C 3CC5                <1> 	cmp	al,kbd_num_code+80h
  1881 00004B2E 7507                <1> 	jne	.translate
  1882 00004B30 80261800DF          <1> 	and	byte [kbd_flags_2],~kbd_num_bit ; clear Num Lock bit
  1883 00004B35 EB68                <1> 	jmp	set_LEDs
  1884                              <1> 
  1885                              <1> ; translate keyboard scan code to ASCII and BIOS scan code
  1886                              <1> 
  1887                              <1> .translate:
  1888 00004B37 F606180008          <1> 	test	byte [kbd_flags_2],08h	; check pause flag
  1889 00004B3C 7407                <1> 	jz	.check_release
  1890 00004B3E 80261800F7          <1> 	and	byte [kbd_flags_2],~08h	; clear pause flag
  1891 00004B43 EB2C                <1> 	jmp	.no_buffer		; don't put key in buffer
  1892                              <1> .check_release:
  1893 00004B45 A880                <1> 	test	al,80h			; ignore key release and KBC responses
  1894 00004B47 7528                <1> 	jnz	.no_buffer
  1895                              <1> 
  1896 00004B49 E8B0D7              <1> 	call	scan_xlat
  1897 00004B4C 85C0                <1> 	test	ax,ax		 	; check for bad code
  1898 00004B4E 7421                <1> 	je	.no_buffer
  1899                              <1> 
  1900                              <1> .put_in_buffer:
  1901 00004B50 56                  <1> 	push	si			; FIXME: Use Int 16h/05 instead?
  1902 00004B51 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  1903 00004B55 89DE                <1> 	mov	si,bx
  1904 00004B57 83C302              <1> 	add	bx,2
  1905 00004B5A 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  1906 00004B5E 7504                <1> 	jne	.1
  1907 00004B60 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  1908                              <1> .1:
  1909 00004B64 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  1910 00004B68 7406                <1> 	je	.no_space		; no space in buffer
  1911 00004B6A 8904                <1> 	mov	word [si],ax
  1912 00004B6C 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  1913                              <1> 
  1914                              <1> .no_space:
  1915 00004B70 5E                  <1> 	pop	si
  1916                              <1> 
  1917                              <1> .no_buffer:
  1918 00004B71 80269600FC          <1> 	and     byte [kbd_flags_3],0FCh	; E0, E1 not last code
  1919                              <1> 
  1920                              <1> keyboard_int_exit:
  1921                              <1> %ifdef AT_KEYBOARD
  1922                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  1923                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  1924                              <1> 	call	kbc_write_command
  1925                              <1> %endif
  1926                              <1> %endif ; AT_KEYBOARD
  1927 00004B76 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1928 00004B78 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC.
  1929                              <1> 
  1930                              <1> keyboard_int_exit1:
  1931 00004B7A 1F                  <1> 	pop	ds
  1932 00004B7B 5B                  <1> 	pop	bx
  1933 00004B7C 58                  <1> 	pop	ax
  1934 00004B7D CF                  <1> 	iret
  1935                              <1> 
  1936                              <1> pause:
  1937 00004B7E 8036180008          <1> 	xor	byte [kbd_flags_2],08h	; toggle pause flag
  1938 00004B83 74F1                <1> 	jz	keyboard_int_exit	; jump if pause flag is unset now
  1939                              <1> 
  1940 00004B85 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1941 00004B87 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  1942                              <1> 
  1943                              <1> .pause_loop:
  1944 00004B89 F606180008          <1> 	test	byte [kbd_flags_2],08h
  1945 00004B8E 75F9                <1> 	jnz	.pause_loop		; wait if pause flag is set
  1946 00004B90 EBE8                <1> 	jmp	keyboard_int_exit1
  1947                              <1> 
  1948                              <1> print_screen:
  1949 00004B92 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1950 00004B94 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  1951 00004B96 CD05                <1> 	int	5h			; INT 5 - print screen
  1952 00004B98 80269600FD          <1> 	and     byte [kbd_flags_3],0FDh	; clear E0 flag
  1953 00004B9D EBDB                <1> 	jmp	keyboard_int_exit1
  1954                              <1> 
  1955                              <1> ;=========================================================================
  1956                              <1> ; set_LEDs - Update the kbd_flags_4 LED bits from the kbd_flags_1
  1957                              <1> ; 	     variable and update LEDs on the keyboard
  1958                              <1> ;-------------------------------------------------------------------------
  1959                              <1> set_LEDs:
  1960 00004B9F B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1961 00004BA1 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  1962                              <1> 
  1963 00004BA3 A01700              <1> 	mov	al,byte [kbd_flags_1]
  1964 00004BA6 D0E8                <1> 	shr	al,1
  1965 00004BA8 D0E8                <1> 	shr	al,1
  1966 00004BAA D0E8                <1> 	shr	al,1
  1967 00004BAC D0E8                <1> 	shr	al,1
  1968 00004BAE 2407                <1> 	and	al,111b
  1969 00004BB0 80269700F8          <1> 	and	byte [kbd_flags_4],0F8h	; clear LED bits.
  1970 00004BB5 08069700            <1> 	or	byte [kbd_flags_4],al	; mask in new bits.
  1971                              <1> %ifdef AT_KEYBOARD
  1972                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  1973                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  1974                              <1> 	call	kbc_write_command
  1975                              <1> %endif
  1976                              <1> 	mov	ah,al			; save LED bits
  1977                              <1> 
  1978                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  1979                              <1> 	call	kbc_write_command
  1980                              <1> 
  1981                              <1> 	mov	al,kbd_cmd_leds		; set LEDs command
  1982                              <1> 	call	kbc_kb_send		; send the command to the keyboard
  1983                              <1> 	mov	al,ah			; get parameter byte
  1984                              <1> 	call	kbc_kb_send		; send parameter to the keyboard
  1985                              <1> 
  1986                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  1987                              <1> 	call	kbc_write_command
  1988                              <1> 	mov	al,dev_cmd_enable	; restart keyboard scanning
  1989                              <1> 	call	kbc_kb_send
  1990                              <1> %endif ; AT_KEYBOARD
  1991 00004BB9 EBBF                <1> 	jmp	keyboard_int_exit1
  1992                              <1> 
  1993                              <1> ;=========================================================================
  1994                              <1> ; kbd_buffer_init - Setup keyboard buffer
  1995                              <1> ;-------------------------------------------------------------------------
  1996                              <1> kbd_buffer_init:
  1997 00004BBB B81E00              <1> 	mov	ax,kbd_buffer		; setup keyboard buffer
  1998 00004BBE A38000              <1> 	mov	word [kbd_buffer_start],ax
  1999 00004BC1 A31A00              <1> 	mov	word [kbd_buffer_head],ax
  2000 00004BC4 A31C00              <1> 	mov	word [kbd_buffer_tail],ax
  2001 00004BC7 83C020              <1> 	add	ax,20h			; size of the keyboard buffer
  2002 00004BCA A38200              <1> 	mov	word [kbd_buffer_end],ax
  2003 00004BCD 31C0                <1> 	xor	ax,ax			; clear keyboard flags
  2004 00004BCF A31700              <1> 	mov	word [kbd_flags_1],ax
  2005 00004BD2 A31800              <1> 	mov	word [kbd_flags_2],ax
  2006 00004BD5 A39600              <1> 	mov	word [kbd_flags_3],ax
  2007 00004BD8 A39700              <1> 	mov	word [kbd_flags_4],ax
  2008 00004BDB C3                  <1> 	ret
  1383                                  %include	"floppy2.inc"		; INT 13
  1384                              <1> ;=========================================================================
  1385                              <1> ; floppy2.inc - BIOS floppy disk services (part 2 of 2)
  1386                              <1> ;	INT 13h, function AH=02h
  1387                              <1> ;	INT 13h, function AH=03h
  1388                              <1> ;	INT 13h, function AH=04h
  1389                              <1> ;	INT 13h, function AH=05h
  1390                              <1> ;	- see floppy1.inc for other INT 13h functions
  1391                              <1> ;-------------------------------------------------------------------------
  1392                              <1> ;
  1393                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1394                              <1> ;
  1395                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
  1396                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1397                              <1> ;
  1398                              <1> ; This program is free software: you can redistribute it and/or modify
  1399                              <1> ; it under the terms of the GNU General Public License as published by
  1400                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1401                              <1> ; (at your option) any later version.
  1402                              <1> ;
  1403                              <1> ; This program is distributed in the hope that it will be useful,
  1404                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1405                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1406                              <1> ; GNU General Public License for more details.
  1407                              <1> ;
  1408                              <1> ; You should have received a copy of the GNU General Public License
  1409                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1410                              <1> ;
  1411                              <1> ;=========================================================================
  1412                              <1> 
  1413                              <1> ;-------------------------------------------------------------------------
  1414                              <1> ; offsets for registers on stack
  1415                              <1> int_13_bp	equ	0
  1416                              <1> int_13_ds	equ	int_13_bp+2
  1417                              <1> int_13_di	equ	int_13_ds+2
  1418                              <1> int_13_si	equ	int_13_di+2
  1419                              <1> int_13_dx	equ	int_13_si+2
  1420                              <1> int_13_dl	equ	int_13_dx
  1421                              <1> int_13_dh	equ	int_13_dx+1
  1422                              <1> int_13_cx	equ	int_13_dx+2
  1423                              <1> int_13_cl	equ	int_13_cx
  1424                              <1> int_13_ch	equ	int_13_cx+1
  1425                              <1> int_13_bx	equ	int_13_cx+2
  1426                              <1> int_13_bl	equ	int_13_bx
  1427                              <1> int_13_bh	equ	int_13_bx+1
  1428                              <1> int_13_ax	equ	int_13_bx+2
  1429                              <1> int_13_al	equ	int_13_ax
  1430                              <1> int_13_ah	equ	int_13_ax+1
  1431                              <1> int_13_ip	equ	int_13_ax+2
  1432                              <1> int_13_cs	equ	int_13_ip+2
  1433                              <1> int_13_flags	equ	int_13_cs+2
  1434                              <1> int_13_flags_l	equ	int_13_flags
  1435                              <1> 
  1436                              <1> ;=========================================================================
  1437                              <1> ; int_13 - BIOS floppy disk services
  1438                              <1> ; Input:
  1439                              <1> ;	AH = function
  1440                              <1> ;		00h - Reset disk system
  1441                              <1> ;		01h - Get status of last operation
  1442                              <1> ;		02h - Read disk sectors
  1443                              <1> ;		03h - Write disk sectors
  1444                              <1> ;		04h - Verify disk sectors
  1445                              <1> ;		05h - Format track
  1446                              <1> ;		08h - Get drive parameters
  1447                              <1> ;		15h - Get disk type
  1448                              <1> ;		16h - Detect disk change
  1449                              <1> ;		17h - Set disk type for format
  1450                              <1> ;		18h - Set media type for format
  1451                              <1> ; Output:
  1452                              <1> ;	- depends on function
  1453                              <1> ;	- for most functions:
  1454                              <1> ;		CF clear if successful
  1455                              <1> ;			AH = 00h - successful completion
  1456                              <1> ;		CF set on error
  1457                              <1> ;			AH = error code
  1458                              <1> ;-------------------------------------------------------------------------
  1459 00004BDC FF<rep 7Dh>         <1> 	setloc	0EC59h			; INT 13 (Floppy) Entry Point
  1459          ******************  <1>  warning: Inserting 125 bytes [-w+user]
  1460                              <1> int_13:
  1461 00004C59 FB                  <1> 	sti
  1462 00004C5A 50                  <1> 	push	ax
  1463 00004C5B 53                  <1> 	push	bx
  1464 00004C5C 51                  <1> 	push	cx
  1465 00004C5D 52                  <1> 	push	dx
  1466 00004C5E 56                  <1> 	push	si
  1467 00004C5F 57                  <1> 	push	di
  1468 00004C60 1E                  <1> 	push	ds
  1469 00004C61 55                  <1> 	push	bp
  1470 00004C62 89E5                <1> 	mov	bp,sp
  1471                              <1> 
  1472 00004C64 BB4000              <1> 	mov	bx,biosdseg
  1473 00004C67 8EDB                <1> 	mov	ds,bx
  1474                              <1> 
  1475                              <1> ; fn01 doesn't need drive type
  1476                              <1> 
  1477 00004C69 80FC01              <1> 	cmp	ah,01h
  1478 00004C6C 7503E965CC          <1> 	je	int_13_fn01		; Get status of last operation
  1479                              <1> 
  1480                              <1> 
  1481 00004C71 80FA01              <1> 	cmp	dl,1
  1482 00004C74 7703                <1> 	ja	.try_fn08		; invalid drive number, but try fn08
  1483                              <1> 
  1484                              <1> ; get drive type
  1485                              <1> 
  1486 00004C76 E85DD3              <1> 	call	get_drive_type		; AL = drive type
  1487                              <1> 
  1488                              <1> ; fn08 needs physical drive information, but can accept drive numbers 0 - 7Fh
  1489                              <1> 
  1490                              <1> .try_fn08:
  1491 00004C79 80FC08              <1> 	cmp	ah,08h
  1492 00004C7C 7503E961CC          <1> 	je	int_13_fn08		; Get drive parameters
  1493                              <1> 
  1494 00004C81 80FA01              <1> 	cmp	dl,1
  1495 00004C84 7743                <1> 	ja	.invalid_parameters	; invalid drive number (> 1)
  1496                              <1> 
  1497                              <1> ; fn15 accepts not existing drive numbers (and returns status 00h for them)
  1498                              <1> 
  1499 00004C86 80FC15              <1> 	cmp	ah,15h
  1500 00004C89 7503E900CD          <1> 	je	int_13_fn15		; Get disk type
  1501                              <1> 
  1502                              <1> ; all other functions require an existing drive number
  1503                              <1> 
  1504 00004C8E 3C00                <1> 	cmp	al,type_none
  1505 00004C90 7437                <1> 	je	.invalid_parameters	; drive not present or not configured
  1506                              <1> 
  1507                              <1> ; dispatch
  1508                              <1> 
  1509 00004C92 80FC00              <1> 	cmp	ah,00h
  1510 00004C95 7503E9CDCB          <1> 	je	int_13_fn00		; Reset disk system
  1511 00004C9A 80FC02              <1> 	cmp	ah,02h
  1512 00004C9D 746B                <1> 	je	int_13_fn02		; Read disk sectors
  1513 00004C9F 80FC03              <1> 	cmp	ah,03h
  1514 00004CA2 7466                <1> 	je	int_13_fn03		; Write disk sectors
  1515 00004CA4 80FC04              <1> 	cmp	ah,04h
  1516 00004CA7 7461                <1> 	je	int_13_fn04		; Verify disk sectors
  1517 00004CA9 80FC05              <1> 	cmp	ah,05h
  1518 00004CAC 7503E9C401          <1> 	je	int_13_fn05		; Format track
  1519 00004CB1 80FC16              <1> 	cmp	ah,16h
  1520 00004CB4 7503E9F0CC          <1> 	je	int_13_fn16		; Detect disk change
  1521 00004CB9 80FC17              <1> 	cmp	ah,17h
  1522 00004CBC 7503E92ACD          <1> 	je	int_13_fn17		; Set disk type for format
  1523 00004CC1 80FC18              <1> 	cmp	ah,18h
  1524 00004CC4 7503E97DCD          <1> 	je	int_13_fn18		; Set media type for format
  1525                              <1> 
  1526                              <1> .invalid_parameters:
  1527 00004CC9 B401                <1> 	mov	ah,fdc_e_invalid
  1528 00004CCB 88264100            <1> 	mov	byte [fdc_last_error],ah
  1529 00004CCF F9                  <1> 	stc				; error condition
  1530 00004CD0 EB1F                <1> 	jmp	int_13_exit
  1531                              <1> 
  1532                              <1> ;-------------------------------------------------------------------------
  1533                              <1> ; int_13_upd_exit - Update diskette change flag and exit
  1534                              <1> ; FIXME: what uses this (fdc_info) flag?
  1535                              <1> 
  1536                              <1> int_13_upd_exit:
  1537 00004CD2 9C                  <1> 	pushf
  1538 00004CD3 50                  <1> 	push	ax
  1539 00004CD4 8A4608              <1> 	mov	al,byte [bp+int_13_dl]	; AL = drive number
  1540 00004CD7 3C01                <1> 	cmp	al,1
  1541 00004CD9 7714                <1> 	ja	.no_update		; skip if drive number > 1
  1542 00004CDB E898D2              <1> 	call	get_media_state		; BL = drive media state
  1543 00004CDE F6C310              <1> 	test	bl,fdc_m_established
  1544 00004CE1 740C                <1> 	jz	.no_update		; skip if media type not established
  1545 00004CE3 B404                <1> 	mov	ah,04h			; set bit 2 (drive 0 type determined)
  1546 00004CE5 08C0                <1> 	or	al,al
  1547 00004CE7 7402                <1> 	jz	.drive_0
  1548 00004CE9 B440                <1> 	mov	ah,40h			; set bit 6 (drive 1 type determined)
  1549                              <1> 
  1550                              <1> .drive_0:
  1551 00004CEB 08268F00            <1> 	or	byte [fdc_info],ah	; set media detected bit
  1552                              <1> 
  1553                              <1> .no_update:
  1554 00004CEF 58                  <1> 	pop	ax
  1555 00004CF0 9D                  <1> 	popf
  1556                              <1> 
  1557                              <1> int_13_exit:
  1558 00004CF1 88660F              <1> 	mov	byte [bp+int_13_ah],ah	; pass AH to the caller
  1559 00004CF4 B80102              <1> 	mov	ax,201h			; set IF and CF
  1560 00004CF7 7205                <1> 	jc	.set_error		; there is an error
  1561 00004CF9 806614FE            <1> 	and	byte [bp+int_13_flags_l],0FEh ; no errors - clear CF
  1562 00004CFD 48                  <1> 	dec	ax			; clear CF in AX too
  1563                              <1> 
  1564                              <1> .set_error:
  1565 00004CFE 094614              <1> 	or	word [bp+int_13_flags],ax
  1566 00004D01 5D                  <1> 	pop	bp
  1567 00004D02 1F                  <1> 	pop	ds
  1568 00004D03 5F                  <1> 	pop	di
  1569 00004D04 5E                  <1> 	pop	si
  1570 00004D05 5A                  <1> 	pop	dx
  1571 00004D06 59                  <1> 	pop	cx
  1572 00004D07 5B                  <1> 	pop	bx
  1573 00004D08 58                  <1> 	pop	ax
  1574 00004D09 CF                  <1> 	iret
  1575                              <1> 
  1576                              <1> ;=========================================================================
  1577                              <1> ; int_13_fn02 - Read disk sectors
  1578                              <1> ; int_13_fn03 - Write disk sectors
  1579                              <1> ; int_13_fn04 - Verify disk sectors
  1580                              <1> ; Input:
  1581                              <1> ;	AH = function
  1582                              <1> ;		02h - read
  1583                              <1> ;		03h - write
  1584                              <1> ;		04h - verify
  1585                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
  1586                              <1> ;	CH = cylinder number
  1587                              <1> ;	CL = sector number
  1588                              <1> ;	DH = head number (0 or 1)
  1589                              <1> ;	DL = drive number (0 or 1)
  1590                              <1> ;	ES:BX -> data buffer
  1591                              <1> ; Output:
  1592                              <1> ;	CF clear if successful
  1593                              <1> ;		AH = 00h - successful completion
  1594                              <1> ;		AL = number of sectors transferred or verified
  1595                              <1> ;	CF set on error
  1596                              <1> ;		AH = error code
  1597                              <1> ;-------------------------------------------------------------------------
  1598                              <1> int_13_fn02:
  1599                              <1> int_13_fn03:
  1600                              <1> int_13_fn04:
  1601 00004D0A 807E0E00            <1> 	cmp	byte [bp+int_13_al],0	; number of sectors must be non zero
  1602 00004D0E 7503E95D01          <1> 	je	.invalid_request
  1603                              <1> 
  1604 00004D13 E860D2              <1> 	call	get_media_state		; BL = media state
  1605                              <1> 
  1606 00004D16 80FC03              <1> 	cmp	ah,03h			; write function
  1607 00004D19 7407                <1> 	je	.set_write
  1608 00004D1B 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; clear the write bit
  1609 00004D20 EB05                <1> 	jmp	.motor_on
  1610                              <1> 
  1611                              <1> .set_write:
  1612 00004D22 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; set the write bit
  1613                              <1> 
  1614                              <1> .motor_on:
  1615 00004D27 E8A0CE              <1> 	call	fdc_motor_on
  1616                              <1> 
  1617 00004D2A 3C01                <1> 	cmp	al,type_360
  1618 00004D2C 7420                <1> 	je	.set_media_360		; set media type for 360K drive
  1619 00004D2E 3C03                <1> 	cmp	al,type_720
  1620 00004D30 7420                <1> 	je	.set_media_720		; set media type for 720K drive
  1621                              <1> 
  1622 00004D32 E83ACF              <1> 	call	fdc_disk_change
  1623 00004D35 80FC06              <1> 	cmp	ah,fdc_e_changed
  1624 00004D38 7425                <1> 	je	.establish_media	; disk changed - establish media
  1625 00004D3A 80FC00              <1> 	cmp	ah,fdc_e_success
  1626 00004D3D 7403E92101          <1> 	jne	.error_end_io		; fdc_disk_change failed
  1627                              <1> 
  1628 00004D42 F6C310              <1> 	test	bl,fdc_m_established
  1629 00004D45 7418                <1> 	jz	.establish_media	; jump if media type is not established
  1630                              <1> 
  1631 00004D47 88D8                <1> 	mov	al,bl			; media type to AL (transfer rate)
  1632 00004D49 E8DAD1              <1> 	call	fdc_set_rate		; select transfer rate
  1633 00004D4C EB19                <1> 	jmp	.fdc_send_specify
  1634                              <1> 
  1635                              <1> ; 360K and 720K drives don't support change line, and only support
  1636                              <1> ; one media type - set it here
  1637                              <1> 
  1638                              <1> .set_media_360:
  1639 00004D4E B093                <1> 	mov	al,fdc_m_360in360	; 250Kbps, media established, 360K/360K
  1640 00004D50 EB02                <1> 	jmp	.set_media
  1641                              <1> 
  1642                              <1> .set_media_720:
  1643 00004D52 B097                <1> 	mov	al,fdc_m_720		; 250Kbps, media established, 720K/720K
  1644                              <1> 
  1645                              <1> .set_media:
  1646 00004D54 E829D2              <1> 	call	set_media_state		; save media state (AL) to the data area
  1647 00004D57 E8CCD1              <1> 	call	fdc_set_rate		; send transfer rate (in AL) to FDC
  1648 00004D5A 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX (trashed by fdc_set_rate)
  1649 00004D5D EB08                <1> 	jmp	.fdc_send_specify
  1650                              <1> 
  1651                              <1> .establish_media:
  1652 00004D5F E8FFD0              <1> 	call	fdc_detect_media	; detect media type
  1653 00004D62 7303E9FC00          <1> 	jc	.error_end_io
  1654                              <1> 	
  1655                              <1> .fdc_send_specify:
  1656 00004D67 B803BF              <1> 	mov	ax,0BF03h		; FDC Specify command +
  1657                              <1> 					; 0BFh - specify byte 0 for 1.44M
  1658 00004D6A 80FB17              <1> 	cmp	bl,fdc_m_1440		; 1.44M?
  1659 00004D6D 7409                <1> 	je	.fdc_send_specify_cmd	; jump if 1.44M
  1660 00004D6F B4DF                <1> 	mov	ah,0DFh			; 0DFh - specify byte 0 for 360/1.2/720
  1661 00004D71 80FBD7              <1> 	cmp	bl,fdc_m_2880		; 2.88M?
  1662 00004D74 7502                <1> 	jne	.fdc_send_specify_cmd	; jump if not 2.88M
  1663 00004D76 B4AF                <1> 	mov	ah,0AFh			; 0AFh - specify byte 0 for 2.88M
  1664                              <1> 
  1665                              <1> .fdc_send_specify_cmd:
  1666 00004D78 BE0200              <1> 	mov	si,2			; specify byte 1
  1667 00004D7B B103                <1> 	mov	cl,3			; 3 bytes command
  1668 00004D7D E8A8CF              <1> 	call	fdc_send_cmd
  1669 00004D80 7303E9DE00          <1> 	jc	.error_end_io		; jump if failed to send command
  1670 00004D85 1E                  <1> 	push	ds
  1671 00004D86 31F6                <1> 	xor	si,si
  1672 00004D88 8EDE                <1> 	mov	ds,si
  1673 00004D8A C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1674 00004D8E 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; number of sectors to transfer
  1675 00004D91 B400                <1> 	mov	ah,00h
  1676 00004D93 88C8                <1> 	mov	al,cl			; AX =  number of sectors to transfer
  1677 00004D95 024E0A              <1> 	add	cl,byte [bp+int_13_cl]	; number of the first sector to access
  1678 00004D98 FEC9                <1> 	dec	cl			; minus 1 - last sector to access
  1679 00004D9A 3A4C04              <1> 	cmp	cl,byte [si+4]		; compare with sectors per track
  1680 00004D9D 7603                <1> 	jbe	.calc_dma_count		; jump if last sector <= sectors/track
  1681 00004D9F 884C04              <1> 	mov	byte [si+4],cl		; update it in disk parameter table
  1682                              <1> 
  1683                              <1> .calc_dma_count:
  1684 00004DA2 8A4C03              <1> 	mov	cl,byte [si+3]		; bytes per sector (02h = 512 bytes...)
  1685 00004DA5 80C107              <1> 	add	cl,7			; CL = log2 (bytes per sector)
  1686 00004DA8 D3E0                <1> 	shl	ax,cl			; AX = AL * 2 ^ CL = AX * bytes/sector
  1687 00004DAA 1F                  <1> 	pop	ds
  1688 00004DAB 48                  <1> 	dec	ax			; minus one byte
  1689 00004DAC 89C1                <1> 	mov	cx,ax			; ...count for DMA
  1690                              <1> 
  1691 00004DAE 8A660F              <1> 	mov	ah,byte [bp+int_13_ah]	; AH = function
  1692 00004DB1 B046                <1> 	mov	al,46h			; DMA mode byte for read, channel 2
  1693 00004DB3 80FC02              <1> 	cmp	ah,02h			; read function?
  1694 00004DB6 7409                <1> 	je	.configure_dma		; jump if read function
  1695 00004DB8 B04A                <1> 	mov	al,4Ah			; DMA mode byte for write, channel 2
  1696 00004DBA 80FC03              <1> 	cmp	ah,03h			; write function?
  1697 00004DBD 7402                <1> 	je	.configure_dma		; jump if write function
  1698 00004DBF B042                <1> 	mov	al,42h			; DMA mode byte for verify, channel 2
  1699                              <1> 
  1700                              <1> .configure_dma:
  1701 00004DC1 E8FCCE              <1> 	call	fdc_configure_dma
  1702 00004DC4 8B4E0A              <1> 	mov	cx,word [bp+int_13_cx]	; restore parameters
  1703 00004DC7 7303E99700          <1> 	jc	.error_end_io		; jump if DMA boundry crossed
  1704                              <1> 
  1705 00004DCC E84CCD              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  1706 00004DCF 7303E98800          <1> 	jc	.error_fdc_get_result	; jump if seek failed
  1707                              <1> 
  1708 00004DD4 1E                  <1> 	push	ds
  1709 00004DD5 31F6                <1> 	xor	si,si
  1710 00004DD7 8EDE                <1> 	mov	ds,si
  1711 00004DD9 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1712 00004DDD 8A6403              <1> 	mov	ah,byte [si+3]		; AH = sector size (02h = 512)
  1713 00004DE0 88C8                <1> 	mov	al,cl			; AL = first sector number
  1714 00004DE2 89C7                <1> 	mov	di,ax			; DI = first sector, sector size
  1715 00004DE4 8A5C04              <1> 	mov	bl,byte [si+4]		; BL = sectors per track
  1716 00004DE7 8A6C06              <1> 	mov	ch,byte [si+6]		; CH = special sector size
  1717 00004DEA 1F                  <1> 	pop	ds
  1718                              <1> 
  1719 00004DEB 53                  <1> 	push	bx
  1720 00004DEC E887D1              <1> 	call	get_media_state
  1721 00004DEF 88DA                <1> 	mov	dl,bl			; DL = drive media state
  1722 00004DF1 5B                  <1> 	pop	bx
  1723 00004DF2 B71B                <1> 	mov	bh,1Bh			; read / write gap for 1.2M/1.44M/2.88M
  1724 00004DF4 80FA17              <1> 	cmp	dl,fdc_m_1440		; 1.44M media?
  1725 00004DF7 7413                <1> 	je	.gap_set		; jump if 1.44M media
  1726 00004DF9 80FA15              <1> 	cmp	dl,fdc_m_1200in1200	; 1.2M in 1.2M drive?
  1727 00004DFC 740E                <1> 	je	.gap_set		; jump if 1.2M media in 1.2M drive
  1728 00004DFE 80FAD7              <1> 	cmp	dl,fdc_m_2880		; 2.88 media?
  1729 00004E01 7409                <1> 	je	.gap_set		; jump if 2.88M media
  1730 00004E03 B723                <1> 	mov	bh,23h			; read / write gap for 360K in 1.2M drv
  1731 00004E05 80FA74              <1> 	cmp	dl,fdc_m_360in1200	; 360K in 1.2M drive
  1732 00004E08 7402                <1> 	je	.gap_set		; jump if 360K media in 1.2M drive
  1733 00004E0A B72A                <1> 	mov	bh,2Ah			; read / write gap for 360K and 720K drv
  1734                              <1> 	
  1735                              <1> .gap_set:
  1736 00004E0C 8A7609              <1> 	mov	dh,byte [bp+int_13_dh]	; restore DH
  1737 00004E0F 8A460B              <1> 	mov	al,byte [bp+int_13_ch]	; cylinder
  1738 00004E12 88F4                <1> 	mov	ah,dh			; head
  1739                              <1> 					; replace with mov ah,byte[bp+int_13_dh]
  1740 00004E14 89C6                <1> 	mov	si,ax			; head / cylinder (bytes 2-3)
  1741 00004E16 D0E4                <1> 	shl	ah,1
  1742 00004E18 D0E4                <1> 	shl	ah,1
  1743 00004E1A 0A6608              <1> 	or	ah,byte [bp+int_13_dl]	; FDC command byte 1 (head & drive)
  1744 00004E1D B0E6                <1> 	mov	al,0E6h			; FDC Read command
  1745 00004E1F 807E0F03            <1> 	cmp	byte [bp+int_13_ah],3	; write function?
  1746 00004E23 7502                <1> 	jne	.send_command		; jump if not write 
  1747 00004E25 B0C5                <1> 	mov	al,0C5h			; FDC Write command
  1748                              <1> 
  1749                              <1> .send_command:
  1750 00004E27 B109                <1> 	mov	cl,9			; 9 bytes command
  1751 00004E29 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ
  1752 00004E2E E8F7CE              <1> 	call	fdc_send_cmd
  1753 00004E31 7229                <1> 	jc	.error_fdc_get_result	; jump if failed to send command
  1754 00004E33 E809D1              <1> 	call	fdc_wait_irq
  1755 00004E36 7224                <1> 	jc	.error_fdc_get_result
  1756 00004E38 B107                <1> 	mov	cl,7
  1757 00004E3A E85DCF              <1> 	call	fdc_get_result		; read result bytes
  1758 00004E3D 7224                <1> 	jc	.error_end_io
  1759                              <1> 
  1760 00004E3F E8B2CF              <1> 	call	fdc_get_error
  1761                              <1> 
  1762 00004E42 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  1763                              <1> ;	mov	dh,byte [bp+int_13_dh]	; DH = head
  1764                              <1> 					; Optimization: DH is preserved
  1765 00004E45 E8FCCD              <1> 	call	fdc_end_io		; return number of last sector in BL
  1766 00004E48 88D8                <1> 	mov	al,bl			; AL = last transferred sector
  1767 00004E4A 2A460A              <1> 	sub	al,byte [bp+int_13_cl]	; minus the first sector
  1768                              <1> 
  1769                              <1> .zero_sectors:
  1770 00004E4D 08E4                <1> 	or	ah,ah
  1771 00004E4F 7401                <1> 	jz	.exit			; jump if no errors
  1772                              <1> 
  1773                              <1> .error:
  1774 00004E51 F9                  <1> 	stc				; indicate error
  1775                              <1> 
  1776                              <1> .exit:
  1777 00004E52 88264100            <1> 	mov	byte [fdc_last_error],ah
  1778 00004E56 88460E              <1> 	mov	byte [bp+int_13_al],al	; number of transferred sectors
  1779 00004E59 E976FE              <1> 	jmp	int_13_upd_exit
  1780                              <1> 
  1781                              <1> .error_fdc_get_result:
  1782 00004E5C B107                <1> 	mov	cl,7
  1783 00004E5E 50                  <1> 	push	ax
  1784 00004E5F E838CF              <1> 	call	fdc_get_result		; read result bytes
  1785 00004E62 58                  <1> 	pop	ax
  1786                              <1> 
  1787                              <1> .error_end_io:
  1788 00004E63 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  1789 00004E66 8A7609              <1> 	mov	dh,byte [bp+int_13_dh]	; DH = head
  1790 00004E69 E8D8CD              <1> 	call	fdc_end_io		; return number of last sector in BL
  1791 00004E6C B000                <1> 	mov	al,00h			; failure, no sectors transferred
  1792 00004E6E EBDD                <1> 	jmp	.zero_sectors
  1793                              <1> 
  1794                              <1> .invalid_request:
  1795 00004E70 B80001              <1> 	mov	ax,fdc_e_invalid << 8	; AH = 01h, AL = 00h (0 sectors trans)
  1796 00004E73 EBDC                <1> 	jmp	.error
  1797                              <1> 
  1798                              <1> ;=========================================================================
  1799                              <1> ; int_13_fn05 - Format track
  1800                              <1> ; Input:
  1801                              <1> ;	AH = 05h
  1802                              <1> ;	CH = track number
  1803                              <1> ;	DH = head number (0 or 1)
  1804                              <1> ;	DL = drive number (0 or 1)
  1805                              <1> ;	ES:BX -> address field buffer
  1806                              <1> ; Output:
  1807                              <1> ;	CF clear if successful
  1808                              <1> ;		AH = 00h - successful completion
  1809                              <1> ;	CF set on error
  1810                              <1> ;		AH = error code 
  1811                              <1> ;-------------------------------------------------------------------------
  1812                              <1> int_13_fn05:
  1813 00004E75 E8FED0              <1> 	call	get_media_state		; BL = drive media state
  1814 00004E78 F6C310              <1> 	test	bl,fdc_m_established
  1815 00004E7B 7503E98100          <1> 	jz	.timeout		; jump if media type is not established
  1816 00004E80 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; set the write bit
  1817 00004E85 E842CD              <1> 	call	fdc_motor_on
  1818 00004E88 E8E4CD              <1> 	call	fdc_disk_change		; read disk change line
  1819 00004E8B 726F                <1> 	jc	.error_end_io		; jump if disk change check failed
  1820 00004E8D 88D8                <1> 	mov	al,bl			; media type to AL (transfer rate)
  1821 00004E8F E894D0              <1> 	call	fdc_set_rate		; select transfer rate
  1822 00004E92 E822CA              <1> 	call	fdc_send_specify	; send FDC Specify command
  1823                              <1> 
  1824 00004E95 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; cylinder
  1825 00004E98 E880CC              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  1826 00004E9B 7256                <1> 	jc	.error_fdc_get_result	; jump if seek failed
  1827                              <1> 
  1828 00004E9D 1E                  <1> 	push	ds
  1829 00004E9E 31F6                <1> 	xor	si,si
  1830 00004EA0 8EDE                <1> 	mov	ds,si
  1831 00004EA2 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1832 00004EA6 8A4C04              <1> 	mov	cl,byte [si+4]		; sectors per track
  1833 00004EA9 8B7C07              <1> 	mov	di,word [si+7]		; format gap, sectors per track
  1834 00004EAC 8B7403              <1> 	mov	si,word [si+3]		; bytes per sector, sectors per track
  1835 00004EAF 1F                  <1> 	pop	ds
  1836                              <1> 
  1837 00004EB0 B500                <1> 	mov	ch,00h			; CX = sectors per track
  1838 00004EB2 D1E1                <1> 	shl	cx,1			; CX = CX * 4 (address field is 4 bytes)
  1839 00004EB4 D1E1                <1> 	shl	cx,1
  1840 00004EB6 49                  <1> 	dec	cx	 		; minus one byte...
  1841 00004EB7 B04A                <1> 	mov	al,4Ah			; DMA mode byte for write, channel 2
  1842 00004EB9 E804CE              <1> 	call	fdc_configure_dma
  1843 00004EBC 723E                <1> 	jc	.error_end_io		; DMA boundry crossed
  1844                              <1> 
  1845 00004EBE 88F4                <1> 	mov	ah,dh
  1846 00004EC0 D0E4                <1> 	shl	ah,1
  1847 00004EC2 D0E4                <1> 	shl	ah,1
  1848 00004EC4 0A6608              <1> 	or	ah,byte [bp+int_13_dl]	; FDC command byte 1 (head & drive)
  1849 00004EC7 B04D                <1> 	mov	al,4Dh			; FDC Format command
  1850 00004EC9 B106                <1> 	mov	cl,6			; 6 byte command
  1851 00004ECB 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ
  1852 00004ED0 E855CE              <1> 	call	fdc_send_cmd
  1853 00004ED3 720F                <1> 	jc	.exit_end_io		; jump if failed to send command
  1854 00004ED5 E867D0              <1> 	call	fdc_wait_irq
  1855 00004ED8 720A                <1> 	jc	.exit_end_io
  1856 00004EDA B107                <1> 	mov	cl,7
  1857 00004EDC E8BBCE              <1> 	call	fdc_get_result		; read result bytes
  1858 00004EDF 7203                <1> 	jc	.exit_end_io
  1859 00004EE1 E810CF              <1> 	call	fdc_get_error		; get error code
  1860                              <1> 
  1861                              <1> .exit_end_io:
  1862 00004EE4 E85DCD              <1> 	call	fdc_end_io
  1863 00004EE7 08E4                <1> 	or	ah,ah
  1864 00004EE9 7401                <1> 	jz	.exit			; jump if no errors
  1865                              <1> 
  1866                              <1> .error:
  1867 00004EEB F9                  <1> 	stc				; indicate error
  1868                              <1> 
  1869                              <1> .exit:
  1870 00004EEC 88264100            <1> 	mov	byte [fdc_last_error],ah
  1871 00004EF0 E9DFFD              <1> 	jmp	int_13_upd_exit
  1872                              <1> 
  1873                              <1> .error_fdc_get_result:
  1874 00004EF3 B107                <1> 	mov	cl,7
  1875 00004EF5 50                  <1> 	push	ax
  1876 00004EF6 E8A1CE              <1> 	call	fdc_get_result		; read result bytes
  1877 00004EF9 58                  <1> 	pop	ax
  1878 00004EFA EBE8                <1> 	jmp	.exit_end_io
  1879                              <1> 
  1880                              <1> .error_end_io:
  1881 00004EFC E845CD              <1> 	call	fdc_end_io
  1882 00004EFF EBEA                <1> 	jmp	.error
  1883                              <1> 
  1884                              <1> .timeout:
  1885 00004F01 B480                <1> 	mov	ah,fdc_e_timeout
  1886 00004F03 EBE6                <1> 	jmp	.error
  1887                              <1> 
  1888                              <1> .invalid_request:
  1889 00004F05 B401                <1> 	mov	ah,fdc_e_invalid
  1890 00004F07 EBE2                <1> 	jmp	.error
  1891                              <1> 
  1892                              <1> ;=========================================================================
  1893                              <1> ; int_0E - IRQ6 (FDC) service routine
  1894                              <1> ; Sets bit 7 in drive recalibration status byte (fdc_calib_state)
  1895                              <1> ;-------------------------------------------------------------------------
  1896 00004F09 FF<rep 4Eh>         <1> 	setloc	0EF57h
  1896          ******************  <1>  warning: Inserting 78 bytes [-w+user]
  1897                              <1> 
  1898                              <1> int_0E:
  1899 00004F57 50                  <1> 	push	ax
  1900 00004F58 1E                  <1> 	push	ds
  1901 00004F59 B84000              <1> 	mov	ax,biosdseg
  1902 00004F5C 8ED8                <1> 	mov	ds,ax
  1903 00004F5E 800E3E0080          <1> 	or	byte [fdc_calib_state],fdc_irq_flag ; set IRQ flag
  1904 00004F63 1F                  <1> 	pop	ds
  1905 00004F64 B020                <1> 	mov	al,20h			; send EOI to PIC
  1906 00004F66 E620                <1> 	out	pic1_reg0,al
  1907 00004F68 B80191              <1> 	mov	ax,9101h		; call "interrupt completed" OS hook
  1908 00004F6B CD15                <1> 	int	15h
  1909 00004F6D 58                  <1> 	pop	ax
  1910 00004F6E CF                  <1> 	iret
  1911                              <1> 
  1912                              <1> ;=========================================================================
  1913                              <1> ; Disk parameter tables in INT 1Eh format
  1914                              <1> ; Byte 0: First byte for specify command:
  1915                              <1> ;	bits 7-4: step rate ([32 ms - value * 2], e.g. 0D0h is 32-13*2 = 6 ms)
  1916                              <1> ;	bits 3-0: head unload time (0Fh = 240 ms)
  1917                              <1> ; Byte 1: Second byte for specify command:
  1918                              <1> ;	bits 7-1: head load time (1 = 4 ms)
  1919                              <1> ;	bit 0: non-DMA mode (always 0)
  1920                              <1> ; Byte 2: motor off timeout in clock ticks (25h - approximately 2 seconds)
  1921                              <1> ; Byte 3: sector size (00h - 128, 01h - 256, 02h - 512, 03h - 1024)
  1922                              <1> ; Byte 4: sectors per track
  1923                              <1> ; Byte 5: gap length for read/write (2Ah for 5.25", 1Bh for 3.5")
  1924                              <1> ; Byte 6: special sector size (0FFh - not used)
  1925                              <1> ; Byte 7: gap length for formating (50h for 5.25", 6Ch for 3.5")
  1926                              <1> ; Byte 8: format filler byte (default 0F6h)
  1927                              <1> ; Byte 9: head settle time in milliseconds
  1928                              <1> ; Byte A: motor start time, in 1/8 seconds
  1929                              <1> ; Byte B: number of cylinders minus one
  1930                              <1> ; Byte C: transfer rate (in bits 7 - 6)
  1931                              <1> ;-------------------------------------------------------------------------
  1932                              <1> media_360_in_360:
  1933 00004F6F DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  1933 00004F78 0F08                <1>
  1934 00004F7A 2780                <1> 	db	27h, 80h
  1935                              <1> media_1200:
  1936 00004F7C DF0225020F1BFF54F6- <1> 	db	0DFh, 02h, 25h, 02h, 0Fh, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 08h
  1936 00004F85 0F08                <1>
  1937 00004F87 4F00                <1> 	db	4Fh, 00h
  1938                              <1> media_720:
  1939 00004F89 DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  1939 00004F92 0F08                <1>
  1940 00004F94 4F80                <1> 	db	4Fh, 80h
  1941                              <1> media_1440:
  1942 00004F96 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
  1942 00004F9F 0F08                <1>
  1943 00004FA1 4F00                <1> 	db	4Fh, 00h
  1944                              <1> media_360_in_1200:
  1945 00004FA3 DF0225020923FF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 23h, 0FFh, 50h, 0F6h, 0Fh, 08h
  1945 00004FAC 0F08                <1>
  1946 00004FAE 2740                <1> 	db	27h, 40h
  1947                              <1> media_2880:
  1948 00004FB0 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  1948 00004FB9 0F08                <1>
  1949 00004FBB 4FC0                <1> 	db	4Fh, 0C0h
  1950                              <1> 
  1951                              <1> ;=========================================================================
  1952                              <1> ; Disk parameter table for IBM compatibility
  1953                              <1> ; Using 2.88M disk as it has maximal number of cylinders and sectors
  1954                              <1> ;-------------------------------------------------------------------------
  1955 00004FBD FF<rep Ah>          <1> 	setloc	0EFC7h
  1955          ******************  <1>  warning: Inserting 10 bytes [-w+user]
  1956                              <1> int_1E:
  1957 00004FC7 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  1957 00004FD0 0F08                <1>
  1958                              <1> ;	db	4Fh, 0C0h
  1384                                  %include	"printer2.inc"		; INT 17
  1385                              <1> ;=========================================================================
  1386                              <1> ; printer2.inc - Parallel printer support (part 2 of 2)
  1387                              <1> ;       INT 17h, function AH=00h
  1388                              <1> ;	INT 17h, function AH=02h
  1389                              <1> ;	- see printer1.inc for other INT 17h functions
  1390                              <1> ;-------------------------------------------------------------------------
  1391                              <1> ;
  1392                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1393                              <1> ;
  1394                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
  1395                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1396                              <1> ;
  1397                              <1> ; This program is free software: you can redistribute it and/or modify
  1398                              <1> ; it under the terms of the GNU General Public License as published by
  1399                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1400                              <1> ; (at your option) any later version.
  1401                              <1> ;
  1402                              <1> ; This program is distributed in the hope that it will be useful,
  1403                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1404                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1405                              <1> ; GNU General Public License for more details.
  1406                              <1> ;
  1407                              <1> ; You should have received a copy of the GNU General Public License
  1408                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1409                              <1> ;
  1410                              <1> ;=========================================================================
  1411                              <1> 
  1412                              <1> ;=========================================================================
  1413                              <1> ; int_17  - BIOS Printer Services
  1414                              <1> ;-------------------------------------------------------------------------
  1415                              <1> 	setloc	0EFD2h			; INT 17 Entry Point
  1416                              <1> int_17:
  1417 00004FD2 FB                  <1> 	sti
  1418 00004FD3 53                  <1> 	push	bx
  1419 00004FD4 52                  <1> 	push	dx
  1420 00004FD5 56                  <1> 	push	si
  1421 00004FD6 1E                  <1> 	push	ds
  1422 00004FD7 BB4000              <1> 	mov	bx,biosdseg
  1423 00004FDA 8EDB                <1> 	mov	ds,bx
  1424 00004FDC 83FA03              <1> 	cmp	dx,num_parallel
  1425 00004FDF 7326                <1> 	jae	int_17_error		; invalid port number specified
  1426 00004FE1 BE7800              <1> 	mov	si,printer_timeout	; printer port timeout setting in BDA
  1427 00004FE4 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  1428 00004FE6 89D3                <1> 	mov	bx,dx
  1429 00004FE8 D1E3                <1> 	shl	bx,1
  1430 00004FEA 8B5708              <1> 	mov	dx,word [equip_parallel+bx] ; DX = serial port address
  1431 00004FED 09D2                <1> 	or	dx,dx
  1432 00004FEF 7416                <1> 	jz	int_17_error		; specified port is not installed
  1433                              <1> 
  1434 00004FF1 88C3                <1> 	mov	bl,al			; save AL to BL
  1435                              <1> 
  1436 00004FF3 08E4                <1> 	or	ah,ah
  1437 00004FF5 7415                <1> 	jz	int_17_fn00		; AH = 00h
  1438 00004FF7 FECC                <1> 	dec	ah
  1439 00004FF9 7503E9A8D5          <1> 	jz	int_17_fn01		; AH = 01h
  1440 00004FFE FECC                <1> 	dec	ah
  1441 00005000 7436                <1> 	jz	int_17_fn02		; AH = 02h
  1442                              <1> 
  1443                              <1> int_17_exit:
  1444 00005002 80F448              <1> 	xor	ah,prn_stat_invert	; invert bits 3 and 6 of the status
  1445 00005005 88D8                <1> 	mov	al,bl			; restore AL
  1446                              <1> 
  1447                              <1> int_17_error:
  1448 00005007 1F                  <1> 	pop	ds
  1449 00005008 5E                  <1> 	pop	si
  1450 00005009 5A                  <1> 	pop	dx
  1451 0000500A 5B                  <1> 	pop	bx
  1452 0000500B CF                  <1> 	iret
  1453                              <1> 
  1454                              <1> ;=========================================================================
  1455                              <1> ; int_17_fn00 - Print character
  1456                              <1> ; Input:
  1457                              <1> ;	AH = 0 - function 00h - print character
  1458                              <1> ;	AL = character to print
  1459                              <1> ;	DX = printer port number (0-2)
  1460                              <1> ; Output:
  1461                              <1> ;	AH = printer status:
  1462                              <1> ;		bit 0	= 1	- timeout error
  1463                              <1> ;		bit 1,2		- reserved
  1464                              <1> ;		bit 3	= 1	- I/O error
  1465                              <1> ;		bit 4	= 1	- printed selected
  1466                              <1> ;		bit 5	= 1	- out of paper
  1467                              <1> ;		bit 6	= 1	- acknowledge from printer
  1468                              <1> ;		bit 7	= 1	- printer not busy
  1469                              <1> ;-------------------------------------------------------------------------
  1470                              <1> int_17_fn00:
  1471 0000500C EE                  <1> 	out	dx,al			; output the character to the data port
  1472 0000500D 42                  <1> 	inc	dx			; DX = prn_stat_reg
  1473                              <1> 					; OPTIMIZATION:
  1474                              <1> 					; prn_stat_reg = prn_data_reg + 1
  1475 0000500E EC                  <1> 	in	al,dx			; read status
  1476 0000500F 88C4                <1> 	mov	ah,al			; AH = printer status
  1477 00005011 F6C480              <1> 	test	ah,prn_stat_busy	; check if printer is busy
  1478 00005014 750C                <1>         jnz     .not_busy
  1479                              <1> 
  1480 00005016 B8FE90              <1> 	mov	ax,90FEh		; printer busy
  1481 00005019 CD15                <1> 	int	15h			; call OS hook
  1482                              <1> 
  1483 0000501B B780                <1> 	mov	bh,prn_stat_busy
  1484 0000501D E8C5D4              <1> 	call	wait_for_port		; wait for printer to be ready
  1485 00005020 750E                <1> 	jnz	.timeout		; timeout had occured
  1486                              <1> 
  1487                              <1> .not_busy:
  1488 00005022 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  1489                              <1> 					; OPTIMIZATION:
  1490                              <1> 					; prn_ctrl_reg = prn_stat_reg + 1
  1491 00005023 B00D                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init | prn_ctrl_strobe)
  1492 00005025 EE                  <1> 	out	dx,al			; activate strobe
  1493 00005026 E6C0                <1> 	out	unused_reg,al		; I/O delay
  1494 00005028 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  1495 0000502A EE                  <1> 	out	dx,al			; de-activate strobe
  1496 0000502B 80E4F8              <1> 	and	ah,prn_stat_bits	; leave only valid status bits
  1497 0000502E EBD2                <1> 	jmp	int_17_exit
  1498                              <1> 
  1499                              <1> .timeout:
  1500 00005030 80E4F8              <1> 	and	ah,prn_stat_bits
  1501 00005033 80CC01              <1> 	or	ah,prn_stat_tmout	; set timeout bit
  1502 00005036 EBCA                <1> 	jmp	int_17_exit
  1503                              <1> 
  1504                              <1> ;=========================================================================
  1505                              <1> ; int_17_fn02 - Return printer status
  1506                              <1> ; Input:
  1507                              <1> ;	AH = 2 - function 02h - return printer status
  1508                              <1> ;	DX = printer port number (0-2)
  1509                              <1> ; Output:
  1510                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  1511                              <1> ;-------------------------------------------------------------------------
  1512                              <1> int_17_fn02:
  1513 00005038 42                  <1> 	inc	dx			; DX = prn_stat_reg
  1514                              <1> 					; OPTIMIZATION:
  1515                              <1> 					; prn_stat_reg = prn_data_reg + 1
  1516                              <1> int_17_status:
  1517 00005039 EC                  <1> 	in	al,dx			; read the status
  1518 0000503A 88C4                <1> 	mov	ah,al			; move status to AH
  1519 0000503C 80E4F8              <1> 	and	ah,prn_stat_bits	; discard reserved bits
  1520 0000503F EBC1                <1> 	jmp	int_17_exit
  1385                                  %include	"video.inc"		; INT 10
  1386                              <1> ;=========================================================================
  1387                              <1> ; video.inc - BIOS video services
  1388                              <1> ;       INT 10h, functions AH=00h to AH=0Fh
  1389                              <1> ;-------------------------------------------------------------------------
  1390                              <1> ;
  1391                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1392                              <1> ;
  1393                              <1> ; This code is adopted from XT-clone BIOS by Anonymous
  1394                              <1> ;
  1395                              <1> ; This program is free software: you can redistribute it and/or modify
  1396                              <1> ; it under the terms of the GNU General Public License as published by
  1397                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1398                              <1> ; (at your option) any later version.
  1399                              <1> ;
  1400                              <1> ; This program is distributed in the hope that it will be useful,
  1401                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1402                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1403                              <1> ; GNU General Public License for more details.
  1404                              <1> ;
  1405                              <1> ; You should have received a copy of the GNU General Public License
  1406                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1407                              <1> ;
  1408                              <1> ;=========================================================================
  1409                              <1> 
  1410                              <1> ;-------------------------------------------------------------------------
  1411                              <1> ; CRTC registers
  1412                              <1> crtc_cur_start	equ	0Ah		; CRTC cursor start line register
  1413                              <1> crtc_cur_end	equ	0Bh		; CRTC cursor end line register
  1414                              <1> crtc_offset_hi	equ	0Ch		; CRTC start address high register
  1415                              <1> crtc_offset_lo	equ	0Dh		; CRTC start address low register
  1416                              <1> crtc_cur_pos_hi	equ	0Eh		; CRCT cursor location high register
  1417                              <1> crtc_cur_pos_lo	equ	0Fh		; CRTC cursor location low register
  1418                              <1> crtc_pen_hi	equ	10h		; CRTC light pen position high byte
  1419                              <1> crtc_pen_lo	equ	11h		; CRTC light pen position low byte
  1420                              <1> 
  1421                              <1> ;-------------------------------------------------------------------------
  1422                              <1> ; control characters
  1423                              <1> bel	equ	07h
  1424                              <1> bs	equ	08h
  1425                              <1> lf	equ	0Ah
  1426                              <1> cr	equ	0Dh
  1427                              <1> 
  1428 00005041 FF<rep 4h>          <1> 	setloc	0F045h			; int 10 functions table
  1428          ******************  <1>  warning: Inserting 4 bytes [-w+user]
  1429                              <1> 
  1430                              <1> int_10_dispatch:
  1431 00005045 [0451]              <1> 	dw	int_10_fn00		; Set video mode
  1432 00005047 [B951]              <1> 	dw	int_10_fn01		; Set text mode cursor shape
  1433 00005049 [C351]              <1> 	dw	int_10_fn02		; Set cursor position
  1434 0000504B [E651]              <1> 	dw	int_10_fn03		; Get cursor position and shape
  1435 0000504D [FA51]              <1> 	dw	int_10_fn04		; Read light pen position
  1436 0000504F [8D52]              <1> 	dw	int_10_fn05		; Set active display page
  1437 00005051 [B852]              <1> 	dw	int_10_fn06		; Scroll up window
  1438 00005053 [B852]              <1> 	dw	int_10_fn07		; Scroll down window
  1439 00005055 [3E54]              <1> 	dw	int_10_fn08		; Read character and attribute
  1440 00005057 [3E54]              <1> 	dw	int_10_fn09		; Write character and attribute
  1441 00005059 [3E54]              <1> 	dw	int_10_fn0A		; Write character only
  1442 0000505B [1956]              <1> 	dw	int_10_fn0B		; Set background color or palette
  1443 0000505D [4356]              <1> 	dw	int_10_fn0C		; Write graphics pixel
  1444 0000505F [7B56]              <1> 	dw	int_10_fn0D		; Read graphics pixel
  1445 00005061 [9956]              <1> 	dw	int_10_fn0E		; Teletype output
  1446 00005063 [0E57]              <1> 	dw	int_10_fn0F		; Get current video mode
  1447                              <1> int_10_num_func	equ ($-int_10_dispatch)/2
  1448                              <1> 
  1449                              <1> 
  1450                              <1> ;-------------------------------------------------------------------------
  1451                              <1> ; offsets for registers on stack
  1452                              <1> 
  1453                              <1> int_10_ax	equ	0
  1454                              <1> int_10_al	equ	int_10_ax
  1455                              <1> int_10_ah	equ	int_10_ax+1
  1456                              <1> int_10_bx	equ	int_10_ax+2
  1457                              <1> int_10_bl	equ	int_10_bx
  1458                              <1> int_10_bh	equ	int_10_bx+1
  1459                              <1> int_10_cx	equ	int_10_bx+2
  1460                              <1> int_10_ch	equ	int_10_cx+1
  1461                              <1> int_10_dx	equ	int_10_cx+2
  1462                              <1> 
  1463                              <1> ;=========================================================================
  1464                              <1> ; int_10 - BIOS video services
  1465                              <1> ; Input:
  1466                              <1> ;	AH - Function
  1467                              <1> ;		00h - Set video mode
  1468                              <1> ;		01h - Set text mode cursor shape
  1469                              <1> ;		02h - Set cursor position
  1470                              <1> ;		03h - Get cursor position and shape
  1471                              <1> ;		04h - Read light pen position
  1472                              <1> ;		05h - Select active display page
  1473                              <1> ;		06h - Scroll up window
  1474                              <1> ;		07h - Scroll down window
  1475                              <1> ;		08h - Read character and attribute at cursor position
  1476                              <1> ;		09h - Write character and attribute at cursor position
  1477                              <1> ;		0Ah - Write character only at cursor position
  1478                              <1> ;		0Bh -
  1479                              <1> ;			BH = 00h - Set background/border color
  1480                              <1> ;			BH = 01h - Set palette
  1481                              <1> ;		0Ch - Write graphics pixel
  1482                              <1> ;		0Dh - Read graphics pixel
  1483                              <1> ;		0Eh - Teletype output
  1484                              <1> ;		0Fh - Get current video mode
  1485                              <1> ;-------------------------------------------------------------------------
  1486                              <1> 	setloc	0F065h			; int 10 Entry Point
  1487                              <1> int_10:
  1488 00005065 FB                  <1> 	sti
  1489 00005066 FC                  <1> 	cld				;  ...strings auto-increment
  1490 00005067 55                  <1> 	push	bp
  1491 00005068 06                  <1> 	push	es
  1492 00005069 1E                  <1> 	push	ds
  1493 0000506A 56                  <1> 	push	si
  1494 0000506B 57                  <1> 	push	di
  1495 0000506C 52                  <1> 	push	dx
  1496 0000506D 51                  <1> 	push	cx
  1497 0000506E 53                  <1> 	push	bx
  1498 0000506F 50                  <1> 	push	ax
  1499 00005070 BB4000              <1> 	mov	bx,biosdseg
  1500 00005073 8EDB                <1> 	mov	ds,bx
  1501 00005075 8A1E4900            <1> 	mov	bl,byte [video_mode]
  1502 00005079 80FB07              <1> 	cmp	bl,07h			; check for monochrome mode
  1503 0000507C BB00B8              <1> 	mov	bx,0B800h		; assume CGA, BX = CGA video segment
  1504 0000507F 7202                <1> 	jb	.color			; it is CGA
  1505 00005081 B7B0                <1> 	mov	bh,0B0h			; else MDA, BX = MDA video segment
  1506                              <1> 
  1507                              <1> .color:
  1508 00005083 8EC3                <1> 	mov	es,bx			; load video segment to ES
  1509 00005085 89E5                <1> 	mov	bp,sp			;  ...start of stack frame
  1510 00005087 80FC10              <1> 	cmp	ah,int_10_num_func	; dispatch table size
  1511 0000508A 730B                <1> 	jae	.exit			; invalid function
  1512 0000508C B700                <1> 	mov	bh,0
  1513 0000508E 88E3                <1> 	mov	bl,ah
  1514 00005090 D1E3                <1> 	shl	bx,1
  1515 00005092 2EFF97[4550]        <1>     cs	call	near [int_10_dispatch+bx]
  1516                              <1> 
  1517                              <1> .exit:
  1518 00005097 58                  <1> 	pop	ax
  1519 00005098 5B                  <1> 	pop	bx
  1520 00005099 59                  <1> 	pop	cx
  1521 0000509A 5A                  <1> 	pop	dx
  1522 0000509B 5F                  <1> 	pop	di
  1523 0000509C 5E                  <1> 	pop	si
  1524 0000509D 1F                  <1> 	pop	ds
  1525 0000509E 07                  <1> 	pop	es
  1526 0000509F 5D                  <1> 	pop	bp
  1527 000050A0 CF                  <1> 	iret
  1528                              <1> 
  1529                              <1> 
  1530                              <1> ;=========================================================================
  1531                              <1> ; int_1D - Video parameters tables
  1532                              <1> ; Contains values loaded to MC6845 CRTC registers 00h to 0Fh during
  1533                              <1> ; video mode initialization
  1534                              <1> ;-------------------------------------------------------------------------
  1535 000050A1 FF<rep 3h>          <1> 	setloc	0F0A4h			; int 1D (MDA and CGA Video Parm Table)
  1535          ******************  <1>  warning: Inserting 3 bytes [-w+user]
  1536                              <1> int_1D:
  1537                              <1> 	; CGA test 40x25 modes
  1538 000050A4 38282D0A1F06191C    <1> 	db	38h, 28h, 2Dh, 0Ah, 1Fh, 06h, 19h, 1Ch
  1539 000050AC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  1540                              <1> 
  1541                              <1> 	; CGA text 80x25 modes
  1542 000050B4 71505A0A1F06191C    <1> 	db	71h, 50h, 5Ah, 0Ah, 1Fh, 06h, 19h, 1Ch
  1543 000050BC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  1544                              <1> 
  1545                              <1> 	; CGA graphics modes
  1546 000050C4 38282D0A7F066470    <1> 	db	38h, 28h, 2Dh, 0Ah, 7Fh, 06h, 64h, 70h
  1547 000050CC 0201060700000000    <1> 	db	02h, 01h, 06h, 07h, 00h, 00h, 00h, 00h
  1548                              <1> 
  1549                              <1> 	; MDA text 80x25 mode
  1550 000050D4 6150520F19061919    <1> 	db	61h, 50h, 52h, 0Fh, 19h, 06h, 19h, 19h
  1551 000050DC 020D0B0C00000000    <1> 	db	02h, 0Dh, 0Bh, 0Ch, 00h, 00h, 00h, 00h
  1552                              <1> 
  1553                              <1> page_size:
  1554 000050E4 0008                <1> 	dw	0800h			; text 40x25 mode
  1555 000050E6 0010                <1> 	dw	1000h			; text 80x25 mode
  1556 000050E8 0040                <1> 	dw	4000h			; graphics modes
  1557 000050EA 0040                <1> 	dw	4000h
  1558                              <1> 
  1559                              <1> columns:
  1560 000050EC 2828                <1> 	db	40, 40			; modes 0, 1 - 40x25
  1561 000050EE 5050                <1> 	db	80, 80			; modes 2, 3 - 80x25
  1562 000050F0 2828                <1> 	db	40, 40			; modes 4, 5 - 40x25
  1563 000050F2 5050                <1> 	db	80, 80			; modes 6, 7 - 80x25
  1564                              <1> 
  1565 000050F4 2C282D292A2E1E29    <1> MODES	db	2Ch,28h,2Dh,29h,2Ah,2Eh,1Eh,29h ; Table of mode sets
  1566                              <1> 
  1567 000050FC 0000101020202030    <1> TABMUL	db	00h,00h,10h,10h,20h,20h,20h,30h ; Table lookup for multiply
  1568                              <1> 
  1569                              <1> ;=========================================================================
  1570                              <1> ; int_10_fn00 - Set video mode
  1571                              <1> ; Input:
  1572                              <1> ;	AH = 00h
  1573                              <1> ;	AL = video mode
  1574                              <1> ;		00h - CGA - text 40x25, 16 shades of gray
  1575                              <1> ;		01h - CGA - text 40x25, 16 colors
  1576                              <1> ;		02h - CGA - text 80x25, 16 shades of gray
  1577                              <1> ;		03h - CGA - text 80x25, 16 colors
  1578                              <1> ;		04h - CGA - graphics 320x200, 4 colors
  1579                              <1> ;		05h - CGA - graphics 320x200, 4 shades of gray
  1580                              <1> ;		06h - CGA - graphics 640x200, monochrome
  1581                              <1> ;		07h - MDA - text 80x25, monochrome
  1582                              <1> ;-------------------------------------------------------------------------
  1583                              <1> int_10_fn00:
  1584 00005104 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = video mode
  1585                              <1> 					; assume CGA mode
  1586 00005107 B900B8              <1> 	mov	cx,0B800h		; CGA video memory segment
  1587 0000510A BAD403              <1> 	mov	dx,3D4h			; port for MC6845 CRTC address register
  1588 0000510D A01000              <1> 	mov	al,byte [equipment_list] ; get equipment - low byte
  1589 00005110 2430                <1> 	and	al,equip_video		; get video adapter type
  1590 00005112 3C30                <1> 	cmp	al,equip_mono		; monochrome?
  1591 00005114 B000                <1> 	mov	al,0
  1592 00005116 7507                <1> 	jne	.color			; jump if CGA/color mode
  1593                              <1> 					; set MDA mode
  1594 00005118 B307                <1> 	mov	bl,07h			; MDA can only be 7
  1595 0000511A B5B0                <1> 	mov	ch,0B0h			; MDA video memory segment
  1596 0000511C B2B4                <1> 	mov	dl,0B4h 		; port for MC6845 CRTC address register
  1597 0000511E 40                  <1> 	inc	ax
  1598                              <1> 
  1599                              <1> .color:
  1600 0000511F 8EC1                <1> 	mov	es,cx			; ES = video memory segment
  1601 00005121 89166300            <1> 	mov	word [video_port],dx	; Save current CRTC display port
  1602 00005125 80C204              <1> 	add	dl,4
  1603 00005128 EE                  <1> 	out	dx,al			; Reset the video
  1604 00005129 881E4900            <1> 	mov	byte [video_mode],bl	; Save current CRTC mode
  1605 0000512D B700                <1> 	mov	bh,0
  1606 0000512F 53                  <1> 	push	bx
  1607 00005130 06                  <1> 	push	es
  1608 00005131 31C0                <1> 	xor	ax,ax
  1609 00005133 8EC0                <1> 	mov	es,ax			; Load interrupt table segment to ES
  1610 00005135 26C4367400          <1>     es	les	si,[1Dh*4]		; Load video parameters table
  1611                              <1> 					; (INT 1Dh vector) to ES:SI
  1612 0000513A 2E8A9F[FC50]        <1>     cs	mov	bl,byte [bx+TABMUL]	; Get BL for indexing into int_1D
  1613 0000513F 01DE                <1> 	add	si,bx
  1614                              <1> 
  1615 00005141 268B4C0A            <1>     es	mov	cx,word [si+crtc_cur_start] ; cursor shape from INT 1Dh table
  1616 00005145 86CD                <1> 	xchg	cl,ch			; convert to LSB format
  1617 00005147 890E6000            <1> 	mov	word [video_cur_shape],cx ; store cursor shape
  1618                              <1> 
  1619 0000514B B91000              <1> 	mov	cx,10h			; Sixteen values to send
  1620                              <1> 
  1621                              <1> .setup_crt_loop:
  1622 0000514E 268A04              <1>     es	mov	al,byte [si]		; Value to send in SI
  1623 00005151 E8E805              <1> 	call	vid_crtc_writeb			;  ...send it
  1624 00005154 FEC4                <1> 	inc	ah			;  ...bump count
  1625 00005156 46                  <1> 	inc	si			;  ...point to next
  1626 00005157 E2F5                <1> 	loop	.setup_crt_loop		;  ...loop until done
  1627 00005159 07                  <1> 	pop	es
  1628 0000515A 31FF                <1> 	xor	di,di
  1629 0000515C B90020              <1> 	mov	cx,2000h		; video memory size for CGA
  1630 0000515F 31C0                <1> 	xor	ax,ax			; fill word for graphics mode
  1631 00005161 E8BD05              <1> 	call	vid_check_mode		; Set flags according to mode
  1632 00005164 7208                <1> 	jc	.clear_screen		; jump if graphics mode
  1633 00005166 7503                <1> 	jnz	.text_fill		; jump if CGA mode
  1634 00005168 B90008              <1> 	mov	cx,0800h 		; video memory size for MDA
  1635                              <1> 
  1636                              <1> .text_fill:
  1637 0000516B B82007              <1> 	mov	ax,07h << 8 | ' '	; fill word for test mode
  1638                              <1> 
  1639                              <1> .clear_screen:
  1640 0000516E F3AB                <1> 	repz	stosw			; clear screen with fill word
  1641                              <1> 
  1642 00005170 8B166300            <1> 	mov	dx,word [video_port]	; Get the port
  1643 00005174 80C204              <1> 	add	dl,4
  1644 00005177 5B                  <1> 	pop	bx
  1645 00005178 2E8A87[F450]        <1>     cs	mov	al,byte [bx+MODES]	; Load data to set for mode
  1646 0000517D EE                  <1> 	out	dx,al			;  ...and send it
  1647 0000517E A26500              <1> 	mov	byte [video_mode_reg],al ;  ...then save active data
  1648 00005181 42                  <1> 	inc	dx
  1649 00005182 B030                <1> 	mov	al,30h			; Assume not 640 x 200 b/w
  1650 00005184 80FB06              <1> 	cmp	bl,6			;  ...correct?
  1651 00005187 7502                <1> 	jnz	.set_palette
  1652 00005189 B03F                <1> 	mov	al,3Fh			; Palette for 640 x 200 b/w
  1653                              <1> 
  1654                              <1> .set_palette:
  1655 0000518B A26600              <1> 	mov	byte [video_palet_reg],al ;  ...save palette
  1656 0000518E EE                  <1> 	out	dx,al			;  ...send palette
  1657                              <1> 
  1658 0000518F 8CD8                <1> 	mov	ax,ds
  1659 00005191 8EC0                <1> 	mov	es,ax
  1660 00005193 31C0                <1> 	xor	ax,ax
  1661 00005195 A26200              <1> 	mov	byte [video_page],al	;  ...active page=page 0
  1662 00005198 B90900              <1> 	mov	cx,9			; video_page_offt + video_cur_pos * 8
  1663 0000519B BF4E00              <1> 	mov	di,video_page_offt
  1664 0000519E F3AB                <1>  	rep	stosw			; zero page offset and cursor position
  1665                              <1> 
  1666 000051A0 2E8A87[EC50]        <1>     cs	mov	al,byte [bx+columns]	; Get display width
  1667 000051A5 A34A00              <1> 	mov	word [video_columns],ax	;  ...save it
  1668 000051A8 B018                <1> 	mov	al,24			; All supported modes have 25 rows
  1669 000051AA A28400              <1> 	mov	byte [video_rows],al	;  ... the value saved uses one less
  1670 000051AD 80E3FE              <1> 	and	bl,0FEh			; Clear the LSB to get an index
  1671                              <1> 					; to 16-bit word page_size table
  1672                              <1> 					; FIXME: It returns graphics mode page
  1673                              <1> 					; size for mode 7. Probably not
  1674                              <1> 					; critical, as MDA has only one page
  1675 000051B0 2E8B87[E450]        <1>     cs	mov	ax,word [bx+page_size]	; Get video page size
  1676 000051B5 A34C00              <1> 	mov	word [video_page_size],ax ;  ...save it
  1677 000051B8 C3                  <1> 	ret
  1678                              <1> 
  1679                              <1> ;=========================================================================
  1680                              <1> ; int_10_fn01 - Set text-mode cursor shape
  1681                              <1> ; Input:
  1682                              <1> ;	AH = 01h
  1683                              <1> ;	CH = cursor scan line start
  1684                              <1> ;	CL = cursor scan line end
  1685                              <1> ; Output:
  1686                              <1> ;	none
  1687                              <1> ;-------------------------------------------------------------------------
  1688                              <1> int_10_fn01:
  1689 000051B9 890E6000            <1> 	mov	word [video_cur_shape],cx ; save cursor shape to BIOS data area
  1690 000051BD B40A                <1> 	mov	ah,crtc_cur_start	; select CRTC cursor shape registers
  1691 000051BF E87105              <1> 	call	vid_crtc_writew		; write it to CRTC
  1692 000051C2 C3                  <1> 	ret
  1693                              <1> 
  1694                              <1> ;=========================================================================
  1695                              <1> ; int_10_fn02 - Set cursor position
  1696                              <1> ; Input:
  1697                              <1> ;	AH = 02h
  1698                              <1> ;	BH = page number
  1699                              <1> ;	DH = cursor row (00h is top)
  1700                              <1> ;	DL = cursor column (00h is left)
  1701                              <1> ; Output:
  1702                              <1> ;	none
  1703                              <1> ;-------------------------------------------------------------------------
  1704                              <1> int_10_fn02:
  1705 000051C3 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  1706 000051C6 381E6200            <1> 	cmp	byte [video_page],bl	; is it on current page?
  1707 000051CA 7512                <1> 	jne	bios_set_cur_pos	; if not visible only update BIOS data
  1708                              <1> 
  1709                              <1> ;=========================================================================
  1710                              <1> ; set_cur_pos - set CRTC cursor position, update BIOS cursor location
  1711                              <1> ;	BL = page
  1712                              <1> ;	DH = cursor row (00h is top)
  1713                              <1> ;	DL = cursor column (00h is left)
  1714                              <1> ;-------------------------------------------------------------------------
  1715                              <1> set_cur_pos:
  1716 000051CC 89D0                <1> 	mov	ax,dx			; AX = cursor position
  1717 000051CE E8AA05              <1> 	call	vid_position_to_offset			; AX - offset
  1718 000051D1 03064E00            <1> 	add	ax,word [video_page_offt]	;  + byte offset, regen reg.
  1719 000051D5 D1E8                <1> 	shr	ax,1
  1720 000051D7 89C1                <1> 	mov	cx,ax
  1721 000051D9 B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  1722 000051DB E85505              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  1723                              <1> bios_set_cur_pos:
  1724 000051DE B700                <1> 	mov	bh,0
  1725 000051E0 D0E3                <1> 	shl	bl,1			; index to words table
  1726 000051E2 895750              <1> 	mov	word [bx+video_cur_pos],dx ; save position to BIOS data area
  1727 000051E5 C3                  <1> 	ret
  1728                              <1> 
  1729                              <1> ;=========================================================================
  1730                              <1> ; int_10_fn03 - Get cursor position and shape
  1731                              <1> ; Input:
  1732                              <1> ;	AH = 03h
  1733                              <1> ;	BH = page number
  1734                              <1> ; Output:
  1735                              <1> ;	CH = cursor start scan line
  1736                              <1> ;	CL = cursor end scan line
  1737                              <1> ;	DH = cursor row (00h is top)
  1738                              <1> ;	DL = cursor column (00h is left)
  1739                              <1> ;-------------------------------------------------------------------------
  1740                              <1> int_10_fn03:
  1741 000051E6 B700                <1> 	mov	bh,0
  1742 000051E8 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  1743 000051EB D0E3                <1> 	shl	bl,1
  1744 000051ED 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; get current cursor position
  1745 000051F0 894606              <1> 	mov	word [bp+int_10_dx],ax	; return position in DX
  1746 000051F3 A16000              <1> 	mov	ax,word [video_cur_shape]  ; get cursor shape
  1747 000051F6 894604              <1> 	mov	word [bp+int_10_cx],ax	; return cursor shape in CX
  1748 000051F9 C3                  <1> 	ret
  1749                              <1> 
  1750                              <1> ;=========================================================================
  1751                              <1> ; int_10_fn04 - Read light pen position
  1752                              <1> ; Input:
  1753                              <1> ;	AH = 04h
  1754                              <1> ; Output:
  1755                              <1> ;	AH - light pen trigger flag
  1756                              <1> ;		00h not down/triggered
  1757                              <1> ;		01h down/triggered
  1758                              <1> ;	If light pen is triggered:
  1759                              <1> ;		DH = character row
  1760                              <1> ;		DL = character column
  1761                              <1> ;		CH = pixel row
  1762                              <1> ;		BX = pixel column
  1763                              <1> ;-------------------------------------------------------------------------
  1764                              <1> int_10_fn04:
  1765 000051FA C6460100            <1> 	mov	byte [bp+int_10_ah],0	; set AH = 0, light pen not triggered
  1766 000051FE 8B166300            <1> 	mov	dx,word [video_port]
  1767 00005202 80C206              <1> 	add	dl,6			; CRTC status register
  1768 00005205 EC                  <1> 	in	al,dx			; read it
  1769 00005206 A804                <1> 	test	al,4			; test light pen switch bit
  1770 00005208 7472                <1> 	jz	.reset_pen		; reset pen and return if switch is off
  1771 0000520A A802                <1> 	test	al,2			; test light pen tigger bit
  1772 0000520C 7501                <1> 	jnz	.read_pen		; continue if triggered
  1773 0000520E C3                  <1> 	ret				; not triggered - return
  1774                              <1> 
  1775                              <1> .read_pen:
  1776 0000520F 8B166300            <1> 	mov	dx,word [video_port]	; CRTC index register
  1777 00005213 B010                <1> 	mov	al,crtc_pen_hi		; CRTC pen position high byte register
  1778 00005215 EE                  <1> 	out	dx,al			; select it
  1779 00005216 42                  <1> 	inc	dx			; CRTC data register
  1780 00005217 EC                  <1> 	in	al,dx			; read high byte of pen position
  1781 00005218 88C4                <1> 	mov	ah,al
  1782 0000521A 4A                  <1> 	dec	dx			; CRTC index register
  1783 0000521B B011                <1> 	mov	al,crtc_pen_lo		; CRTC pen position low byte register
  1784 0000521D EE                  <1> 	out	dx,al			; select it
  1785 0000521E 42                  <1> 	inc	dx			; CRTC data register
  1786 0000521F EC                  <1> 	in	al,dx			; read low byte of pen position
  1787                              <1> 
  1788 00005220 B700                <1> 	mov	bh,0
  1789 00005222 8A1E4900            <1> 	mov	bl,byte [video_mode]	; get current video mode
  1790 00005226 2E8A9F[8552]        <1>     cs	mov	bl,byte [bx+.correction] ; light pen correction factor
  1791 0000522B 29D8                <1> 	sub	ax,bx
  1792 0000522D 7902                <1> 	jns	.1
  1793 0000522F 31C0                <1> 	xor	ax,ax			; set to zero if negative result
  1794                              <1> 
  1795                              <1> .1:
  1796 00005231 E8ED04              <1> 	call	vid_check_mode			; check video mode
  1797 00005234 7325                <1> 	jnc	.text			; calculate character position if text
  1798 00005236 B228                <1> 	mov	dl,40			; divide by 40
  1799 00005238 F6F2                <1> 	div	dl			; AL = row, AH = column (reminder)
  1800 0000523A B700                <1> 	mov	bh,0
  1801 0000523C 88E3                <1> 	mov	bl,ah
  1802 0000523E B103                <1> 	mov	cl,3
  1803 00005240 D3E3                <1> 	shl	bx,cl			; BX = AH * 8 - pixel column
  1804 00005242 88C5                <1> 	mov	ch,al
  1805 00005244 D0E5                <1> 	shl	ch,1			; CH = AL * 2 - pixel row
  1806 00005246 88E2                <1> 	mov	dl,ah			; DL = AH - character column
  1807 00005248 88C6                <1> 	mov	dh,al
  1808 0000524A D0EE                <1> 	shr	dh,1
  1809 0000524C D0EE                <1> 	shr	dh,1			; DH = AL / 4 - character row
  1810 0000524E 803E490006          <1> 	cmp	byte [video_mode],6	; check for 640x200 mode
  1811 00005253 751A                <1> 	jnz	.exit
  1812 00005255 D1E3                <1> 	shl	bx,1			; adjust pixel column (double it)
  1813 00005257 D0E2                <1> 	shl	dl,1			; same or character column
  1814 00005259 EB14                <1> 	jmp	.exit
  1815                              <1> 
  1816                              <1> .text:
  1817 0000525B F6364A00            <1> 	div	byte [video_columns] 	; divide by number of columns
  1818 0000525F 86C4                <1> 	xchg	al,ah			; AL = column, AH = row
  1819 00005261 89C2                <1> 	mov	dx,ax			; save characer row,column to DH,AL
  1820 00005263 B103                <1> 	mov	cl,3
  1821 00005265 D2E4                <1> 	shl	ah,cl
  1822 00005267 88E5                <1> 	mov	ch,ah			; CH = AH * 8 - pixel row
  1823 00005269 B700                <1> 	mov	bh,0
  1824 0000526B 88C3                <1> 	mov	bl,al
  1825 0000526D D3E3                <1> 	shl	bx,cl			; BX = AL * 8 - pixel column
  1826                              <1> 
  1827                              <1> .exit:
  1828 0000526F C6460101            <1> 	mov	byte [bp+int_10_ah],1	; set AH = 1, light pen triggered
  1829 00005273 895606              <1> 	mov	word [bp+int_10_dx],dx	;  ...row, column in user dx
  1830 00005276 895E02              <1> 	mov	word [bp+int_10_bx],bx	;  ...pixel column in user bx
  1831 00005279 886E05              <1> 	mov	byte [bp+int_10_ch],ch	;  ...raster line in user ch
  1832                              <1> 
  1833                              <1> .reset_pen:
  1834 0000527C 8B166300            <1> 	mov	dx,word [video_port]	; Get port of active CRTC card
  1835 00005280 80C207              <1> 	add	dl,7			; clear light pen strobe reg
  1836 00005283 EE                  <1> 	out	dx,al			; reset it
  1837 00005284 C3                  <1> 	ret
  1838                              <1> 
  1839                              <1> .correction:
  1840 00005285 0303050503030304    <1> 	db	3, 3, 5, 5, 3, 3, 3, 4	; light pen correction
  1841                              <1> 
  1842                              <1> ;=========================================================================
  1843                              <1> ; int_10_fn05 - Select active display page
  1844                              <1> ; Input:
  1845                              <1> ;	AH = 05h
  1846                              <1> ;	AL - new page number (00h is the first page)
  1847                              <1> ; Output:
  1848                              <1> ;	none
  1849                              <1> ;-------------------------------------------------------------------------
  1850                              <1> int_10_fn05:
  1851 0000528D A26200              <1> 	mov	byte [video_page],al	; update page number in BIOS data area
  1852 00005290 88C3                <1> 	mov	bl,al			; also copy it to BL
  1853 00005292 B400                <1> 	mov	ah,0
  1854 00005294 F7264C00            <1> 	mul	word [video_page_size]	; calculate page offset
  1855 00005298 A34E00              <1> 	mov	word [video_page_offt],ax ; save the offset
  1856 0000529B D1E8                <1> 	shr	ax,1			; calculate CRTC page start address
  1857 0000529D 89C1                <1> 	mov	cx,ax			; save a copy to CX
  1858 0000529F B40C                <1> 	mov	ah,crtc_offset_hi	; CRTC start address high register
  1859 000052A1 E88F04              <1> 	call	vid_crtc_writew		; write new offset to CRTC
  1860                              <1> 
  1861 000052A4 B700                <1> 	mov	bh,0
  1862 000052A6 D1E3                <1> 	shl	bx,1
  1863 000052A8 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; AX - cursor position for new page
  1864 000052AB E8CD04              <1> 	call	vid_position_to_offset			; AX - offset relative to start of page
  1865 000052AE D1E8                <1> 	shr	ax,1
  1866 000052B0 01C1                <1> 	add	cx,ax			; add to the page offset
  1867 000052B2 B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  1868 000052B4 E87C04              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  1869 000052B7 C3                  <1> 	ret
  1870                              <1> 
  1871                              <1> ;=========================================================================
  1872                              <1> ; int_10_fn06 - scroll up window
  1873                              <1> ; int_10_fn07 - scroll down window
  1874                              <1> ; Input:
  1875                              <1> ;	AH = 06h (scroll up) or AH = 07 (scroll down)
  1876                              <1> ;	AL = number of rows by which to scroll up (00h = clear entire window)
  1877                              <1> ;	BH = attribute used to write blank rows at bottom of window
  1878                              <1> ;	CH,CL = row,column of window's upper left corner
  1879                              <1> ;	DH,DL = row,column of window's lower right corner
  1880                              <1> ; Output:
  1881                              <1> ;	none
  1882                              <1> ; TODO:
  1883                              <1> ;	optimize graphics fill
  1884                              <1> ;-------------------------------------------------------------------------
  1885                              <1> int_10_fn06:
  1886                              <1> int_10_fn07:
  1887 000052B8 E86604              <1> 	call	vid_check_mode
  1888 000052BB 7303E9D900          <1> 	jc	.graphics_scroll
  1889                              <1> 
  1890 000052C0 31F6                <1> 	xor	si,si			; SI - "snow" workaround not required
  1891 000052C2 803E490002          <1> 	cmp	byte [video_mode],2
  1892 000052C7 720A                <1> 	jb	.no_snow
  1893 000052C9 803E490003          <1> 	cmp	byte [video_mode],3
  1894 000052CE 7703                <1> 	ja	.no_snow
  1895 000052D0 BE5555              <1> 	mov	si,0101010101010101b	; CGA "snow" workaround required
  1896                              <1> ;	mov	si,0001000100010001b	; CGA "snow" workaround required
  1897                              <1> .no_snow:
  1898 000052D3 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  1899 000052D6 50                  <1> 	push	ax
  1900 000052D7 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h	; check for scroll down function
  1901 000052DB 7403                <1> 	jz	.1			; jump if scroll down
  1902 000052DD 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  1903                              <1> 
  1904                              <1> .1:
  1905 000052E0 E89804              <1> 	call	vid_position_to_offset
  1906 000052E3 03064E00            <1> 	add	ax,word [video_page_offt]
  1907 000052E7 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  1908                              <1> 
  1909                              <1> ; calculate scroll window size (DX)
  1910                              <1> 
  1911 000052E9 5A                  <1> 	pop	dx			; DX = window's lower right corner
  1912 000052EA 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract windows's upper left corner
  1913 000052ED 81C20101            <1> 	add	dx,101h 		; add 1x1
  1914                              <1> 
  1915                              <1> ; calculate offset between the source and the destination (AX)
  1916                              <1> 
  1917 000052F1 8B1E4A00            <1> 	mov	bx,word [video_columns]	; BX = columns (note BX <= 80)
  1918 000052F5 D1E3                <1> 	shl	bx,1			; each character takes two bytes
  1919 000052F7 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = number of rows to scroll
  1920 000052FA 52                  <1> 	push    dx
  1921 000052FB B400                <1>         mov     ah,0
  1922 000052FD F7E3                <1>         mul     bx
  1923 000052FF 5A                  <1>         pop     dx
  1924                              <1> 
  1925 00005300 28D3                <1> 	sub	bl,dl			; BX = distance between end of one
  1926 00005302 28D3                <1> 	sub	bl,dl			;   row and beggining of another
  1927 00005304 1E                  <1> 	push	ds
  1928 00005305 8CC1                <1> 	mov	cx,es
  1929 00005307 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  1930 00005309 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  1931 0000530D 7405                <1> 	jz	.2			; jump if scroll up
  1932 0000530F F7D8                <1> 	neg	ax			; negate offset
  1933 00005311 F7DB                <1> 	neg	bx			; negate distance
  1934 00005313 FD                  <1> 	std				; copy backwards
  1935                              <1> 
  1936                              <1> .2:
  1937 00005314 8A4E00              <1> 	mov	cl,byte [bp+int_10_al]	; CL = number of rows to scroll
  1938 00005317 08C9                <1> 	or	cl,cl
  1939 00005319 7423                <1> 	jz	.text_fill_only		; jump if clear window only requested
  1940 0000531B 96                  <1> 	xchg	ax,si			; AX = snow workaround flag, SI = offset
  1941 0000531C 01FE                <1> 	add	si,di			; SI = scroll copy source address
  1942 0000531E 28CE                <1> 	sub	dh,cl			; DH = number of rows to copy
  1943                              <1> 
  1944 00005320 09DB                <1> 	or	bx,bx
  1945 00005322 7434                <1> 	jz	.text_full_row_scroll
  1946                              <1> 
  1947                              <1> .text_scroll_loop:
  1948 00005324 B500                <1> 	mov	ch,0
  1949 00005326 88D1                <1> 	mov	cl,dl			; CX = characters in row to copy
  1950                              <1> 
  1951 00005328 D1C8                <1> 	ror	ax,1			; rotate snow workaround flag
  1952 0000532A 7303                <1> 	jnc	.text_scroll_no_retrace
  1953 0000532C E85800              <1> 	call	.retrace_wait
  1954                              <1> 
  1955                              <1> .text_scroll_no_retrace:
  1956 0000532F F3A5                <1> 	repz	movsw			; copy one row
  1957                              <1> 
  1958                              <1> ;.text_scroll_next_row:
  1959 00005331 01DE                <1> 	add	si,bx			; SI = next row to copy source address
  1960 00005333 01DF                <1> 	add	di,bx			; DI = next row to copy destination
  1961 00005335 FECE                <1> 	dec	dh			; decrement row counter
  1962 00005337 75EB                <1> 	jnz	.text_scroll_loop	; jump if there is more rows to copy
  1963                              <1> 
  1964                              <1> .text_fill:
  1965 00005339 8A7600              <1> 	mov	dh,byte [bp+int_10_al]	; DH = number of rows to fill
  1966 0000533C 89C6                <1> 	mov	si,ax			; SI = snow workaround flag
  1967                              <1> 
  1968                              <1> .text_fill_only:
  1969 0000533E B500                <1> 	mov	ch,0
  1970 00005340 8A6603              <1> 	mov	ah,byte [bp+int_10_bh]	; AH = blank attribute
  1971 00005343 B020                <1> 	mov	al,' '			; AL = blank character
  1972                              <1> 
  1973                              <1> .text_fill_loop:
  1974 00005345 88D1                <1> 	mov	cl,dl			; CX = characters in row to fill
  1975 00005347 D1CE                <1> 	ror	si,1			; rotate snow workaround flag
  1976 00005349 7303                <1> 	jnc	.text_fill_no_retrace	; jump if LSB was zero - no wait
  1977 0000534B E83900              <1> 	call	.retrace_wait		; wait for vertical retrace
  1978                              <1> 
  1979                              <1> .text_fill_no_retrace:
  1980 0000534E F3AB                <1> 	repz	stosw			; fill one row
  1981 00005350 01DF                <1> 	add	di,bx			; DI = next row to fill destination
  1982 00005352 FECE                <1> 	dec	dh			; decrement row counter
  1983 00005354 75EF                <1> 	jnz	.text_fill_loop		; jump if there is more rows to fill
  1984                              <1> 
  1985 00005356 1F                  <1> 	pop	ds
  1986 00005357 C3                  <1> 	ret
  1987                              <1> 
  1988                              <1> .text_full_row_scroll:
  1989 00005358 09C0                <1> 	or	ax,ax
  1990 0000535A 741F                <1> 	jz	.text_full_row_no_snow
  1991 0000535C 50                  <1> 	push	ax
  1992 0000535D 88D0                <1> 	mov	al,dl
  1993 0000535F F6E6                <1> 	mul	dh
  1994                              <1> 
  1995                              <1> .text_full_row_loop:
  1996 00005361 B9F000              <1> 	mov	cx,240
  1997 00005364 39C8                <1> 	cmp	ax,cx
  1998 00005366 7705                <1> 	ja	.copy_chunk
  1999 00005368 91                  <1> 	xchg	ax,cx
  2000 00005369 31C0                <1> 	xor	ax,ax
  2001 0000536B EB02                <1> 	jmp	.do_copy
  2002                              <1> 
  2003                              <1> .copy_chunk:
  2004 0000536D 29C8                <1> 	sub	ax,cx
  2005                              <1> 
  2006                              <1> .do_copy:
  2007 0000536F E81500              <1> 	call	.retrace_wait
  2008 00005372 F3A5                <1> 	rep	movsw
  2009 00005374 09C0                <1> 	or	ax,ax
  2010 00005376 75E9                <1> 	jnz	.text_full_row_loop
  2011 00005378 58                  <1> 	pop	ax
  2012 00005379 EBBE                <1> 	jmp	.text_fill
  2013                              <1> 
  2014                              <1> .text_full_row_no_snow:
  2015 0000537B 50                  <1> 	push	ax
  2016 0000537C 88D0                <1> 	mov	al,dl
  2017 0000537E F6E6                <1> 	mul	dh
  2018 00005380 89C1                <1> 	mov	cx,ax
  2019 00005382 F3A5                <1> 	rep	movsw
  2020 00005384 58                  <1> 	pop	ax
  2021 00005385 EBB2                <1> 	jmp	.text_fill
  2022                              <1> 
  2023                              <1> ;-------------------------------------------------------------------------
  2024                              <1> ; .retrace_wait - next till the next vertical retrace
  2025                              <1> 
  2026                              <1> .retrace_wait:
  2027 00005387 50                  <1> 	push	ax
  2028 00005388 52                  <1> 	push	dx
  2029 00005389 BADA03              <1> 	mov	dx,03DAh		; DX = CGA status register
  2030                              <1> 
  2031                              <1> .retrace_wait_not_set:
  2032 0000538C EC                  <1> 	in	al,dx
  2033 0000538D A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  2034 0000538F 75FB                <1> 	jnz	.retrace_wait_not_set	; jump if retrace
  2035                              <1> 
  2036                              <1> .retrace_wait_set:
  2037 00005391 EC                  <1> 	in	al,dx
  2038 00005392 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  2039 00005394 74FB                <1> 	jz	.retrace_wait_set	; jump if no retrace
  2040 00005396 5A                  <1> 	pop	dx
  2041 00005397 58                  <1> 	pop	ax
  2042                              <1> 
  2043                              <1> .retrace_exit:
  2044 00005398 C3                  <1> 	ret
  2045                              <1> 
  2046                              <1> ;-------------------------------------------------------------------------
  2047                              <1> ; .graphics_scroll - scroll for graphics modes
  2048                              <1> 
  2049                              <1> .graphics_scroll:
  2050 00005399 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  2051 0000539C 50                  <1> 	push	ax
  2052 0000539D 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h ; check for scroll down function
  2053 000053A1 7403                <1> 	jz	.3			; jump if scroll down
  2054 000053A3 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  2055                              <1> 
  2056                              <1> .3:
  2057 000053A6 E8E303              <1> 	call	vid_gfx_pos_to_offset	
  2058 000053A9 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  2059                              <1> 
  2060                              <1> ; calculate scroll windows size (DX)
  2061                              <1> 
  2062 000053AB 5A                  <1> 	pop	dx			; DX = window's lower right corner
  2063 000053AC 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract window's upper left corner
  2064 000053AF 81C20101            <1> 	add	dx,101h 		; add 1x1
  2065 000053B3 D0E6                <1> 	shl	dh,1			; multiply by four: one character takes
  2066 000053B5 D0E6                <1> 	shl	dh,1			;   four bytes in each plane
  2067 000053B7 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  2068 000053BA 803E490006          <1> 	cmp	byte [video_mode],06h	; check for 640x200 mode
  2069 000053BF 7409                <1> 	jz	.4			; jump if 640x200 mode
  2070 000053C1 D0E2                <1> 	shl	dl,1			; double character width for 320x200 
  2071 000053C3 D1E7                <1> 	shl	di,1			; double character width for 320x200
  2072 000053C5 3C07                <1> 	cmp	al,07h			; check for scroll down function
  2073 000053C7 7509                <1> 	jnz	.5			; jump if scroll down
  2074 000053C9 47                  <1> 	inc	di			; scroll up - adjust source address
  2075                              <1> 
  2076                              <1> .4:
  2077 000053CA 3C07                <1> 	cmp	al,07h			; check for scroll down function
  2078 000053CC 7504                <1> 	jnz	.5			; jump if not scroll down
  2079 000053CE 81C7F000            <1> 	add	di,0F0h			; adjust destination address
  2080                              <1> 					;   for copying backwards
  2081                              <1> 
  2082                              <1> .5:
  2083 000053D2 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = number of rows to scroll
  2084 000053D5 D0E3                <1> 	shl	bl,1			; multiply by four: one character takes
  2085 000053D7 D0E3                <1> 	shl	bl,1			;   four bytes in each plane
  2086 000053D9 53                  <1> 	push	bx
  2087 000053DA 28DE                <1> 	sub	dh,bl			; DH = number of rows to copy
  2088 000053DC B050                <1> 	mov	al,50h
  2089 000053DE F6E3                <1> 	mul	bl
  2090 000053E0 BBB01F              <1> 	mov	bx,1FB0h
  2091 000053E3 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  2092 000053E7 7406                <1> 	jz	.6			; jump if scroll up
  2093 000053E9 F7D8                <1> 	neg	ax			; negate offset for scroll down
  2094 000053EB BB5020              <1> 	mov	bx,2050h
  2095 000053EE FD                  <1> 	std				; copy backwards
  2096                              <1> 
  2097                              <1> .6:
  2098 000053EF 89FE                <1> 	mov	si,di
  2099 000053F1 01C6                <1> 	add	si,ax			; SI = scroll copy source address
  2100 000053F3 58                  <1> 	pop	ax
  2101 000053F4 8CC1                <1> 	mov	cx,es
  2102 000053F6 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  2103 000053F8 08C0                <1> 	or	al,al
  2104 000053FA 7426                <1> 	jz	.graphics_fill		; jump if clear window only requested
  2105 000053FC 50                  <1> 	push	ax
  2106                              <1> 
  2107                              <1> .graphics_scroll_loop:
  2108 000053FD B500                <1> 	mov	ch,0
  2109 000053FF 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  2110 00005401 56                  <1> 	push	si
  2111 00005402 57                  <1> 	push	di
  2112 00005403 F3A4                <1> 	repz	movsb			; copy one row in the first plane
  2113 00005405 5F                  <1> 	pop	di
  2114 00005406 5E                  <1> 	pop	si
  2115 00005407 81C60020            <1> 	add	si,2000h		; point SI and DI to the second plane
  2116 0000540B 81C70020            <1> 	add	di,2000h
  2117 0000540F 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  2118 00005411 56                  <1> 	push	si
  2119 00005412 57                  <1> 	push	di
  2120 00005413 F3A4                <1> 	repz	movsb			; copy one row in the second plane
  2121 00005415 5F                  <1> 	pop	di
  2122 00005416 5E                  <1> 	pop	si
  2123 00005417 29DE                <1> 	sub	si,bx			; SI = next row to copy source address
  2124 00005419 29DF                <1> 	sub	di,bx			; DI = next row to copy destination
  2125 0000541B FECE                <1> 	dec	dh			; decrement row counter
  2126 0000541D 75DE                <1> 	jnz	.graphics_scroll_loop	; jump if there is more rows to copy
  2127                              <1> 
  2128 0000541F 58                  <1> 	pop	ax
  2129 00005420 88C6                <1> 	mov	dh,al			; DH = number of rows to fill
  2130                              <1> 
  2131                              <1> .graphics_fill:
  2132 00005422 8A4603              <1> 	mov	al,byte [bp+int_10_bh]	; AL = fill color
  2133 00005425 B500                <1> 	mov	ch,0
  2134                              <1> 
  2135                              <1> .graphics_fill_loop:
  2136 00005427 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  2137 00005429 57                  <1> 	push	di
  2138 0000542A F3AA                <1> 	repz	stosb			; fill one row in the first plane
  2139 0000542C 5F                  <1> 	pop	di
  2140 0000542D 81C70020            <1> 	add	di,2000h		; point DI to the second plane
  2141 00005431 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  2142 00005433 57                  <1> 	push	di
  2143 00005434 F3AA                <1> 	repz	stosb			; fill one row in the second plane
  2144 00005436 5F                  <1> 	pop	di
  2145 00005437 29DF                <1> 	sub	di,bx
  2146 00005439 FECE                <1> 	dec	dh			; decrement row counter
  2147 0000543B 75EA                <1> 	jnz	.graphics_fill_loop	; jumpif there is more rows to fill
  2148 0000543D C3                  <1> 	ret
  2149                              <1> 
  2150                              <1> ;=========================================================================
  2151                              <1> ; int_10_fn08 - Read character and attribute
  2152                              <1> ; Input:
  2153                              <1> ;	AH = 08h
  2154                              <1> ; Output:
  2155                              <1> ;	AL - character read
  2156                              <1> ;	BH - video attribute (text modes only)
  2157                              <1> ; int_10_fn09 - Write character and attribute
  2158                              <1> ; Input:
  2159                              <1> ;	AH = 09h
  2160                              <1> ;	AL - character to write
  2161                              <1> ;	BH - page number
  2162                              <1> ;	BL - attribute (text modes) or color (graphics modes)
  2163                              <1> ;	CX - number of times to write character
  2164                              <1> ; Output:
  2165                              <1> ;	none
  2166                              <1> ; int_10_fn0A - Write character only
  2167                              <1> ; Input:
  2168                              <1> ;	AH = 0Ah
  2169                              <1> ;	AL - character to write
  2170                              <1> ;	BH - page number
  2171                              <1> ;	CX - repeat count
  2172                              <1> ; Output:
  2173                              <1> ;	none
  2174                              <1> ;-------------------------------------------------------------------------
  2175                              <1> int_10_fn08:
  2176                              <1> int_10_fn09:
  2177                              <1> int_10_fn0A:
  2178 0000543E E8E002              <1> 	call	vid_check_mode
  2179 00005441 7277                <1> 	jc	.graphics		; jump if graphics mode
  2180 00005443 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  2181 00005446 B700                <1> 	mov	bh,0
  2182 00005448 53                  <1> 	push	bx
  2183 00005449 E82803              <1> 	call	vid_current_offset
  2184 0000544C 89C7                <1> 	mov	di,ax			; DI = character offset in the page
  2185 0000544E 58                  <1> 	pop	ax			; AX = page number
  2186 0000544F F7264C00            <1> 	mul	word [video_page_size] 	; AX = page number * page size
  2187 00005453 01C7                <1> 	add	di,ax			; DI = character offset
  2188 00005455 89FE                <1> 	mov	si,di			; SI = character offset
  2189 00005457 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC port
  2190 0000545B 83C206              <1> 	add	dx,6			; DX = CGA status register
  2191 0000545E 1E                  <1> 	push	ds
  2192 0000545F 8CC3                <1> 	mov	bx,es
  2193 00005461 8EDB                <1> 	mov	ds,bx			; load video segment to DS
  2194 00005463 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  2195 00005466 3C08                <1> 	cmp	al,08h			; check for read character function
  2196 00005468 7512                <1> 	jnz	.text_write		; jump if not read char (write char)
  2197                              <1> 
  2198                              <1> .read_retrace_wait:
  2199 0000546A EC                  <1> 	in	al,dx
  2200 0000546B A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2201 0000546D 75FB                <1> 	jnz	.read_retrace_wait	; jump if retrace
  2202 0000546F FA                  <1> 	cli
  2203                              <1> 
  2204                              <1> .read_no_retrace_wait:
  2205 00005470 EC                  <1> 	in	al,dx
  2206 00005471 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2207 00005473 74FB                <1> 	jz	.read_no_retrace_wait	; jump if no retrace
  2208                              <1> 
  2209 00005475 AD                  <1> 	lodsw				; read character and attribute
  2210 00005476 FB                  <1> 	sti
  2211 00005477 1F                  <1> 	pop	ds
  2212 00005478 894600              <1> 	mov	word [bp+int_10_ax],ax	; return character and attribute in AX
  2213 0000547B C3                  <1> 	ret
  2214                              <1> 
  2215                              <1> .text_write:
  2216 0000547C 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = character to write
  2217 0000547F 8A7E02              <1> 	mov	bh,byte [bp+int_10_bl]	; BH = attribute to write
  2218 00005482 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]  ; CX = number of times to write char
  2219 00005485 3C0A                <1> 	cmp	al,0Ah			; check for write char only function
  2220 00005487 7418                <1> 	jz	.text_write_char_only	; jump if write char only
  2221                              <1> 
  2222                              <1> .write_char_retrace:
  2223 00005489 EC                  <1> 	in	al,dx
  2224 0000548A A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  2225 0000548C 750B                <1> 	jnz	.do_write_char_attr	; retrace is in progress - write char
  2226                              <1> 
  2227                              <1> .write_retrace_wait1:
  2228 0000548E EC                  <1> 	in	al,dx
  2229 0000548F A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2230 00005491 75FB                <1> 	jnz	.write_retrace_wait1	; jump if retrace
  2231 00005493 FA                  <1> 	cli
  2232                              <1> 
  2233                              <1> .write_no_retrace_wait1:
  2234 00005494 EC                  <1> 	in	al,dx
  2235 00005495 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2236 00005497 74FB                <1> 	jz	.write_no_retrace_wait1	; jump if no retrace
  2237                              <1> 
  2238                              <1> .do_write_char_attr:
  2239 00005499 89D8                <1> 	mov	ax,bx			; AX = character / attribute
  2240 0000549B AB                  <1> 	stosw				; write it to video memory
  2241 0000549C FB                  <1> 	sti
  2242 0000549D E2EA                <1> 	loop	.write_char_retrace	; repeat CX times
  2243 0000549F 1F                  <1> 	pop	ds
  2244 000054A0 C3                  <1> 	ret
  2245                              <1> 
  2246                              <1> .text_write_char_only:
  2247 000054A1 EC                  <1> 	in	al,dx
  2248 000054A2 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  2249 000054A4 750B                <1> 	jnz	.do_write_char_only	; retrace is in progress - write char
  2250                              <1> 
  2251                              <1> .write_retrace_wait2:
  2252 000054A6 EC                  <1> 	in	al,dx
  2253 000054A7 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2254 000054A9 75FB                <1> 	jnz	.write_retrace_wait2	; jump if retrace
  2255 000054AB FA                  <1> 	cli
  2256                              <1> 
  2257                              <1> .write_no_retrace_wait2:
  2258 000054AC EC                  <1> 	in	al,dx
  2259 000054AD A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2260 000054AF 74FB                <1> 	jz	.write_no_retrace_wait2	; jump if no retrace
  2261                              <1> 
  2262                              <1> .do_write_char_only:
  2263 000054B1 88D8                <1> 	mov	al,bl			; AL = character to write
  2264 000054B3 AA                  <1> 	stosb				; write it to video memory
  2265 000054B4 FB                  <1> 	sti
  2266 000054B5 47                  <1> 	inc	di			; skip attribute
  2267 000054B6 E2E9                <1> 	loop	.text_write_char_only	; repeat CX times
  2268 000054B8 1F                  <1> 	pop	ds
  2269 000054B9 C3                  <1> 	ret
  2270                              <1> 
  2271                              <1> .graphics:
  2272 000054BA 807E0108            <1> 	cmp	byte [bp+int_10_ah],08h	; check for read character function
  2273 000054BE 7503E9B300          <1> 	jz	.graphics_read
  2274                              <1> 
  2275 000054C3 A15000              <1> 	mov	ax,word [video_cur_pos]	; Get cursor position
  2276 000054C6 E8C302              <1> 	call	vid_gfx_pos_to_offset	;  ...convert (row,col) -> col
  2277 000054C9 89C7                <1> 	mov	di,ax			; Save in displacement register
  2278 000054CB 1E                  <1> 	push	ds
  2279 000054CC 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; Get character to write
  2280 000054CF B400                <1> 	mov	ah,0
  2281 000054D1 08C0                <1> 	or	al,al			; Is it user character set?
  2282 000054D3 7807                <1> 	js	.CG9_02			;  ...skip if so
  2283 000054D5 8CCA                <1> 	mov	dx,cs			; Else use ROM character set
  2284 000054D7 BE[6E5A]            <1> 	mov	si,gfx_font		; load graphics font offset
  2285 000054DA EB0C                <1> 	jmp	.CG9_03
  2286                              <1> 
  2287                              <1> .CG9_02:
  2288 000054DC 247F                <1> 	and	al,7Fh			; Origin to zero
  2289 000054DE 31DB                <1> 	xor	bx,bx			;  ...then go load
  2290 000054E0 8EDB                <1> 	mov	ds,bx			;  ...user graphics
  2291 000054E2 C5367C00            <1> 	lds	si,[7Ch]		;  ...vector, offset in si
  2292 000054E6 8CDA                <1> 	mov	dx,ds			;  ...segment into dx
  2293                              <1> 
  2294                              <1> .CG9_03:
  2295 000054E8 1F                  <1> 	pop	ds			; Restore data segment
  2296 000054E9 B103                <1> 	mov	cl,3			;  ...char 8 pixels wide
  2297 000054EB D3E0                <1> 	shl	ax,cl
  2298 000054ED 01C6                <1> 	add	si,ax			; Add regen. buffer base addr.
  2299 000054EF 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]	;  ...load char. count
  2300 000054F2 803E490006          <1> 	cmp	byte [video_mode],6	; Is the mode 640 x 200 b/w?
  2301 000054F7 1E                  <1> 	push	ds
  2302 000054F8 8EDA                <1> 	mov	ds,dx
  2303 000054FA 7451                <1> 	jz	.CG8_02			;  ...skip if so
  2304 000054FC D1E7                <1> 	shl	di,1
  2305 000054FE 8A4602              <1> 	mov	al,byte [bp+int_10_bl]	; Get character attribute
  2306 00005501 83E003              <1> 	and	ax,3
  2307 00005504 BB5555              <1> 	mov	bx,5555h
  2308 00005507 F7E3                <1> 	mul	bx
  2309 00005509 89C2                <1> 	mov	dx,ax
  2310 0000550B 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Restore BL (character attribute)
  2311                              <1> 
  2312                              <1> .CG9_04:
  2313 0000550E B708                <1> 	mov	bh,8			; Char 8 pixels wide
  2314 00005510 57                  <1> 	push	di
  2315 00005511 56                  <1> 	push	si
  2316                              <1> 
  2317                              <1> .CG9_05:
  2318 00005512 AC                  <1> 	lodsb				; Read the screen
  2319 00005513 51                  <1> 	push	cx
  2320 00005514 53                  <1> 	push	bx
  2321 00005515 31DB                <1> 	xor	bx,bx
  2322 00005517 B90800              <1> 	mov	cx,8
  2323                              <1> 
  2324                              <1> .CG9_06:
  2325 0000551A D0E8                <1> 	shr	al,1			; Shift bits thru byte
  2326 0000551C D1DB                <1> 	rcr	bx,1
  2327 0000551E D1FB                <1> 	sar	bx,1
  2328 00005520 E2F8                <1> 	loop	.CG9_06
  2329                              <1> 
  2330 00005522 89D8                <1> 	mov	ax,bx			; Result into ax
  2331 00005524 5B                  <1> 	pop	bx
  2332 00005525 59                  <1> 	pop	cx
  2333 00005526 21D0                <1> 	and	ax,dx
  2334 00005528 86E0                <1> 	xchg	ah,al
  2335 0000552A 08DB                <1> 	or	bl,bl
  2336 0000552C 7903                <1> 	jns	.CG9_07
  2337 0000552E 263305              <1>     es	xor	ax,word [di]
  2338                              <1> 
  2339                              <1> .CG9_07:
  2340 00005531 268905              <1>     es	mov	word [di],ax		; Write new word
  2341 00005534 81F70020            <1> 	xor	di,2000h
  2342 00005538 F7C70020            <1> 	test	di,2000h		; Is this other plane?
  2343 0000553C 7503                <1> 	jnz	.CG9_08			;  ...nope
  2344 0000553E 83C750              <1> 	add	di,50h			; Else advance character
  2345                              <1> 
  2346                              <1> .CG9_08:
  2347 00005541 FECF                <1> 	dec	bh			; Show another char written
  2348 00005543 75CD                <1> 	jnz	.CG9_05			;  ...more to go
  2349 00005545 5E                  <1> 	pop	si
  2350 00005546 5F                  <1> 	pop	di
  2351 00005547 47                  <1> 	inc	di
  2352 00005548 47                  <1> 	inc	di
  2353 00005549 E2C3                <1> 	loop	.CG9_04
  2354 0000554B 1F                  <1> 	pop	ds
  2355 0000554C C3                  <1> 	ret
  2356                              <1> 
  2357                              <1> .CG8_02:
  2358 0000554D 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Get display page
  2359 00005550 BA0020              <1> 	mov	dx,2000h		;  ...size of graphics plane
  2360                              <1> 
  2361                              <1> .CG8_03:
  2362 00005553 B708                <1> 	mov	bh,8			; Pixel count to write
  2363 00005555 57                  <1> 	push	di
  2364 00005556 56                  <1> 	push	si
  2365                              <1> 
  2366                              <1> .CG8_04:
  2367 00005557 AC                  <1> 	lodsb				; Read from one plane
  2368 00005558 08DB                <1> 	or	bl,bl			;  ...done both planes?
  2369 0000555A 7903                <1> 	jns	.CG8_05			;  ...skip if not
  2370 0000555C 263205              <1>     es	xor	al,byte [di]		; Else load attribute
  2371                              <1> 
  2372                              <1> .CG8_05:
  2373 0000555F 268805              <1>     es	mov	byte [di],al		; Write out attribute
  2374 00005562 31D7                <1> 	xor	di,dx			;  ...get other plane
  2375 00005564 85D7                <1> 	test	di,dx			; Done both planes?
  2376 00005566 7503                <1> 	jnz	.CG8_06			;  ...skip if not
  2377 00005568 83C750              <1> 	add	di,50h			; Else position for now char
  2378                              <1> 
  2379                              <1> .CG8_06:
  2380 0000556B FECF                <1> 	dec	bh			; Show row of pixels read
  2381 0000556D 75E8                <1> 	jnz	.CG8_04			;  ...not done all of them
  2382 0000556F 5E                  <1> 	pop	si
  2383 00005570 5F                  <1> 	pop	di
  2384 00005571 47                  <1> 	inc	di
  2385 00005572 E2DF                <1> 	loop	.CG8_03
  2386 00005574 1F                  <1> 	pop	ds
  2387 00005575 C3                  <1> 	ret
  2388                              <1> 
  2389                              <1> .graphics_read:
  2390 00005576 FC                  <1> 	cld				; Increment upwards
  2391 00005577 A15000              <1> 	mov	ax,word [video_cur_pos]	;  ...get cursor position
  2392 0000557A E80F02              <1> 	call	vid_gfx_pos_to_offset	; Convert (row,col) -> columns
  2393 0000557D 89C6                <1> 	mov	si,ax			;  ...save in si
  2394 0000557F 83EC08              <1> 	sub	sp,8			; Grab 8 bytes temp storage
  2395 00005582 89E7                <1> 	mov	di,sp			;  ...save base in di
  2396 00005584 803E490006          <1> 	cmp	byte [video_mode],6	; Mode 640 x 200 b/w?
  2397 00005589 8CC0                <1> 	mov	ax,es
  2398 0000558B 1E                  <1> 	push	ds
  2399 0000558C 57                  <1> 	push	di
  2400 0000558D 8ED8                <1> 	mov	ds,ax			; load video segment to DS
  2401 0000558F 7431                <1> 	jz	CGR_06			; Mode is 640 x 200 b/w - skip
  2402 00005591 B608                <1> 	mov	dh,8			; Eight pixels high/char
  2403 00005593 D1E6                <1> 	shl	si,1
  2404 00005595 BB0020              <1> 	mov	bx,2000h		; Bytes per video plane
  2405                              <1> 
  2406                              <1> CGR_02:
  2407 00005598 8B04                <1> 	mov	ax,word [si] 		; Read existing word
  2408 0000559A 86E0                <1> 	xchg	ah,al
  2409 0000559C B900C0              <1> 	mov	cx,0C000h		; Attributes to scan for
  2410 0000559F B200                <1> 	mov	dl,0
  2411                              <1> 
  2412                              <1> CGR_03:
  2413 000055A1 85C8                <1> 	test	ax,cx			; Look for attributes
  2414 000055A3 F8                  <1> 	clc
  2415 000055A4 7401                <1> 	jz	CGR_04			;  ...set, skip
  2416 000055A6 F9                  <1> 	stc				; Else show not set
  2417                              <1> 
  2418                              <1> CGR_04:
  2419 000055A7 D0D2                <1> 	rcl	dl,1
  2420 000055A9 D1E9                <1> 	shr	cx,1
  2421 000055AB D1E9                <1> 	shr	cx,1
  2422 000055AD 73F2                <1> 	jnb	CGR_03			;  ...more shifts to go
  2423 000055AF 368815              <1>     ss	mov	byte [di],dl
  2424 000055B2 47                  <1> 	inc	di
  2425 000055B3 31DE                <1> 	xor	si,bx			; Do other video plane
  2426 000055B5 85DE                <1> 	test	si,bx			;  ...done both planes?
  2427 000055B7 7503                <1> 	jnz	CGR_05			;  ...no, skip
  2428 000055B9 83C650              <1> 	add	si,50h			; Else advance pointer
  2429                              <1> 
  2430                              <1> CGR_05:
  2431 000055BC FECE                <1> 	dec	dh			; Show another pixel row done
  2432 000055BE 75D8                <1> 	jnz	CGR_02			;  ...more rows to do
  2433 000055C0 EB17                <1> 	jmp	short	CGR_08
  2434                              <1> 
  2435                              <1> CGR_06:
  2436 000055C2 B604                <1> 	mov	dh,4			; Mode 640 x 200 b/w - special
  2437                              <1> 
  2438                              <1> CGR_07:
  2439 000055C4 8A24                <1> 	mov	ah,byte [si] 		; Read pixels from one plane
  2440 000055C6 368825              <1>     ss	mov	byte [di],ah		;  ...save on stack
  2441 000055C9 47                  <1> 	inc	di			;  ...advance
  2442 000055CA 8AA40020            <1> 	mov	ah,byte [si+2000h]	; Read pixels from other plane
  2443 000055CE 368825              <1>     ss	mov	byte [di],ah		; Save pixels on stack
  2444 000055D1 47                  <1> 	inc	di			;  ...advance
  2445 000055D2 83C650              <1> 	add	si,50h			; Total pixels in char
  2446 000055D5 FECE                <1> 	dec	dh			;  ...another row processed
  2447 000055D7 75EB                <1> 	jnz	CGR_07			;  ...more to do
  2448                              <1> 
  2449                              <1> CGR_08:
  2450 000055D9 8CCA                <1> 	mov	dx,cs			; Load segment of graphics font 
  2451 000055DB BF[6E5A]            <1> 	mov	di,gfx_font		;  ...and offset
  2452 000055DE 8EC2                <1> 	mov	es,dx			;  ...save offset in es
  2453 000055E0 8CD2                <1> 	mov	dx,ss
  2454 000055E2 8EDA                <1> 	mov	ds,dx
  2455 000055E4 5E                  <1> 	pop	si
  2456 000055E5 B000                <1> 	mov	al,0
  2457                              <1> 
  2458                              <1> CGR_09:
  2459 000055E7 BA8000              <1> 	mov	dx,80h			; Number of char. in graphics set
  2460                              <1> 
  2461                              <1> CGR_10:
  2462 000055EA 56                  <1> 	push	si
  2463 000055EB 57                  <1> 	push	di
  2464 000055EC B90800              <1> 	mov	cx,8			; Bytes to compare for char
  2465 000055EF F3A6                <1> 	repz	cmpsb			;  ...do compare
  2466 000055F1 5F                  <1> 	pop	di
  2467 000055F2 5E                  <1> 	pop	si
  2468 000055F3 741C                <1> 	jz	CGR_11			; Found graphics character
  2469 000055F5 FEC0                <1> 	inc	al			;  ...else show another char
  2470 000055F7 83C708              <1> 	add	di,8			;  ...advance one row
  2471 000055FA 4A                  <1> 	dec	dx			;  ...one less char  to scan
  2472 000055FB 75ED                <1> 	jnz	CGR_10			; Loop if more char left
  2473                              <1> 
  2474 000055FD 08C0                <1> 	or	al,al			; User graphics character set?
  2475 000055FF 7410                <1> 	jz	CGR_11			;  ...no, not found
  2476 00005601 31DB                <1> 	xor	bx,bx			; 
  2477 00005603 8EDB                <1> 	mov	ds,bx			; Load interrupt table segment to ES
  2478 00005605 C43E7C00            <1> 	les	di,[1Fh*4]		; Load user font for graphics 
  2479                              <1> 					; (INT 1Fh vector) to ES:SI
  2480 00005609 8CC3                <1> 	mov	bx,es
  2481 0000560B 09FB                <1> 	or	bx,di
  2482 0000560D 7402                <1> 	jz	CGR_11			;  ...not found
  2483 0000560F EBD6                <1> 	jmp	short	CGR_09		; Try using user graphics char
  2484                              <1> 
  2485                              <1> CGR_11:
  2486 00005611 884600              <1> 	mov	byte [bp+int_10_al],al	; Return char in user al
  2487 00005614 1F                  <1> 	pop	ds
  2488 00005615 83C408              <1> 	add	sp,8			;  ...return temp storage
  2489 00005618 C3                  <1> 	ret
  2490                              <1> 
  2491                              <1> ;=========================================================================
  2492                              <1> ; int_10_fn0B - Set background color or palette
  2493                              <1> ; Input:
  2494                              <1> ; 	AH - 0Bh
  2495                              <1> ;	BH = 00h - set background / border color
  2496                              <1> ;		BL - background (graphics modes) or border (text modes)
  2497                              <1> ;	BH = 01h - set palette (320x200 graphics mode)
  2498                              <1> ;		BL - palette ID:
  2499                              <1> ;			00h - background, green, red, and yellow (brown)
  2500                              <1> ;			01h - background, cyan, magenta, and white
  2501                              <1> ; Output:
  2502                              <1> ;	none
  2503                              <1> ;-------------------------------------------------------------------------
  2504                              <1> int_10_fn0B:
  2505 00005619 A06600              <1> 	mov	al,byte [video_palet_reg] ; AL = current palette register
  2506 0000561C 8A6602              <1> 	mov	ah,byte [bp+int_10_bl]	; AH = color / palette ID
  2507 0000561F 807E0300            <1> 	cmp	byte [bp+int_10_bh],00h	; check function
  2508 00005623 7509                <1> 	jnz	.set_palette		; jump to set palette if BH != 0
  2509                              <1> 
  2510 00005625 24E0                <1> 	and	al,0E0h			; clear color bits - bits 0-5
  2511 00005627 80E41F              <1> 	and	ah,1Fh			; clear non-color bits in input
  2512 0000562A 08E0                <1> 	or	al,ah			; apply new color
  2513 0000562C EB09                <1> 	jmp	.write_palet_reg
  2514                              <1> 
  2515                              <1> .set_palette:
  2516 0000562E 24DF                <1> 	and	al,0DFh			; clear palette bit - bit 6
  2517 00005630 F6C401              <1> 	test	ah,01h
  2518 00005633 7402                <1> 	jz	.write_palet_reg
  2519 00005635 0C20                <1> 	or	al,20h			; set palette bit for BL = 01h
  2520                              <1> 
  2521                              <1> .write_palet_reg:
  2522 00005637 A26600              <1> 	mov	byte [video_palet_reg],al ; save new palette reg in BIOS data
  2523 0000563A 8B166300            <1> 	mov	dx,word [video_port]
  2524 0000563E 83C205              <1> 	add	dx,5			; CRTC color select register
  2525 00005641 EE                  <1> 	out	dx,al			; send it to CRTC
  2526 00005642 C3                  <1> 	ret
  2527                              <1> 
  2528                              <1> ;=========================================================================
  2529                              <1> ; int_10_fn0C - Write graphics pixel
  2530                              <1> ; Input:
  2531                              <1> ;	AH = 0Ch
  2532                              <1> ;	AL = pixel color, if bit 7 set, pixel is XOR'ed onto screen
  2533                              <1> ;	CX = column
  2534                              <1> ;	DX = row
  2535                              <1> ; Output:
  2536                              <1> ;	none
  2537                              <1> ;-------------------------------------------------------------------------
  2538                              <1> int_10_fn0C:
  2539 00005643 E80501              <1> 	call	vid_pixel_address	; calculate pixel address	
  2540 00005646 750D                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  2541 00005648 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  2542 0000564B 88C3                <1> 	mov	bl,al			; copy color to BL
  2543 0000564D 2401                <1> 	and	al,1			; one bit per pixel
  2544 0000564F D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  2545 00005651 B47F                <1> 	mov	ah,7Fh			; AH = pixel mask
  2546 00005653 EB0F                <1> 	jmp	.prepare_mask
  2547                              <1> 
  2548                              <1> .mode_320x200:
  2549 00005655 D0E1                <1> 	shl	cl,1
  2550 00005657 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  2551 0000565A 88C3                <1> 	mov	bl,al			; copy color to BL
  2552 0000565C 2403                <1> 	and	al,3			; two bit per pixel
  2553 0000565E D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  2554 00005660 D0C8                <1> 	ror	al,1
  2555 00005662 B43F                <1> 	mov	ah,3Fh			; AH = pixel mask
  2556                              <1> 
  2557                              <1> .prepare_mask:
  2558 00005664 D2CC                <1> 	ror	ah,cl			; position pixel mask correctly
  2559 00005666 D2E8                <1> 	shr	al,cl			; position color bits correctly
  2560 00005668 268A0C              <1>     es	mov	cl,byte [si]		; read the byte containing the pixel
  2561 0000566B 08DB                <1> 	or	bl,bl			; check if bit 7 set
  2562 0000566D 7904                <1> 	jns	.set_color		; bit 7 not set - new color
  2563 0000566F 30C1                <1> 	xor	cl,al			; else XOR with existing color
  2564 00005671 EB04                <1> 	jmp	.write_pixel
  2565                              <1> 
  2566                              <1> .set_color:
  2567 00005673 20E1                <1> 	and	cl,ah			; clear existing color bits
  2568 00005675 08C1                <1> 	or	cl,al			; set new color bits
  2569                              <1> 
  2570                              <1> .write_pixel:
  2571 00005677 26880C              <1>     es	mov	[si],cl			; write the byte with the new pixel
  2572 0000567A C3                  <1> 	ret
  2573                              <1> 
  2574                              <1> ;=========================================================================
  2575                              <1> ; int_10_fn0D - Read graphics pixel
  2576                              <1> ; Input:
  2577                              <1> ;	AH = 0Dh
  2578                              <1> ;	CX = column
  2579                              <1> ;	DX = row
  2580                              <1> ; Output:
  2581                              <1> ;	AL = pixel color 
  2582                              <1> ;-------------------------------------------------------------------------
  2583                              <1> int_10_fn0D:
  2584 0000567B E8CD00              <1> 	call	vid_pixel_address	; calculate pixel address
  2585 0000567E 268A04              <1>     es	mov	al,byte [si]		; read byte containing the pixel
  2586 00005681 7508                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  2587 00005683 D2E0                <1> 	shl	al,cl			; shift pixel to bit 7
  2588 00005685 D0C0                <1> 	rol	al,1			; shift pixel from bit 7 to bit 0
  2589 00005687 2401                <1> 	and	al,1			; one bit per pixel
  2590 00005689 EB0A                <1> 	jmp	.exit
  2591                              <1> 
  2592                              <1> .mode_320x200:
  2593 0000568B D0E1                <1> 	shl	cl,1			; update position for two bits per pixel
  2594 0000568D D2E0                <1> 	shl	al,cl			; shift pixel to bits 7-6
  2595 0000568F D0C0                <1> 	rol	al,1			; shift pixel to bits 1-0
  2596 00005691 D0C0                <1> 	rol	al,1
  2597 00005693 2403                <1> 	and	al,3			; two bits per pixel
  2598                              <1> 
  2599                              <1> .exit:
  2600 00005695 884600              <1> 	mov	byte [bp+int_10_al],al	; return pixel color in AL
  2601 00005698 C3                  <1> 	ret
  2602                              <1> 
  2603                              <1> ;=========================================================================
  2604                              <1> ; int_10_fn0E - Teletype output
  2605                              <1> ; Input:
  2606                              <1> ;	AH = 0Eh
  2607                              <1> ;	AL = character to write
  2608                              <1> ;	BL = foreground color (graphics modes only)
  2609                              <1> ; Output:
  2610                              <1> ;	none
  2611                              <1> ; Notes:
  2612                              <1> ;	- writes character to the active video page
  2613                              <1> ;	- support following control characters: BEL, BS, LF, CR
  2614                              <1> ;-------------------------------------------------------------------------
  2615                              <1> int_10_fn0E:
  2616 00005699 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  2617 0000569D B700                <1> 	mov	bh,0
  2618 0000569F D0E3                <1> 	shl	bl,1			; word index
  2619 000056A1 8B5750              <1> 	mov	dx,word [bx+video_cur_pos] ; DX = cursor position
  2620                              <1> 
  2621 000056A4 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = character to write
  2622 000056A7 3C08                <1> 	cmp	al,bs
  2623 000056A9 7429                <1> 	jz	.bs			; jump if backspace (BS)
  2624 000056AB 3C0A                <1> 	cmp	al,lf
  2625 000056AD 741C                <1> 	jz	.lf			; jump if line feed (LF)
  2626 000056AF 3C07                <1> 	cmp	al,bel
  2627 000056B1 7433                <1> 	jz	.bel			; jump if beep (BEL)
  2628 000056B3 3C0D                <1> 	cmp	al,cr
  2629 000056B5 7426                <1> 	jz	.cr			; jump if carriage return (CR)
  2630 000056B7 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; BL = attribute for graphics mode
  2631 000056BA B40A                <1> 	mov	ah,0Ah			; INT 10h, function 0Ah - write char
  2632 000056BC B90100              <1> 	mov	cx,1			; one character
  2633 000056BF CD10                <1> 	int	10h			; write character
  2634 000056C1 FEC2                <1> 	inc	dl			; move cursor to the next column
  2635 000056C3 3A164A00            <1> 	cmp	dl,byte [video_columns]	; compare position to number of columns
  2636 000056C7 7516                <1> 	jnz	.set_cursor_pos		; jump if not past the last column
  2637 000056C9 B200                <1> 	mov	dl,0			; move to the first position
  2638                              <1> 
  2639                              <1> .lf:
  2640 000056CB 80FE18              <1> 	cmp	dh,24			; on the last row?
  2641 000056CE 741C                <1> 	jz	.scroll			; jump if on the last row - scroll
  2642 000056D0 FEC6                <1> 	inc	dh			; move cursor to the next row
  2643 000056D2 750B                <1> 	jnz	.set_cursor_pos		; set new cursor position
  2644                              <1> 
  2645                              <1> .bs:
  2646 000056D4 80FA00              <1> 	cmp	dl,0			; on the first column?
  2647 000056D7 7406                <1> 	jz	.set_cursor_pos		; jump if yes - nothing to do
  2648 000056D9 FECA                <1> 	dec	dl			; move cursor to the previous position
  2649 000056DB EB02                <1> 	jmp	.set_cursor_pos		; set new cursor position
  2650                              <1> 
  2651                              <1> .cr:
  2652 000056DD B200                <1> 	mov	dl,0			; set cursor to the first column
  2653                              <1> 
  2654                              <1> .set_cursor_pos:
  2655 000056DF 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  2656 000056E3 E9E6FA              <1> 	jmp	set_cur_pos		; set new cursor position
  2657                              <1> 
  2658                              <1> .bel:
  2659 000056E6 B302                <1> 	mov	bl,2			; 0.2 second beep
  2660 000056E8 E8A5CF              <1> 	call	beep
  2661 000056EB C3                  <1> 	ret
  2662                              <1> 
  2663                              <1> .scroll:
  2664 000056EC B402                <1> 	mov	ah,02h
  2665 000056EE CD10                <1> 	int	10h			; set new cursor position
  2666 000056F0 E82E00              <1> 	call	vid_check_mode
  2667 000056F3 B700                <1> 	mov	bh,0
  2668 000056F5 7206                <1> 	jc	.do_scroll		; jump if text mode - do scroll
  2669 000056F7 B408                <1> 	mov	ah,08h			; INT 10h, function 08h - read char
  2670 000056F9 CD10                <1> 	int	10h			; read attirbute at current position
  2671 000056FB 88E7                <1> 	mov	bh,ah
  2672                              <1> 
  2673                              <1> .do_scroll:
  2674 000056FD B406                <1> 	mov	ah,06h			; INT 10h, function 06h - Scroll up
  2675 000056FF B001                <1> 	mov	al,1			; scroll one line
  2676 00005701 31C9                <1> 	xor	cx,cx			; top right corner is 0,0
  2677 00005703 B618                <1> 	mov	dh,24			; bottom row is 24
  2678 00005705 8A164A00            <1> 	mov	dl,byte [video_columns] ; right column is the last column
  2679 00005709 FECA                <1> 	dec	dl
  2680 0000570B CD10                <1> 	int	10h			; scroll page up
  2681 0000570D C3                  <1> 	ret
  2682                              <1> 
  2683                              <1> ;=========================================================================
  2684                              <1> ; int_10_fn0F - Get current video mode
  2685                              <1> ; Input:
  2686                              <1> ;	AH = 0Fh
  2687                              <1> ; Output:
  2688                              <1> ;	AL = video mode
  2689                              <1> ;	AH = characters per column
  2690                              <1> ;	BH = active video page
  2691                              <1> ;-------------------------------------------------------------------------
  2692                              <1> int_10_fn0F:
  2693 0000570E A04A00              <1> 	mov	al,byte [video_columns]
  2694 00005711 884601              <1> 	mov	byte [bp+int_10_ah],al
  2695 00005714 A04900              <1> 	mov	al,byte [video_mode]
  2696 00005717 884600              <1> 	mov	byte [bp+int_10_al],al
  2697 0000571A A06200              <1> 	mov	al,byte [video_page]
  2698 0000571D 884603              <1> 	mov	byte [bp+int_10_bh],al
  2699 00005720 C3                  <1> 	ret
  2700                              <1> 
  2701                              <1> ;=========================================================================
  2702                              <1> ; vid_check_mode - Check current video mode
  2703                              <1> ; Input:
  2704                              <1> ;	none
  2705                              <1> ; Output:
  2706                              <1> ;	ZF set if monochrome mode (mode 07h)
  2707                              <1> ;	CF set if graphics modes (modes 04h - 06h)
  2708                              <1> ;-------------------------------------------------------------------------
  2709                              <1> vid_check_mode:
  2710 00005721 50                  <1> 	push	ax
  2711 00005722 A04900              <1> 	mov	al,byte [video_mode]
  2712 00005725 3C07                <1> 	cmp	al,07h			; set ZF if monochrome mode
  2713 00005727 7408                <1> 	jz	.exit			; jump if monochrome
  2714 00005729 3C04                <1> 	cmp	al,04h			; clears CF if graphics mode
  2715 0000572B F5                  <1> 	cmc				; invert CF flag (CF = 1 - graphics)
  2716 0000572C 7303                <1> 	jnc	.exit			; jump if not graphics (CF = 0, ZF = 0)
  2717 0000572E 18C0                <1> 	sbb	al,al			; AL=AL-(AL+CF) set CF and clear ZF?
  2718 00005730 F9                  <1> 	stc				; set CF back
  2719                              <1> 
  2720                              <1> .exit:
  2721 00005731 58                  <1> 	pop	ax
  2722 00005732 C3                  <1> 	ret
  2723                              <1> 
  2724                              <1> ;=========================================================================
  2725                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  2726                              <1> ; Input:
  2727                              <1> ;	AH = register number
  2728                              <1> ;	CX = word to write
  2729                              <1> ; Output:
  2730                              <1> ;	AX trashed
  2731                              <1> ; Note:
  2732                              <1> ;	Writes CH to register number AH, and CL to register number AH+1
  2733                              <1> ;-------------------------------------------------------------------------
  2734                              <1> vid_crtc_writew:
  2735 00005733 88E8                <1> 	mov	al,ch
  2736 00005735 E80400              <1> 	call	vid_crtc_writeb		; write CH to CRTC register AH
  2737 00005738 FEC4                <1> 	inc	ah			; point AH to the next register
  2738 0000573A 88C8                <1> 	mov	al,cl			; prepare AL for vid_crtc_writeb
  2739                              <1> 
  2740                              <1> ; fall through to vid_crtc_writeb (writting to AH+1)
  2741                              <1> 
  2742                              <1> ;=========================================================================
  2743                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  2744                              <1> ; Input:
  2745                              <1> ;	AH = register number
  2746                              <1> ;	AL = byte to write
  2747                              <1> ; Output:
  2748                              <1> ;	none
  2749                              <1> ;-------------------------------------------------------------------------
  2750                              <1> vid_crtc_writeb:
  2751 0000573C 52                  <1> 	push	dx
  2752 0000573D 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC index port
  2753 00005741 86C4                <1> 	xchg	al,ah			; AH = byte, AL = register number
  2754 00005743 EE                  <1> 	out	dx,al			; write register number
  2755 00005744 86C4                <1> 	xchg	al,ah			; AH = register numbet, AL = byte
  2756 00005746 FEC2                <1> 	inc	dl			; DX = CRTC data port
  2757 00005748 EE                  <1> 	out	dx,al			; write byte
  2758 00005749 5A                  <1> 	pop	dx
  2759 0000574A C3                  <1> 	ret
  2760                              <1> 
  2761                              <1> ;=========================================================================
  2762                              <1> ; vid_pixel_address - calculate pixel address and mask
  2763                              <1> ; Input:
  2764                              <1> ;	CX - column
  2765                              <1> ;	DX - row
  2766                              <1> ; Output:
  2767                              <1> ;	SI - pixel address
  2768                              <1> ;	CH - pixel mask
  2769                              <1> ;	CL - pixel position in the byte
  2770                              <1> ;	ZF - mode
  2771                              <1> ;		0 = 320x200
  2772                              <1> ;		1 = 640x200
  2773                              <1> ;-------------------------------------------------------------------------
  2774                              <1> vid_pixel_address:
  2775 0000574B 31F6                <1> 	xor	si,si			; SI = 0
  2776 0000574D D0EA                <1> 	shr	dl,1			; divide row by two
  2777 0000574F 7303                <1> 	jnb	.even			; jump if on even row 
  2778 00005751 BE0020              <1> 	mov	si,2000h		; odd row - second video plane
  2779                              <1> 
  2780                              <1> .even:
  2781 00005754 B050                <1> 	mov	al,50h			; bytes in each row
  2782 00005756 F6E2                <1> 	mul	dl			; AX - address of the row
  2783                              <1> 
  2784 00005758 01C6                <1> 	add	si,ax			; add row address to SI
  2785 0000575A 89CA                <1> 	mov	dx,cx			; DX - column
  2786 0000575C B90203              <1> 	mov	cx,0302h 		; CH - pixel pos mask, CL - shift
  2787 0000575F 803E490006          <1> 	cmp	byte [video_mode],6	; 640x200 mode?
  2788 00005764 9C                  <1> 	pushf				; save ZF (and other flags
  2789 00005765 7503                <1> 	jnz	.1			; skip if not 640x200
  2790 00005767 B90307              <1> 	mov	cx,0703h 		; pixel pos mask and shift for 640x200
  2791                              <1> 
  2792                              <1> .1:
  2793 0000576A 20D5                <1> 	and	ch,dl			; CH = pixel position in the byte
  2794 0000576C D3EA                <1> 	shr	dx,cl			; DX = address of the column
  2795 0000576E 01D6                <1> 	add	si,dx			; add column address to SI
  2796 00005770 86CD                <1> 	xchg	cl,ch			; CH = pixel mask, CL = pixel position
  2797 00005772 9D                  <1> 	popf
  2798 00005773 C3                  <1> 	ret
  2799                              <1> 
  2800                              <1> ;=========================================================================
  2801                              <1> ; vid_current_offset - convert current cursor position to offset
  2802                              <1> ;		       relative to page starting address
  2803                              <1> ; Input:
  2804                              <1> ;	BL = page
  2805                              <1> ; Output:
  2806                              <1> ;	AX = offset
  2807                              <1> ;-------------------------------------------------------------------------
  2808                              <1> vid_current_offset:
  2809 00005774 B700                <1> 	mov	bh,0
  2810 00005776 D1E3                <1> 	shl	bx,1				; word index
  2811 00005778 8B4750              <1> 	mov	ax,word [bx+video_cur_pos]	; AX = current cursor position
  2812                              <1> 
  2813                              <1> ; fall through to vid_position_to_offset
  2814                              <1> 
  2815                              <1> ;=========================================================================
  2816                              <1> ; vid_position_to_offset - convert position (row and column) to offset
  2817                              <1> ;			   relative to page starting address
  2818                              <1> ; Input:
  2819                              <1> ;	AH = row
  2820                              <1> ;	AL = column
  2821                              <1> ; Output:
  2822                              <1> ;	AX = offset
  2823                              <1> ;-------------------------------------------------------------------------
  2824                              <1> vid_position_to_offset:
  2825 0000577B 53                  <1> 	push	bx
  2826 0000577C 88C3                <1> 	mov	bl,al			; BL = column
  2827 0000577E 88E0                <1> 	mov	al,ah			; AL = row
  2828 00005780 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  2829 00005784 B700                <1> 	mov	bh,0			;
  2830 00005786 01D8                <1> 	add	ax,bx			; AX = row * video_columns + column
  2831 00005788 D1E0                <1> 	shl	ax,1			; multiply by two (char + attribute)
  2832 0000578A 5B                  <1> 	pop	bx
  2833 0000578B C3                  <1> 	ret
  2834                              <1> 
  2835                              <1> ;=========================================================================
  2836                              <1> ; vid_gfx_pos_to_offset - convert position (row and column) to offset
  2837                              <1> ; Input:
  2838                              <1> ;	AH = row
  2839                              <1> ;	AL = column
  2840                              <1> ; Output:
  2841                              <1> ;	AX = offset
  2842                              <1> ;-------------------------------------------------------------------------
  2843                              <1> vid_gfx_pos_to_offset:
  2844 0000578C 53                  <1> 	push	bx
  2845 0000578D 88C3                <1> 	mov	bl,al			; BL = column
  2846 0000578F 88E0                <1> 	mov	al,ah			; AL = row
  2847 00005791 F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  2848 00005795 D1E0                <1> 	shl	ax,1			; multiply by four: one character takes
  2849 00005797 D1E0                <1> 	shl	ax,1			;   four bytes in each plane
  2850 00005799 B700                <1> 	mov	bh,0
  2851 0000579B 01D8                <1> 	add	ax,bx			; AX = row * video_columns * 4 + column
  2852 0000579D 5B                  <1> 	pop	bx
  2853 0000579E C3                  <1> 	ret
  1386                                  
  1387                                  ;=========================================================================
  1388                                  ; detect_rom_ext - Look for BIOS extensions, initialize if found
  1389                                  ;-------------------------------------------------------------------------
  1390                                  
  1391                                  detect_rom_ext:
  1392 0000579F B040                    	mov	al,e_ext_start		; ROM extension scan start
  1393 000057A1 E680                    	out	post_reg,al
  1394 000057A3 E421                    	in	al,pic1_reg1		; get IMR (option ROMs may trash it)
  1395 000057A5 50                      	push	ax			; save it
  1396 000057A6 BA00C8                  	mov	dx,0C800h
  1397 000057A9 BB00F8                  	mov	bx,0F800h
  1398                                  %ifdef BIOS_SETUP
  1399 000057AC E827B8                  	call	get_config_a
  1400 000057AF A804                    	test	al,nvram_ext_scan
  1401 000057B1 7403                    	jz	.ext_scan_loop		; ext_scan clear - scan till F8000
  1402 000057B3 BB00F0                  	mov	bx,0F000h		; ext_scan set - scan till F0000
  1403                                  %endif ; BIOS_SETUP
  1404                                  
  1405                                  .ext_scan_loop:
  1406 000057B6 E8DD00                  	call	extension_scan
  1407 000057B9 833E670000              	cmp	word [67h],0
  1408 000057BE 7429                    	jz	.ext_scan_done		; No ROM extension found
  1409 000057C0 B041                    	mov	al,e_ext_detect		; ROM extension found
  1410 000057C2 E680                    	out	post_reg,al
  1411 000057C4 BE[1304]                	mov	si,msg_rom_found
  1412 000057C7 E8A6D0                  	call	print
  1413 000057CA A16900                  	mov	ax,word [69h]		; ROM extension's segment
  1414 000057CD E8BBD0                  	call	print_hex
  1415 000057D0 BE[3004]                	mov	si,msg_rom_init
  1416 000057D3 E89AD0                  	call	print
  1417 000057D6 53                      	push	bx
  1418 000057D7 52                      	push	dx
  1419 000057D8 FF1E6700                	call	far [67h]
  1420 000057DC B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  1421 000057DF 8ED8                    	mov	ds,ax
  1422 000057E1 B042                    	mov	al,e_ext_init_ok	; ROM extension initialized
  1423 000057E3 E680                    	out	post_reg,al
  1424 000057E5 5A                      	pop	dx
  1425 000057E6 5B                      	pop	bx
  1426 000057E7 EBCD                    	jmp	.ext_scan_loop
  1427                                  
  1428                                  .ext_scan_done:
  1429 000057E9 58                      	pop	ax			; get previous IMR
  1430 000057EA E621                    	out	pic1_reg1,al		; restore it
  1431 000057EC B043                    	mov	al,e_ext_complete	; ROM extension scan complete
  1432 000057EE E680                    	out	post_reg,al
  1433                                  
  1434 000057F0 C3                      	ret
  1435                                  
  1436                                  ;=========================================================================
  1437                                  ; detect_ram - Determine the size of installed RAM and test it
  1438                                  ; Input:
  1439                                  ;	none
  1440                                  ; Output:
  1441                                  ;	AX = RAM size
  1442                                  ;	CX, SI - trashed
  1443                                  ;-------------------------------------------------------------------------
  1444                                  detect_ram:
  1445 000057F1 B030                    	mov	al,e_ram_start		; RAM scan start
  1446 000057F3 E680                    	out	post_reg,al
  1447                                  
  1448 000057F5 1E                      	push	ds
  1449 000057F6 B106                    	mov	cl,6			; for SHL - converting KiB to segment
  1450 000057F8 B82000                  	mov	ax,MIN_RAM_SIZE
  1451                                  
  1452                                  .fill_loop:
  1453 000057FB 50                      	push	ax
  1454 000057FC D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  1455 000057FE 8ED8                    	mov	ds,ax
  1456 00005800 A3FE3F                  	mov	word [RAM_TEST_BLOCK-2],ax
  1457 00005803 58                      	pop	ax
  1458 00005804 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  1459 00005807 3D8002                  	cmp	ax,MAX_RAM_SIZE
  1460 0000580A 75EF                    	jne	.fill_loop
  1461 0000580C B82000                  	mov	ax,MIN_RAM_SIZE
  1462                                  
  1463                                  .size_loop:
  1464 0000580F 50                      	push	ax
  1465 00005810 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  1466 00005812 8ED8                    	mov	ds,ax
  1467 00005814 3906FE3F                	cmp	word [RAM_TEST_BLOCK-2],ax
  1468 00005818 750B                    	jne	.size_done
  1469 0000581A 58                      	pop	ax
  1470 0000581B 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  1471 0000581E 3D8002                  	cmp	ax,MAX_RAM_SIZE
  1472 00005821 7303                    	jnb	.size_exit
  1473 00005823 EBEA                    	jmp	.size_loop
  1474                                  
  1475                                  .size_done:
  1476 00005825 58                      	pop	ax
  1477                                  
  1478                                  .size_exit:
  1479 00005826 1F                      	pop	ds
  1480 00005827 A31300                  	mov	word [memory_size],ax	; store it for now... might change later
  1481 0000582A C3                      	ret
  1482                                  
  1483                                  ;=========================================================================
  1484                                  ; int_12 - Get memory size
  1485                                  ; Input:
  1486                                  ;	none
  1487                                  ; Output:
  1488                                  ;	AX = memory size
  1489                                  ;-------------------------------------------------------------------------
  1490 0000582B FF<rep 16h>             	setloc	0F841h			; INT 12 Entry Point
  1490          ******************       warning: Inserting 22 bytes [-w+user]
  1491                                  int_12:
  1492 00005841 FB                      	sti
  1493 00005842 1E                      	push	ds
  1494 00005843 B84000                  	mov	ax,biosdseg
  1495 00005846 8ED8                    	mov	ds,ax
  1496 00005848 A11300                  	mov	ax,word [memory_size]
  1497 0000584B 1F                      	pop	ds
  1498 0000584C CF                      	iret
  1499                                  
  1500                                  ;=========================================================================
  1501                                  ; int_11 - Get equipment list
  1502                                  ; Input:
  1503                                  ;	none
  1504                                  ; Output:
  1505                                  ;	AX = equipment list
  1506                                  ;-------------------------------------------------------------------------
  1507                                  	setloc	0F84Dh			; INT 11 Entry Point
  1508                                  int_11:
  1509 0000584D FB                      	sti
  1510 0000584E 1E                      	push	ds
  1511 0000584F B84000                  	mov	ax,biosdseg
  1512 00005852 8ED8                    	mov	ds,ax
  1513 00005854 A11000                  	mov	ax,word [equipment_list]
  1514 00005857 1F                      	pop	ds
  1515 00005858 CF                      	iret
  1516                                  
  1517                                  ;=========================================================================
  1518                                  ; Includes with fixed entry points (for IBM compatibility)
  1519                                  ;-------------------------------------------------------------------------
  1520                                  
  1521                                  %include	"misc.inc"
  1522                              <1> ;=========================================================================
  1523                              <1> ; misc.inc - Miscellaneous BIOS Services
  1524                              <1> ;       INT 15h, functions:
  1525                              <1> ;       	4Fh	- OS hook keyboard intercept
  1526                              <1> ;		90h	- Device busy loop
  1527                              <1> ;		91h	- Interrupt completed
  1528                              <1> ;		0C0h	- Get system configruation
  1529                              <1> ;		0C2h	- PS/2 mouse services (see ps2aux.inc)
  1530                              <1> ;		
  1531                              <1> ;-------------------------------------------------------------------------
  1532                              <1> ;
  1533                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1534                              <1> ;
  1535                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
  1536                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1537                              <1> ;
  1538                              <1> ; This program is free software: you can redistribute it and/or modify
  1539                              <1> ; it under the terms of the GNU General Public License as published by
  1540                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1541                              <1> ; (at your option) any later version.
  1542                              <1> ;
  1543                              <1> ; This program is distributed in the hope that it will be useful,
  1544                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1545                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1546                              <1> ; GNU General Public License for more details.
  1547                              <1> ;
  1548                              <1> ; You should have received a copy of the GNU General Public License
  1549                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1550                              <1> ;
  1551                              <1> ;=========================================================================
  1552                              <1> 
  1553                              <1> ;-------------------------------------------------------------------------
  1554                              <1> ; offsets for registers on stack
  1555                              <1> int_15_bp	equ	0
  1556                              <1> int_15_ip	equ	int_15_bp+2
  1557                              <1> int_15_cs	equ	int_15_ip+2
  1558                              <1> int_15_flags	equ	int_15_cs+2
  1559                              <1> 
  1560                              <1> ;=========================================================================
  1561                              <1> ; int_15 - Miscellaneous BIOS services
  1562                              <1> ; Input:
  1563                              <1> ;	AH = 4Fh - OS hook keyboard intercept
  1564                              <1> ;		- Does nothing
  1565                              <1> ;	AH = 0C2h - PS/2 mouse services
  1566                              <1> ;		- Implemented in ps2aux.inc
  1567                              <1> ;-------------------------------------------------------------------------
  1568                              <1> 	setloc	0F859h			; INT 15 Entry Point
  1569                              <1> int_15:
  1570 00005859 FB                  <1> 	sti
  1571 0000585A 80FC4F              <1> 	cmp	ah,4Fh
  1572 0000585D 742A                <1> 	je	int_15_exit		; continue with int 09h ISR
  1573 0000585F 80FCC0              <1> 	cmp	ah,0C0h
  1574 00005862 7426                <1> 	je	int_15_fnC0
  1575 00005864 3D0190              <1> 	cmp	ax,9001h
  1576 00005867 741E                <1> 	je	int_15_os_hook		; diskette - device busy hook
  1577 00005869 3DFD90              <1> 	cmp	ax,90FDh
  1578 0000586C 7419                <1> 	je	int_15_os_hook		; diskette - motor start hook
  1579 0000586E 3D0191              <1> 	cmp	ax,9101h
  1580 00005871 7414                <1> 	je	int_15_os_hook		; diskette - interrupt completed
  1581                              <1> 
  1582                              <1> %ifdef PS2_MOUSE
  1583                              <1> 	cmp	ah,0C2h
  1584                              <1> 	jne	.1
  1585                              <1> 	jmp	int_15_fnC2		; jump to PS/2 mouse handler
  1586                              <1> .1:
  1587                              <1> %endif
  1588                              <1> 
  1589 00005873 B486                <1> 	mov	ah,86h			; no cassete present
  1590                              <1> 
  1591                              <1> int_15_err:
  1592 00005875 55                  <1> 	push	bp
  1593 00005876 89E5                <1> 	mov	bp,sp
  1594 00005878 804E0601            <1> 	or	byte [bp+int_15_flags],1 ; set CF flag
  1595 0000587C 5D                  <1> 	pop	bp
  1596 0000587D CF                  <1> 	iret
  1597                              <1> 
  1598                              <1> int_15_ok:
  1599 0000587E 55                  <1> 	push	bp
  1600 0000587F 89E5                <1> 	mov	bp,sp
  1601 00005881 806606FE            <1> 	and	byte [bp+int_15_flags],~1 ; clear CF flag
  1602 00005885 5D                  <1> 	pop	bp
  1603 00005886 CF                  <1> 	iret
  1604                              <1> 
  1605                              <1> int_15_os_hook:
  1606 00005887 B400                <1> 	mov	ah,00h
  1607                              <1> 
  1608                              <1> int_15_exit:
  1609 00005889 CF                  <1> 	iret
  1610                              <1> 
  1611                              <1> ;=========================================================================
  1612                              <1> ; int_15_fnC0 - Get configuration
  1613                              <1> ; Input:
  1614                              <1> ;	AH = 0C0h - get configuration
  1615                              <1> ; Output:
  1616                              <1> ;	AH = 00h - function supported
  1617                              <1> ;	ES:BX = configuration table (0F000h:0E6F5h)
  1618                              <1> ;	CF = 0 (success)
  1619                              <1> ;-------------------------------------------------------------------------
  1620                              <1> int_15_fnC0:
  1621 0000588A B400                <1> 	mov	ah,00h
  1622 0000588C BB00F0              <1> 	mov	bx,bioscseg
  1623 0000588F 8EC3                <1> 	mov	es,bx
  1624 00005891 BB[F546]            <1> 	mov	bx,config_table
  1625 00005894 EBE8                <1> 	jmp	int_15_ok
  1522                                  
  1523                                  ;=========================================================================
  1524                                  ; extension_scan - scan for BIOS extensions
  1525                                  ; Input:
  1526                                  ;	DX - start segment
  1527                                  ;	BX - end segment
  1528                                  ; Returns:
  1529                                  ;	DX - address for the continuation of the scan
  1530                                  ;	biosdseg:67h - address of the extension, 0000:0000 if not found
  1531                                  ;-------------------------------------------------------------------------
  1532                                  extension_scan:
  1533 00005896 C70667000000            	mov	word [67h],0
  1534 0000589C C70669000000            	mov	word [69h],0
  1535                                  .scan:
  1536 000058A2 8EC2                    	mov	es,dx
  1537 000058A4 26813E000055AA              es	cmp	word [0],0AA55h		; check for signature
  1538 000058AB 7532                    	jnz	.next			; no signature, check next 2 KiB
  1539 000058AD 26A00200                    es	mov	al,byte [2]		; AL = rom size in 512 byte blocks
  1540 000058B1 B400                    	mov	ah,0
  1541 000058B3 B105                    	mov	cl,5
  1542 000058B5 D3E0                    	shl	ax,cl			; convert size to paragraphs
  1543 000058B7 01C2                    	add	dx,ax
  1544 000058B9 83C27F                  	add	dx,007Fh		; round DX to the nearest 2 KiB
  1545 000058BC 83E280                  	and	dx,0FF80h		; (2 KiB = 128 x 16 bytes)
  1546 000058BF B104                    	mov	cl,4
  1547 000058C1 D3E0                    	shl	ax,cl			; convert size to bytes
  1548 000058C3 89C1                    	mov	cx,ax
  1549 000058C5 B000                    	mov	al,0
  1550 000058C7 31F6                    	xor	si,si
  1551                                  .checksum:
  1552 000058C9 260204                      es	add	al,byte [si]
  1553 000058CC 46                      	inc	si
  1554 000058CD E2FA                    	loop	.checksum
  1555 000058CF 08C0                    	or	al,al			; AL == 0?
  1556 000058D1 750C                    	jnz	.next			; AL not zero - bad checksum
  1557 000058D3 C70667000300            	mov	word [67h],3		; extension initialization offset
  1558 000058D9 8C066900                	mov	word [69h],es		; extension segment
  1559 000058DD EB08                    	jmp	.exit
  1560                                  .next:
  1561 000058DF 81C28000                	add	dx,80h			; add 2 KiB
  1562 000058E3 39DA                    	cmp	dx,bx
  1563 000058E5 72BB                    	jb	.scan
  1564                                  .exit:
  1565 000058E7 C3                      	ret
  1566                                  
  1567                                  ;=========================================================================
  1568                                  ; ipl - Initial Program Load - try to read and execute boot sector
  1569                                  ;-------------------------------------------------------------------------
  1570                                  ipl:
  1571 000058E8 FB                      	sti
  1572 000058E9 31C0                    	xor	ax,ax
  1573 000058EB 8ED8                    	mov	ds,ax
  1574 000058ED C7067800[C74F]          	mov	word [78h],int_1E	; set Floppy Parameters Table location
  1575 000058F3 8C0E7A00                	mov	word [7Ah],cs
  1576                                  
  1577                                  .boot_retry:
  1578 000058F7 B90400                  	mov	cx,4			; retry booting from floppy 4 times
  1579                                  
  1580                                  .fd_read_retry:
  1581 000058FA 51                      	push	cx
  1582 000058FB B400                    	mov	ah,00h			; reset disk system
  1583 000058FD B200                    	mov	dl,00h			; drive 0
  1584 000058FF CD13                    	int	13h
  1585 00005901 7220                    	jb	.fd_failed
  1586 00005903 B408                    	mov	ah,08h			; get drive parameters
  1587 00005905 B200                    	mov	dl,00h			; drive 0
  1588 00005907 CD13                    	int	13h
  1589 00005909 7218                    	jc	.fd_failed
  1590 0000590B 80FA00                  	cmp	dl,00h
  1591 0000590E 7416                    	jz	.try_hdd		; jump if zero drives
  1592 00005910 B80102                  	mov	ax,0201h		; read one sector
  1593 00005913 31D2                    	xor	dx,dx			; head 0, drive 0
  1594 00005915 8EC2                    	mov	es,dx			; to 0000:7C00
  1595 00005917 BB007C                  	mov	bx,7C00h
  1596 0000591A B90100                  	mov	cx,0001h		; track 0, sector 1
  1597 0000591D CD13                    	int	13h
  1598 0000591F 7202                    	jc	.fd_failed
  1599 00005921 EB1D                    	jmp	.check_signature	; read successful, check for boot sector
  1600                                  
  1601                                  .fd_failed:
  1602 00005923 59                      	pop	cx
  1603 00005924 E2D4                    	loop	.fd_read_retry
  1604                                  
  1605                                  ; try booting from HDD
  1606                                  .try_hdd:
  1607 00005926 B40D                    	mov	ah,0Dh			; reset hard disks
  1608 00005928 B280                    	mov	dl,80h			; drive 80h
  1609 0000592A CD13                    	int	13h
  1610 0000592C 7217                    	jc	.boot_failed
  1611 0000592E B80102                  	mov	ax,0201h		; read one sector
  1612 00005931 BA8000                  	mov	dx,0080h		; head 0, drive 80h
  1613 00005934 31C9                    	xor	cx,cx
  1614 00005936 8EC1                    	mov	es,cx
  1615 00005938 BB007C                  	mov	bx,7C00h		; to 0000:7C00
  1616 0000593B 41                      	inc	cx			; CX == 0001h; track 0, sector 1
  1617 0000593C CD13                    	int	13h
  1618 0000593E 7205                    	jc	.boot_failed
  1619                                  
  1620                                  .check_signature:
  1621                                  %ifdef BOOT_SIGNATURE
  1622                                      es	cmp	word [7DFEh],0AA55h
  1623                                  	jnz	.boot_failed		; boot sector signature not found
  1624                                  %endif ; BOOT_SIGNATURE
  1625 00005940 EA007C0000              	jmp	0000h:7C00h		; jump to the boot sector
  1626                                  
  1627                                  .boot_failed:
  1628 00005945 BE[D703]                	mov	si,msg_boot_failed
  1629 00005948 E825CF                  	call	print
  1630 0000594B B400                    	mov	ah,00h
  1631 0000594D CD16                    	int	16h
  1632 0000594F EBA6                    	jmp	.boot_retry
  1633                                  
  1634                                  ;=========================================================================
  1635                                  ; test_ram - Test installed RAM
  1636                                  ; Input:
  1637                                  ;	AX = detected RAM size
  1638                                  ; Output:
  1639                                  ;	AX = tested RAM size
  1640                                  ;	CX, SI - trashed
  1641                                  ;-------------------------------------------------------------------------
  1642                                  test_ram:
  1643 00005951 813E72003412            	cmp	word [warm_boot],1234h	; warm boot - don't test RAM
  1644 00005957 747D                    	je	.test_done
  1645                                  
  1646                                  %ifdef BIOS_SETUP
  1647 00005959 50                      	push	ax
  1648 0000595A E879B6                  	call	get_config_a
  1649 0000595D A808                    	test	al,nvram_mem_test
  1650 0000595F 58                      	pop	ax
  1651 00005960 7574                    	jnz	.test_done		; mem_test set - skip memory test
  1652                                  %endif ; BIOS_SETUP
  1653                                  
  1654 00005962 BE[7103]                	mov	si,msg_ram_testing
  1655 00005965 E808CF                  	call	print
  1656 00005968 B82000                  	mov	ax,MIN_RAM_SIZE		; start from 32 KiB
  1657                                  
  1658                                  .test_loop:
  1659 0000596B 50                      	push	ax
  1660 0000596C B403                    	mov	ah,03h			; INT 10h, AH=03h - get cursor position
  1661 0000596E B700                    	mov	bh,00h			; page 0
  1662 00005970 CD10                    	int	10h			; position returned in DX
  1663 00005972 58                      	pop	ax
  1664 00005973 E837CF                  	call	print_dec
  1665 00005976 50                      	push	ax
  1666 00005977 B402                    	mov	ah,02h			; INT 10h, AH=02h - set cursor position
  1667 00005979 B700                    	mov	bh,00h			; page 0
  1668 0000597B CD10                    	int	10h
  1669 0000597D B401                    	mov	ah,01h
  1670 0000597F CD16                    	int	16h
  1671 00005981 7412                    	jz	.test_no_key
  1672 00005983 B400                    	mov	ah,00h
  1673 00005985 CD16                    	int	16h			; read the keystroke
  1674 00005987 3C1B                    	cmp	al,1Bh			; ESC?
  1675 00005989 7421                    	je	.test_esc
  1676 0000598B 3D003B                  	cmp	ax,3B00h		; F1?
  1677 0000598E 7505                    	jne	.test_no_key
  1678 00005990 800E120001              	or	byte [post_flags],post_setup
  1679                                  
  1680                                  .test_no_key:
  1681 00005995 58                      	pop	ax
  1682 00005996 E83E00                  	call	ram_test_block
  1683 00005999 721D                    	jc	.test_error		; error in last test
  1684 0000599B 83C010                  	add	ax,RAM_TEST_BLOCK/1024	; test the next block
  1685 0000599E 3B061300                	cmp	ax,word [memory_size]
  1686 000059A2 72C7                    	jb	.test_loop
  1687                                  
  1688 000059A4 50                      	push	ax
  1689 000059A5 B031                    	mov	al,e_ram_complete	; RAM scan complete
  1690 000059A7 E680                    	out	post_reg,al
  1691 000059A9 58                      	pop	ax
  1692                                  
  1693 000059AA EB2A                    	jmp	.test_done
  1694                                  
  1695                                  .test_esc:
  1696 000059AC 58                      	pop	ax
  1697 000059AD A11300                  	mov	ax,word [memory_size]
  1698                                  
  1699 000059B0 50                      	push	ax
  1700 000059B1 B032                    	mov	al,e_ram_esc		; RAM scan canceled
  1701 000059B3 E680                    	out	post_reg,al
  1702 000059B5 58                      	pop	ax
  1703                                  
  1704 000059B6 EB1E                    	jmp	.test_done
  1705                                  
  1706                                  .test_error:
  1707 000059B8 A31300                  	mov	word [memory_size],ax	; store size of good memory
  1708 000059BB BE[8E03]                	mov	si,msg_ram_error
  1709 000059BE E8AFCE                  	call	print
  1710 000059C1 E8E9CE                  	call	print_dec
  1711 000059C4 BE[D003]                	mov	si,msg_kib
  1712 000059C7 E8A6CE                  	call	print
  1713 000059CA BE[8B00]                	mov	si,msg_crlf
  1714 000059CD E8A0CE                  	call	print
  1715                                  
  1716 000059D0 50                      	push	ax
  1717 000059D1 B055                    	mov	al,e_ram_fail		; RAM scan failed
  1718 000059D3 E680                    	out	post_reg,al
  1719 000059D5 58                      	pop	ax
  1720                                  
  1721                                  .test_done:
  1722 000059D6 C3                      	ret
  1723                                  
  1724                                  ;=========================================================================
  1725                                  ; ram_test_block - Test a 16 KiB (RAM_TEST_BLOCK) of RAM
  1726                                  ; Input:
  1727                                  ;	AX = address of the memory to test (in KiB)
  1728                                  ; Output:
  1729                                  ;	CF = status
  1730                                  ;		0 = passed
  1731                                  ;		1 = failed
  1732                                  ;-------------------------------------------------------------------------
  1733                                  ram_test_block:
  1734 000059D7 50                      	push	ax
  1735 000059D8 53                      	push	bx
  1736 000059D9 51                      	push	cx
  1737 000059DA 56                      	push	si
  1738 000059DB 57                      	push	di
  1739 000059DC 1E                      	push	ds
  1740 000059DD 06                      	push	es
  1741 000059DE B106                    	mov	cl,6			; convert KiB to segment address
  1742 000059E0 D3E0                    	shl	ax,cl			; (multiply by 64)
  1743 000059E2 8ED8                    	mov	ds,ax
  1744 000059E4 8EC0                    	mov	es,ax
  1745 000059E6 31F6                    	xor	si,si
  1746 000059E8 31FF                    	xor	di,di
  1747 000059EA BB0020                  	mov	bx,RAM_TEST_BLOCK/2	; RAM test block size in words
  1748 000059ED B8AA55                  	mov	ax,55AAh		; first test pattern
  1749 000059F0 89D9                    	mov	cx,bx
  1750 000059F2 F3AB                        rep	stosw				; store test pattern
  1751 000059F4 89D9                    	mov	cx,bx			; RAM test block size
  1752                                  .1:
  1753 000059F6 AD                      	lodsw
  1754 000059F7 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  1755 000059FA 7522                    	jne	.fail
  1756 000059FC E2F8                    	loop	.1
  1757 000059FE 31F6                    	xor	si,si
  1758 00005A00 31FF                    	xor	di,di
  1759 00005A02 B855AA                  	mov	ax,0AA55h		; second test pattern
  1760 00005A05 89D9                    	mov	cx,bx			; RAM test block size
  1761 00005A07 F3AB                        rep stosw				; store test pattern
  1762 00005A09 89D9                    	mov	cx,bx			; RAM test block size
  1763                                  .2:
  1764 00005A0B AD                      	lodsw
  1765 00005A0C 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  1766 00005A0F 750D                    	jne	.fail
  1767 00005A11 E2F8                    	loop	.2
  1768 00005A13 31FF                    	xor	di,di
  1769 00005A15 31C0                    	xor	ax,ax			; zero
  1770 00005A17 89D9                    	mov	cx,bx			; RAM test block size
  1771 00005A19 F3AB                        rep stosw				; zero the memory
  1772 00005A1B F8                      	clc				; test passed, clear CF
  1773 00005A1C EB01                    	jmp	.exit
  1774                                  
  1775                                  .fail:
  1776 00005A1E F9                      	stc				; test failed, set CF
  1777                                  	
  1778                                  .exit:
  1779 00005A1F 07                      	pop	es
  1780 00005A20 1F                      	pop	ds
  1781 00005A21 5F                      	pop	di
  1782 00005A22 5E                      	pop	si
  1783 00005A23 59                      	pop	cx
  1784 00005A24 5B                      	pop	bx
  1785 00005A25 58                      	pop	ax
  1786 00005A26 C3                      	ret
  1787                                  
  1788                                  ;=========================================================================
  1789                                  ; Includes with fixed entry points (for IBM compatibility)
  1790                                  ;-------------------------------------------------------------------------
  1791                                  %include	"fnt00-7F.inc"
  1792                              <1> ;=========================================================================
  1793                              <1> ; fnt00-7F.inc - Font for graphics modes
  1794                              <1> ;       Characters from 00h to 7Fh
  1795                              <1> ;-------------------------------------------------------------------------
  1796                              <1> ;
  1797                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1798                              <1> ;
  1799                              <1> ; This font is borrowed from kbd package (alt-8x8)
  1800                              <1> ;
  1801                              <1> ; This program is free software: you can redistribute it and/or modify
  1802                              <1> ; it under the terms of the GNU General Public License as published by
  1803                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1804                              <1> ; (at your option) any later version.
  1805                              <1> ;
  1806                              <1> ; This program is distributed in the hope that it will be useful,
  1807                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1808                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1809                              <1> ; GNU General Public License for more details.
  1810                              <1> ;
  1811                              <1> ; You should have received a copy of the GNU General Public License
  1812                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1813                              <1> ;
  1814                              <1> ;=========================================================================
  1815 00005A27 FF<rep 47h>         <1> 	setloc	0FA6Eh			; IBM graphics char set entry
  1815          ******************  <1>  warning: Inserting 71 bytes [-w+user]
  1816                              <1> gfx_font:
  1817 00005A6E 0000000000000000    <1> 	db	 00h, 00h,   00h,  00h,  00h,  00h,  00h,  00h
  1818 00005A76 7E81A581BD99817E    <1> 	db	 7Eh, 81h,  0A5h,  81h, 0BDh,  99h,  81h,  7Eh
  1819 00005A7E 7EFFDBFFC3E7FF7E    <1> 	db	 7Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh,  7Eh
  1820 00005A86 6CFEFEFE7C381000    <1> 	db	 6Ch, 0FEh, 0FEh, 0FEh,  7Ch,  38h,  10h,  00h
  1821 00005A8E 10387CFE7C381000    <1> 	db	 10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  10h,  00h
  1822 00005A96 387C38FEFE7C387C    <1> 	db	 38h,  7Ch,  38h, 0FEh, 0FEh,  7Ch,  38h,  7Ch
  1823 00005A9E 1010387CFE7C387C    <1> 	db	 10h,  10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  7Ch
  1824 00005AA6 0000183C3C180000    <1> 	db	 00h,  00h,  18h,  3Ch,  3Ch,  18h,  00h,  00h
  1825 00005AAE FFFFE7C3C3E7FFFF    <1> 	db	0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh
  1826 00005AB6 003C664242663C00    <1> 	db	 00h,  3Ch,  66h,  42h,  42h,  66h,  3Ch,  00h
  1827 00005ABE FFC399BDBD99C3FF    <1> 	db	0FFh, 0C3h,  99h, 0BDh, 0BDh,  99h, 0C3h, 0FFh
  1828 00005AC6 0F070F7DCCCCCC78    <1> 	db	 0Fh,  07h,  0Fh,  7Dh, 0CCh, 0CCh, 0CCh,  78h
  1829 00005ACE 3C6666663C187E18    <1> 	db	 3Ch,  66h,  66h,  66h,  3Ch,  18h,  7Eh,  18h
  1830 00005AD6 3F333F303070F0E0    <1> 	db	 3Fh,  33h,  3Fh,  30h,  30h,  70h, 0F0h, 0E0h
  1831 00005ADE 7F637F636367E6C0    <1> 	db	 7Fh,  63h,  7Fh,  63h,  63h,  67h, 0E6h, 0C0h
  1832 00005AE6 995A3CE7E73C5A99    <1> 	db	 99h,  5Ah,  3Ch, 0E7h, 0E7h,  3Ch,  5Ah,  99h
  1833 00005AEE 80E0F8FEF8E08000    <1> 	db	 80h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h,  80h,  00h
  1834 00005AF6 020E3EFE3E0E0200    <1> 	db	 02h,  0Eh,  3Eh, 0FEh,  3Eh,  0Eh,  02h,  00h
  1835 00005AFE 183C7E18187E3C18    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  7Eh,  3Ch,  18h
  1836 00005B06 6666666666006600    <1> 	db	 66h,  66h,  66h,  66h,  66h,  00h,  66h,  00h
  1837 00005B0E 7FDBDB7B1B1B1B00    <1> 	db	 7Fh, 0DBh, 0DBh,  7Bh,  1Bh,  1Bh,  1Bh,  00h
  1838 00005B16 3E63386C6C38CC78    <1> 	db	 3Eh,  63h,  38h,  6Ch,  6Ch,  38h, 0CCh,  78h
  1839 00005B1E 000000007E7E7E00    <1> 	db	 00h,  00h,  00h,  00h,  7Eh,  7Eh,  7Eh,  00h
  1840 00005B26 183C7E187E3C18FF    <1> 	db	 18h,  3Ch,  7Eh,  18h,  7Eh,  3Ch,  18h, 0FFh
  1841 00005B2E 183C7E1818181800    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  18h,  18h,  00h
  1842 00005B36 181818187E3C1800    <1> 	db	 18h,  18h,  18h,  18h,  7Eh,  3Ch,  18h,  00h
  1843 00005B3E 00180CFE0C180000    <1> 	db	 00h,  18h,  0Ch, 0FEh,  0Ch,  18h,  00h,  00h
  1844 00005B46 003060FE60300000    <1> 	db	 00h,  30h,  60h, 0FEh,  60h,  30h,  00h,  00h
  1845 00005B4E 0000C0C0C0FE0000    <1> 	db	 00h,  00h, 0C0h, 0C0h, 0C0h, 0FEh,  00h,  00h
  1846 00005B56 002466FF66240000    <1> 	db	 00h,  24h,  66h, 0FFh,  66h,  24h,  00h,  00h
  1847 00005B5E 00183C7EFFFF0000    <1> 	db	 00h,  18h,  3Ch,  7Eh,  0FFh, 0FFh, 00h,  00h
  1848 00005B66 00FFFF7E3C180000    <1> 	db	 00h, 0FFh, 0FFh,  7Eh,  3Ch,  18h,  00h,  00h
  1849 00005B6E 0000000000000000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h,  00h
  1850 00005B76 3078783030003000    <1> 	db	 30h,  78h,  78h,  30h,  30h,  00h,  30h,  00h
  1851 00005B7E 6C6C6C0000000000    <1> 	db	 6Ch,  6Ch,  6Ch,  00h,  00h,  00h,  00h,  00h
  1852 00005B86 6C6CFE6CFE6C6C00    <1> 	db	 6Ch,  6Ch, 0FEh,  6Ch, 0FEh,  6Ch,  6Ch,  00h
  1853 00005B8E 307CC0780CF83000    <1> 	db	 30h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  30h,  00h
  1854 00005B96 00C6CC183066C600    <1> 	db	 00h, 0C6h, 0CCh,  18h,  30h,  66h, 0C6h,  00h
  1855 00005B9E 386C3876DCCC7600    <1> 	db	 38h,  6Ch,  38h,  76h, 0DCh, 0CCh,  76h,  00h
  1856 00005BA6 6060C00000000000    <1> 	db	 60h,  60h, 0C0h,  00h,  00h,  00h,  00h,  00h
  1857 00005BAE 1830606060301800    <1> 	db	 18h,  30h,  60h,  60h,  60h,  30h,  18h,  00h
  1858 00005BB6 6030181818306000    <1> 	db	 60h,  30h,  18h,  18h,  18h,  30h,  60h,  00h
  1859 00005BBE 00663CFF3C660000    <1> 	db	 00h,  66h,  3Ch, 0FFh,  3Ch,  66h,  00h,  00h
  1860 00005BC6 003030FC30300000    <1> 	db	 00h,  30h,  30h, 0FCh,  30h,  30h,  00h,  00h
  1861 00005BCE 0000000000303060    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  60h
  1862 00005BD6 000000FC00000000    <1> 	db	 00h,  00h,  00h, 0FCh,  00h,  00h,  00h,  00h
  1863 00005BDE 0000000000303000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  00h
  1864 00005BE6 060C183060C08000    <1> 	db	 06h,  0Ch,  18h,  30h,  60h, 0C0h,  80h,  00h
  1865 00005BEE 7CC6CEDEF6E67C00    <1> 	db	 7Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h,  7Ch,  00h
  1866 00005BF6 307030303030FC00    <1> 	db	 30h,  70h,  30h,  30h,  30h,  30h, 0FCh,  00h
  1867 00005BFE 78CC0C3860CCFC00    <1> 	db	 78h, 0CCh,  0Ch,  38h,  60h, 0CCh, 0FCh,  00h
  1868 00005C06 78CC0C380CCC7800    <1> 	db	 78h, 0CCh,  0Ch,  38h,  0Ch, 0CCh,  78h,  00h
  1869 00005C0E 1C3C6CCCFE0C1E00    <1> 	db	 1Ch,  3Ch,  6Ch, 0CCh, 0FEh,  0Ch,  1Eh,  00h
  1870 00005C16 FCC0F80C0CCC7800    <1> 	db	0FCh, 0C0h, 0F8h,  0Ch,  0Ch, 0CCh,  78h,  00h
  1871 00005C1E 3860C0F8CCCC7800    <1> 	db	 38h,  60h, 0C0h, 0F8h, 0CCh, 0CCh,  78h,  00h
  1872 00005C26 FCCC0C1830303000    <1> 	db	0FCh, 0CCh,  0Ch,  18h,  30h,  30h,  30h,  00h
  1873 00005C2E 78CCCC78CCCC7800    <1> 	db	 78h, 0CCh, 0CCh,  78h, 0CCh, 0CCh,  78h,  00h
  1874 00005C36 78CCCC7C0C187000    <1> 	db	 78h, 0CCh, 0CCh,  7Ch,  0Ch,  18h,  70h,  00h
  1875 00005C3E 0030300000303000    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  00h
  1876 00005C46 0030300000303060    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  60h
  1877 00005C4E 183060C060301800    <1> 	db	 18h,  30h,  60h, 0C0h,  60h,  30h,  18h,  00h
  1878 00005C56 0000FC0000FC0000    <1> 	db	 00h,  00h, 0FCh,  00h,  00h, 0FCh,  00h,  00h
  1879 00005C5E 6030180C18306000    <1> 	db	 60h,  30h,  18h,  0Ch,  18h,  30h,  60h,  00h
  1880 00005C66 78CC0C1830003000    <1> 	db	 78h, 0CCh,  0Ch,  18h,  30h,  00h,  30h,  00h
  1881 00005C6E 7CC6DEDEDEC07800    <1> 	db	 7Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h,  78h,  00h
  1882 00005C76 3078CCCCFCCCCC00    <1> 	db	 30h,  78h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh,  00h
  1883 00005C7E FC66667C6666FC00    <1> 	db	0FCh,  66h,  66h,  7Ch,  66h,  66h, 0FCh,  00h
  1884 00005C86 3C66C0C0C0663C00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0C0h,  66h,  3Ch,  00h
  1885 00005C8E F86C6666666CF800    <1> 	db	0F8h,  6Ch,  66h,  66h,  66h,  6Ch, 0F8h,  00h
  1886 00005C96 FE6268786862FE00    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  62h, 0FEh,  00h
  1887 00005C9E FE6268786860F000    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  60h, 0F0h,  00h
  1888 00005CA6 3C66C0C0CE663E00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0CEh,  66h,  3Eh,  00h
  1889 00005CAE CCCCCCFCCCCCCC00    <1> 	db	0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh,  00h
  1890 00005CB6 7830303030307800    <1> 	db	 78h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  1891 00005CBE 1E0C0C0CCCCC7800    <1> 	db	 1Eh,  0Ch,  0Ch,  0Ch, 0CCh, 0CCh,  78h,  00h
  1892 00005CC6 E6666C786C66E600    <1> 	db	0E6h,  66h,  6Ch,  78h,  6Ch,  66h, 0E6h,  00h
  1893 00005CCE F06060606266FE00    <1> 	db	0F0h,  60h,  60h,  60h,  62h,  66h, 0FEh,  00h
  1894 00005CD6 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
  1895 00005CDE C6E6F6DECEC6C600    <1> 	db	0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h,  00h
  1896 00005CE6 386CC6C6C66C3800    <1> 	db	 38h,  6Ch, 0C6h, 0C6h, 0C6h,  6Ch,  38h,  00h
  1897 00005CEE FC66667C6060F000    <1> 	db	0FCh,  66h,  66h,  7Ch,  60h,  60h, 0F0h,  00h
  1898 00005CF6 78CCCCCCDC781C00    <1> 	db	 78h, 0CCh, 0CCh, 0CCh, 0DCh,  78h,  1Ch,  00h
  1899 00005CFE FC66667C6C66E600    <1> 	db	0FCh,  66h,  66h,  7Ch,  6Ch,  66h, 0E6h,  00h
  1900 00005D06 78CCE0701CCC7800    <1> 	db	 78h, 0CCh, 0E0h,  70h,  1Ch, 0CCh,  78h,  00h
  1901 00005D0E FCB4303030307800    <1> 	db	0FCh, 0B4h,  30h,  30h,  30h,  30h,  78h,  00h
  1902 00005D16 CCCCCCCCCCCCFC00    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh,  00h
  1903 00005D1E CCCCCCCCCC783000    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  1904 00005D26 C6C6C6D6FEEEC600    <1> 	db	0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h,  00h
  1905 00005D2E C6446C38386CC600    <1> 	db	0C6h,  44h,  6Ch,  38h,  38h,  6Ch, 0C6h,  00h
  1906 00005D36 CCCCCC7830307800    <1> 	db	0CCh, 0CCh, 0CCh,  78h,  30h,  30h,  78h,  00h
  1907 00005D3E FEC68C183266FE00    <1> 	db	0FEh, 0C6h,  8Ch,  18h,  32h,  66h, 0FEh,  00h
  1908 00005D46 7860606060607800    <1> 	db	 78h,  60h,  60h,  60h,  60h,  60h,  78h,  00h
  1909 00005D4E C06030180C060200    <1> 	db	0C0h,  60h,  30h,  18h,  0Ch,  06h,  02h,  00h
  1910 00005D56 7818181818187800    <1> 	db	 78h,  18h,  18h,  18h,  18h,  18h,  78h,  00h
  1911 00005D5E 10386CC600000000    <1> 	db	 10h,  38h,  6Ch, 0C6h,  00h,  00h,  00h,  00h
  1912 00005D66 00000000000000FF    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h, 0FFh
  1913 00005D6E 3030180000000000    <1> 	db	 30h,  30h,  18h,  00h,  00h,  00h,  00h,  00h
  1914 00005D76 0000780C7CCC7C00    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  7Ch,  00h
  1915 00005D7E 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
  1916 00005D86 000078CCC0CC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0C0h, 0CCh,  78h,  00h
  1917 00005D8E 0C0C0C7CCCCC7C00    <1> 	db	 0Ch,  0Ch,  0Ch,  7Ch, 0CCh, 0CCh,  7Ch,  00h
  1918 00005D96 000078CCFCC07800    <1> 	db	 00h,  00h,  78h, 0CCh, 0FCh, 0C0h,  78h,  00h
  1919 00005D9E 386C60F06060F000    <1> 	db	 38h,  6Ch,  60h, 0F0h,  60h,  60h, 0F0h,  00h
  1920 00005DA6 00007CCCCC7C0CF8    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  1921 00005DAE 60607C6666666600    <1> 	db	 60h,  60h,  7Ch,  66h,  66h,  66h,  66h,  00h
  1922 00005DB6 3000703030307800    <1> 	db	 30h,  00h,  70h,  30h,  30h,  30h,  78h,  00h
  1923 00005DBE 0C000C0C0C0C6C38    <1> 	db	 0Ch,  00h,  0Ch,  0Ch,  0Ch,  0Ch,  6Ch,  38h
  1924 00005DC6 6060666C786C6600    <1> 	db	 60h,  60h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
  1925 00005DCE 7030303030307800    <1> 	db	 70h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  1926 00005DD6 0000CCFEFED6C600    <1> 	db	 00h,  00h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h,  00h
  1927 00005DDE 0000F8CCCCCCCC00    <1> 	db	 00h,  00h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh,  00h
  1928 00005DE6 000078CCCCCC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0CCh, 0CCh,  78h,  00h
  1929 00005DEE 00007C66667C6060    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  60h
  1930 00005DF6 00007CCCCC7C0C0C    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch,  0Ch
  1931 00005DFE 0000DC766660F000    <1> 	db	 00h,  00h, 0DCh,  76h,  66h,  60h, 0F0h,  00h
  1932 00005E06 00007CC0780CF800    <1> 	db	 00h,  00h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  00h
  1933 00005E0E 10307C3030341800    <1> 	db	 10h,  30h,  7Ch,  30h,  30h,  34h,  18h,  00h
  1934 00005E16 0000CCCCCCCC7C00    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh, 0CCh,  7Ch,  00h
  1935 00005E1E 0000CCCCCC783000    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  1936 00005E26 0000C6D6FEFE6C00    <1> 	db	 00h,  00h, 0C6h, 0D6h, 0FEh, 0FEh,  6Ch,  00h
  1937 00005E2E 0000C66C386CC600    <1> 	db	 00h,  00h, 0C6h,  6Ch,  38h,  6Ch, 0C6h,  00h
  1938 00005E36 0000CCCCCC7C0CF8    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  1939 00005E3E 0000FC983064FC00    <1> 	db	 00h,  00h, 0FCh,  98h,  30h,  64h, 0FCh,  00h
  1940 00005E46 1C3030E030301C00    <1> 	db	 1Ch,  30h,  30h, 0E0h,  30h,  30h,  1Ch,  00h
  1941 00005E4E 1818180018181800    <1> 	db	 18h,  18h,  18h,  00h,  18h,  18h,  18h,  00h
  1942 00005E56 E030301C3030E000    <1> 	db	0E0h,  30h,  30h,  1Ch,  30h,  30h, 0E0h,  00h
  1943 00005E5E 76DC000000000000    <1> 	db	 76h, 0DCh,  00h,  00h,  00h,  00h,  00h,  00h
  1944 00005E66 0010386CC6C6FE00    <1> 	db	 00h,  10h,  38h,  6Ch, 0C6h, 0C6h, 0FEh,  00h
  1792                                  %include	"time2.inc"
  1793                              <1> ;=========================================================================
  1794                              <1> ; time2.int - BIOS Time Services
  1795                              <1> ;       INT 1Ah - BIOS Time Serivces
  1796                              <1> ;		dispatcher
  1797                              <1> ;       INT 08h - IRQ0 interrupt handler (timer interrupt)
  1798                              <1> ;-------------------------------------------------------------------------
  1799                              <1> ;
  1800                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1801                              <1> ;
  1802                              <1> ; Copyright (C) 2010 - 2025 Sergey Kiselev.
  1803                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1804                              <1> ;
  1805                              <1> ; This program is free software: you can redistribute it and/or modify
  1806                              <1> ; it under the terms of the GNU General Public License as published by
  1807                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1808                              <1> ; (at your option) any later version.
  1809                              <1> ;
  1810                              <1> ; This program is distributed in the hope that it will be useful,
  1811                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1812                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1813                              <1> ; GNU General Public License for more details.
  1814                              <1> ;
  1815                              <1> ; You should have received a copy of the GNU General Public License
  1816                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1817                              <1> ;
  1818                              <1> ;=========================================================================
  1819                              <1> 
  1820                              <1> ;=========================================================================
  1821                              <1> ; int_1A - BIOS Time Services
  1822                              <1> ; Note: see time1.inc for functions implementation
  1823                              <1> ;-------------------------------------------------------------------------
  1824                              <1> 	setloc	0FE6Eh			; INT 1A Entry Point
  1825                              <1> int_1A:
  1826 00005E6E 53                  <1> 	push	bx
  1827 00005E6F 1E                  <1> 	push	ds
  1828 00005E70 BB4000              <1> 	mov	bx,biosdseg
  1829 00005E73 8EDB                <1> 	mov	ds,bx
  1830 00005E75 80FC08              <1> 	cmp	ah,.max/2
  1831 00005E78 731B                <1> 	jae	int_1A_exit
  1832 00005E7A B700                <1> 	mov	bh,0
  1833 00005E7C 88E3                <1> 	mov	bl,ah
  1834 00005E7E D1E3                <1> 	shl	bx,1
  1835 00005E80 2EFFA7[855E]        <1>     cs	jmp	near [.dispatch+bx]
  1836                              <1> .dispatch:
  1837 00005E85 [CA16]              <1> 	dw	int_1A_fn00
  1838 00005E87 [DC16]              <1> 	dw	int_1A_fn01
  1839                              <1> %ifdef AT_RTC
  1840 00005E89 [EC16]              <1> 	dw	int_1A_fn02
  1841 00005E8B [2617]              <1> 	dw	int_1A_fn03
  1842 00005E8D [7317]              <1> 	dw	int_1A_fn04
  1843 00005E8F [AB17]              <1> 	dw	int_1A_fn05
  1844 00005E91 [F217]              <1> 	dw	int_1A_fn06
  1845 00005E93 [4B18]              <1> 	dw	int_1A_fn07
  1846                              <1> %endif ; AT_RTC
  1847                              <1> .max	equ	$-.dispatch
  1848                              <1> int_1A_exit:
  1849 00005E95 1F                  <1> 	pop	ds
  1850 00005E96 5B                  <1> 	pop	bx
  1851 00005E97 CF                  <1> 	iret
  1852                              <1> int_1A_exitf:
  1853 00005E98 1F                  <1> 	pop	ds
  1854 00005E99 5B                  <1> 	pop	bx
  1855 00005E9A CA0200              <1> 	retf	2
  1856                              <1> 
  1857                              <1> ;=========================================================================
  1858                              <1> ; int_08 - IRQ0 ISR, called approximately every 55ms
  1859                              <1> ;-------------------------------------------------------------------------
  1860 00005E9D FF<rep 8h>          <1> 	setloc	0FEA5h			; INT 08 Entry Point
  1860          ******************  <1>  warning: Inserting 8 bytes [-w+user]
  1861                              <1> int_08:
  1862 00005EA5 50                  <1> 	push	ax
  1863 00005EA6 52                  <1> 	push	dx
  1864 00005EA7 1E                  <1> 	push	ds
  1865 00005EA8 B84000              <1> 	mov	ax,biosdseg
  1866 00005EAB 8ED8                <1> 	mov	ds,ax
  1867 00005EAD 803E400000          <1> 	cmp	byte [fdc_motor_tout],0
  1868 00005EB2 7411                <1> 	jz	.1
  1869 00005EB4 FE0E4000            <1> 	dec	byte [fdc_motor_tout]
  1870 00005EB8 750B                <1> 	jnz	.1
  1871 00005EBA 80263F00F0          <1> 	and	byte [fdc_motor_state],0F0h ; update fdc_motor_state byte
  1872 00005EBF B00C                <1> 	mov	al,0Ch			; turn off motors, enable DMA + IRQ
  1873 00005EC1 BAF203              <1> 	mov	dx,fdc_dor_reg		; write it to Digital Output register
  1874 00005EC4 EE                  <1> 	out	dx,al
  1875                              <1> .1:
  1876 00005EC5 FF066C00            <1> 	inc	word [ticks_lo]
  1877 00005EC9 7504                <1> 	jnz	.2
  1878 00005ECB FF066E00            <1> 	inc	word [ticks_hi]
  1879                              <1> .2:
  1880 00005ECF 833E6E0018          <1> 	cmp	word [ticks_hi],18h	; 1573042 ticks in one day
  1881 00005ED4 7519                <1> 	jnz	.3			; which is 65536 * 24 + 178 or
  1882 00005ED6 813E6C00B200        <1> 	cmp	word [ticks_lo],0B2h	; 10000h * 18h + 0B2h
  1883 00005EDC 7511                <1> 	jnz	.3
  1884 00005EDE C7066E000000        <1> 	mov	word [ticks_hi],0
  1885 00005EE4 C7066C000000        <1> 	mov	word [ticks_lo],0
  1886 00005EEA C606700001          <1> 	mov	byte [new_day],1
  1887                              <1> .3:
  1888 00005EEF CD1C                <1> 	int	1Ch			; User timer interrupt
  1889 00005EF1 B020                <1> 	mov	al,20h
  1890 00005EF3 E620                <1> 	out	pic1_reg0,al
  1891 00005EF5 1F                  <1> 	pop	ds
  1892 00005EF6 5A                  <1> 	pop	dx
  1893 00005EF7 58                  <1> 	pop	ax
  1894 00005EF8 CF                  <1> 	iret
  1793                                  
  1794                                  ;=========================================================================
  1795                                  ; int_ignore - signal end of interrupt to PIC if hardware interrupt, return
  1796                                  ;-------------------------------------------------------------------------
  1797 00005EF9 FF<rep 2Ah>             	setloc	0FF23h			; Spurious IRQ Handler Entry Point
  1797          ******************       warning: Inserting 42 bytes [-w+user]
  1798                                  int_ignore:
  1799 00005F23 50                      	push	ax
  1800 00005F24 1E                      	push	ds
  1801 00005F25 B84000                  	mov	ax,biosdseg
  1802 00005F28 8ED8                    	mov	ds,ax
  1803 00005F2A B00B                    	mov	al,0Bh			; PIC OCW3 - read in-service register
  1804 00005F2C E620                    	out	pic1_reg0,al
  1805 00005F2E 90                      	nop
  1806 00005F2F E420                    	in	al,pic1_reg0		; get IRQ number
  1807 00005F31 88C4                    	mov	ah,al
  1808 00005F33 08C0                    	or	al,al
  1809 00005F35 7504                    	jnz	.1
  1810 00005F37 B4FF                    	mov	ah,0FFh
  1811 00005F39 EB0A                    	jmp	.2
  1812                                  .1:
  1813 00005F3B E421                    	in	al,pic1_reg1		; clear the interrupt
  1814 00005F3D 08E0                    	or	al,ah
  1815 00005F3F E621                    	out	pic1_reg1,al
  1816 00005F41 B020                    	mov	al,20h			; end of interrupt
  1817 00005F43 E620                    	out	pic1_reg0,al		; signal end of interrupt
  1818                                  .2:
  1819 00005F45 88266B00                	mov	byte [last_irq],ah
  1820 00005F49 1F                      	pop	ds
  1821 00005F4A 58                      	pop	ax
  1822 00005F4B CF                      	iret
  1823                                  
  1824                                  ;=========================================================================
  1825                                  ; int_dummy - Dummy interrupt handler. Do nothing, return.
  1826                                  ;-------------------------------------------------------------------------
  1827 00005F4C FF<rep 7h>              	setloc	0FF53h			; Dummy Interrupt Handler
  1827          ******************       warning: Inserting 7 bytes [-w+user]
  1828                                  int_dummy:
  1829 00005F53 CF                      	iret
  1830                                  
  1831                                  ;=========================================================================
  1832                                  ; int_05 - BIOS Print Screen
  1833                                  ;-------------------------------------------------------------------------
  1834                                  	setloc	0FF54h			; INT 05 (Print Screen) Entry Point
  1835                                  int_05:
  1836 00005F54 FB                      	sti
  1837 00005F55 50                      	push	ax
  1838 00005F56 53                      	push	bx
  1839 00005F57 51                      	push	cx
  1840 00005F58 52                      	push	dx
  1841 00005F59 1E                      	push	ds
  1842 00005F5A B84000                  	mov	ax,biosdseg
  1843 00005F5D 8ED8                    	mov	ds,ax			; DS = BIOS data segment
  1844 00005F5F 803E000101              	cmp	byte [prt_scrn_flags],prt_scrn_run
  1845 00005F64 746A                    	je	.exit			; print screen is already in progress
  1846 00005F66 C606000101              	mov	byte [prt_scrn_flags],prt_scrn_run
  1847                                  					; signal that print screen is running
  1848                                  
  1849 00005F6B B40F                    	mov	ah,0Fh			; get video mode parameters
  1850 00005F6D CD10                    	int	10h			; returns number of columns in AH
  1851                                  					; and active display page in BH
  1852 00005F6F 88E1                    	mov	cl,ah			; store number columns
  1853                                  
  1854 00005F71 8A2E8400                	mov	ch,byte [video_rows]	; try getting number of rows
  1855 00005F75 08ED                    	or	ch,ch
  1856 00005F77 7407                    	jz	.wrong_num_rows		; CH == 0, apparently not initialized
  1857                                  
  1858 00005F79 FEC5                    	inc	ch			; CH = number of rows (on EGA/VGA)
  1859 00005F7B 80FD3C                  	cmp	ch,60			; 60 rows maximum (as far as I know)
  1860 00005F7E 7602                    	jbe	.get_cursor_pos
  1861                                  
  1862                                  .wrong_num_rows:
  1863 00005F80 B519                    	mov	ch,25			; assume 25 rows
  1864                                  
  1865                                  .get_cursor_pos:
  1866 00005F82 B403                    	mov	ah,03h			; get cursor position and size
  1867 00005F84 CD10                    	int	10h			; returns cursor position in DX
  1868 00005F86 52                      	push	dx			; save original position / DX in stack
  1869                                  
  1870                                  	
  1871 00005F87 B40D                    	mov	ah,0Dh			; move to the next line
  1872 00005F89 E85100                  	call	.print_char
  1873 00005F8C 7548                    	jnz	.error
  1874 00005F8E B40A                    	mov	ah,0Ah
  1875 00005F90 E84A00                  	call	.print_char
  1876 00005F93 7541                    	jnz	.error
  1877                                  
  1878 00005F95 B600                    	mov 	dh,0			; start from the first row (0)
  1879                                  
  1880                                  .row_loop:
  1881 00005F97 B200                    	mov 	dl,0			; start from the first column (0)
  1882                                  
  1883                                  .column_loop:
  1884 00005F99 B402                    	mov	ah,02h
  1885 00005F9B CD10                    	int	10h			; set cursor position (position in DX)
  1886                                  
  1887 00005F9D B408                    	mov	ah,08h
  1888 00005F9F CD10                    	int	10h			; read character at cursor position
  1889                                  
  1890 00005FA1 3C20                    	cmp	al,20h			; control character?
  1891 00005FA3 7302                    	jae	.continue		; no, print it
  1892 00005FA5 B020                    	mov	al,20h			; print space instead
  1893                                  
  1894                                  .continue:
  1895 00005FA7 E83300                  	call	.print_char
  1896 00005FAA 752A                    	jnz	.error
  1897 00005FAC FEC2                    	inc	dl
  1898 00005FAE 38CA                    	cmp	dl,cl			; on the last column?
  1899 00005FB0 72E7                    	jb	.column_loop		; print next column
  1900                                  
  1901 00005FB2 B40D                    	mov	ah,0Dh			; move to the next line
  1902 00005FB4 E82600                  	call	.print_char
  1903 00005FB7 751D                    	jnz	.error
  1904 00005FB9 B40A                    	mov	ah,0Ah
  1905 00005FBB E81F00                  	call	.print_char
  1906 00005FBE 7516                    	jnz	.error
  1907                                  
  1908 00005FC0 FEC6                    	inc	dh
  1909 00005FC2 38EE                    	cmp	dh,ch			; on the last row?
  1910 00005FC4 72D1                    	jb	.row_loop		; print next row
  1911                                  
  1912 00005FC6 C606000100              	mov	byte [prt_scrn_flags],prt_scrn_ready
  1913                                  					; ready for the next call
  1914                                  
  1915                                  .restore_cursor:
  1916 00005FCB 5A                      	pop	dx			; DX = original cursor position
  1917 00005FCC B402                    	mov	ah,02h
  1918 00005FCE CD10                    	int	10h			; set cursor position (position in DX)
  1919                                  
  1920                                  .exit:
  1921 00005FD0 1F                      	pop	ds
  1922 00005FD1 5A                      	pop	dx
  1923 00005FD2 59                      	pop	cx
  1924 00005FD3 5B                      	pop	bx
  1925 00005FD4 58                      	pop	ax
  1926 00005FD5 CF                      	iret
  1927                                  
  1928                                  .error:
  1929 00005FD6 C6060001FF              	mov	byte [prt_scrn_flags],prt_scrn_fail
  1930                                  					; signal failure
  1931 00005FDB EBEE                    	jmp	.restore_cursor
  1932                                  	
  1933                                  
  1934                                  .print_char:
  1935 00005FDD 52                      	push	dx
  1936 00005FDE 31D2                    	xor	dx,dx			; DX = 0 - first printer port
  1937 00005FE0 B400                    	mov	ah,00h			; INT 17h, AH=10h - print character
  1938 00005FE2 CD17                    	int	17h
  1939 00005FE4 5A                      	pop	dx
  1940 00005FE5 F6C425                  	test	ah,25h			; ZF = 0 - no error
  1941 00005FE8 C3                      	ret
  1942                                  
  1943                                  ;=========================================================================
  1944                                  ; start - at power up or reset execution starts here (F000:FFF0)
  1945                                  ;-------------------------------------------------------------------------
  1946 00005FE9 FF<rep 7h>                      setloc	0FFF0h			; Power-On Entry Point
  1946          ******************       warning: Inserting 7 bytes [-w+user]
  1947                                  start:
  1948 00005FF0 EA[5B40]00F0                    jmp     bioscseg:cold_start
  1949                                  
  1950                                  	setloc	0FFF5h			; ROM Date in ASCII
  1951 00005FF5 30392F32372F3235        	db	DATE			; BIOS release date MM/DD/YY
  1952 00005FFD 20                      	db	20h
  1953                                  
  1954                                  	setloc	0FFFEh			; System Model byte
  1955 00005FFE FE                      	db	MODEL_BYTE
  1956 00005FFF FF                      	db	0ffh
